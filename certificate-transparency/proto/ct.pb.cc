// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/ct.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "proto/ct.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ct {

namespace {

const ::google::protobuf::Descriptor* DigitallySigned_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DigitallySigned_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* DigitallySigned_HashAlgorithm_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* DigitallySigned_SignatureAlgorithm_descriptor_ = NULL;
const ::google::protobuf::Descriptor* X509ChainEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  X509ChainEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* PreCert_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PreCert_reflection_ = NULL;
const ::google::protobuf::Descriptor* CertInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CertInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* PrecertChainEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PrecertChainEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* XJSONEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  XJSONEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* LogEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* LogID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogID_reflection_ = NULL;
const ::google::protobuf::Descriptor* SctExtension_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SctExtension_reflection_ = NULL;
const ::google::protobuf::Descriptor* SignedCertificateTimestamp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SignedCertificateTimestamp_reflection_ = NULL;
const ::google::protobuf::Descriptor* SignedCertificateTimestampList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SignedCertificateTimestampList_reflection_ = NULL;
const ::google::protobuf::Descriptor* SignedEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SignedEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* TimestampedEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TimestampedEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* MerkleTreeLeaf_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MerkleTreeLeaf_reflection_ = NULL;
const ::google::protobuf::Descriptor* MerkleAuditProof_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MerkleAuditProof_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShortMerkleAuditProof_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShortMerkleAuditProof_reflection_ = NULL;
const ::google::protobuf::Descriptor* LoggedEntryPB_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LoggedEntryPB_reflection_ = NULL;
const ::google::protobuf::Descriptor* LoggedEntryPB_Contents_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LoggedEntryPB_Contents_reflection_ = NULL;
const ::google::protobuf::Descriptor* SthExtension_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SthExtension_reflection_ = NULL;
const ::google::protobuf::Descriptor* SignedTreeHead_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SignedTreeHead_reflection_ = NULL;
const ::google::protobuf::Descriptor* SSLClientCTData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SSLClientCTData_reflection_ = NULL;
const ::google::protobuf::Descriptor* SSLClientCTData_SCTInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SSLClientCTData_SCTInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClusterNodeState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClusterNodeState_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClusterControl_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClusterControl_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClusterConfig_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClusterConfig_reflection_ = NULL;
const ::google::protobuf::Descriptor* SequenceMapping_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SequenceMapping_reflection_ = NULL;
const ::google::protobuf::Descriptor* SequenceMapping_Mapping_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SequenceMapping_Mapping_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* LogEntryType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* SignatureType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Version_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* MerkleLeafType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_proto_2fct_2eproto() {
  protobuf_AddDesc_proto_2fct_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "proto/ct.proto");
  GOOGLE_CHECK(file != NULL);
  DigitallySigned_descriptor_ = file->message_type(0);
  static const int DigitallySigned_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DigitallySigned, hash_algorithm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DigitallySigned, sig_algorithm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DigitallySigned, signature_),
  };
  DigitallySigned_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DigitallySigned_descriptor_,
      DigitallySigned::default_instance_,
      DigitallySigned_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DigitallySigned, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DigitallySigned, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DigitallySigned));
  DigitallySigned_HashAlgorithm_descriptor_ = DigitallySigned_descriptor_->enum_type(0);
  DigitallySigned_SignatureAlgorithm_descriptor_ = DigitallySigned_descriptor_->enum_type(1);
  X509ChainEntry_descriptor_ = file->message_type(1);
  static const int X509ChainEntry_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(X509ChainEntry, leaf_certificate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(X509ChainEntry, cert_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(X509ChainEntry, certificate_chain_),
  };
  X509ChainEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      X509ChainEntry_descriptor_,
      X509ChainEntry::default_instance_,
      X509ChainEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(X509ChainEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(X509ChainEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(X509ChainEntry));
  PreCert_descriptor_ = file->message_type(2);
  static const int PreCert_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PreCert, issuer_key_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PreCert, tbs_certificate_),
  };
  PreCert_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PreCert_descriptor_,
      PreCert::default_instance_,
      PreCert_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PreCert, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PreCert, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PreCert));
  CertInfo_descriptor_ = file->message_type(3);
  static const int CertInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertInfo, issuer_key_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertInfo, tbs_certificate_),
  };
  CertInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CertInfo_descriptor_,
      CertInfo::default_instance_,
      CertInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CertInfo));
  PrecertChainEntry_descriptor_ = file->message_type(4);
  static const int PrecertChainEntry_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrecertChainEntry, pre_certificate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrecertChainEntry, precertificate_chain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrecertChainEntry, pre_cert_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrecertChainEntry, cert_info_),
  };
  PrecertChainEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PrecertChainEntry_descriptor_,
      PrecertChainEntry::default_instance_,
      PrecertChainEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrecertChainEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrecertChainEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PrecertChainEntry));
  XJSONEntry_descriptor_ = file->message_type(5);
  static const int XJSONEntry_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XJSONEntry, json_),
  };
  XJSONEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      XJSONEntry_descriptor_,
      XJSONEntry::default_instance_,
      XJSONEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XJSONEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XJSONEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(XJSONEntry));
  LogEntry_descriptor_ = file->message_type(6);
  static const int LogEntry_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogEntry, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogEntry, x509_entry_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogEntry, precert_entry_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogEntry, x_json_entry_),
  };
  LogEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogEntry_descriptor_,
      LogEntry::default_instance_,
      LogEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogEntry));
  LogID_descriptor_ = file->message_type(7);
  static const int LogID_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogID, key_id_),
  };
  LogID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogID_descriptor_,
      LogID::default_instance_,
      LogID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogID));
  SctExtension_descriptor_ = file->message_type(8);
  static const int SctExtension_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SctExtension, sct_extension_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SctExtension, sct_extension_data_),
  };
  SctExtension_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SctExtension_descriptor_,
      SctExtension::default_instance_,
      SctExtension_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SctExtension, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SctExtension, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SctExtension));
  SignedCertificateTimestamp_descriptor_ = file->message_type(9);
  static const int SignedCertificateTimestamp_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedCertificateTimestamp, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedCertificateTimestamp, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedCertificateTimestamp, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedCertificateTimestamp, signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedCertificateTimestamp, extensions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedCertificateTimestamp, sct_extension_),
  };
  SignedCertificateTimestamp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SignedCertificateTimestamp_descriptor_,
      SignedCertificateTimestamp::default_instance_,
      SignedCertificateTimestamp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedCertificateTimestamp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedCertificateTimestamp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SignedCertificateTimestamp));
  SignedCertificateTimestampList_descriptor_ = file->message_type(10);
  static const int SignedCertificateTimestampList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedCertificateTimestampList, sct_list_),
  };
  SignedCertificateTimestampList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SignedCertificateTimestampList_descriptor_,
      SignedCertificateTimestampList::default_instance_,
      SignedCertificateTimestampList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedCertificateTimestampList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedCertificateTimestampList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SignedCertificateTimestampList));
  SignedEntry_descriptor_ = file->message_type(11);
  static const int SignedEntry_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedEntry, x509_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedEntry, precert_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedEntry, json_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedEntry, cert_info_),
  };
  SignedEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SignedEntry_descriptor_,
      SignedEntry::default_instance_,
      SignedEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SignedEntry));
  TimestampedEntry_descriptor_ = file->message_type(12);
  static const int TimestampedEntry_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimestampedEntry, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimestampedEntry, entry_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimestampedEntry, signed_entry_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimestampedEntry, extensions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimestampedEntry, sct_extension_),
  };
  TimestampedEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TimestampedEntry_descriptor_,
      TimestampedEntry::default_instance_,
      TimestampedEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimestampedEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimestampedEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TimestampedEntry));
  MerkleTreeLeaf_descriptor_ = file->message_type(13);
  static const int MerkleTreeLeaf_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MerkleTreeLeaf, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MerkleTreeLeaf, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MerkleTreeLeaf, timestamped_entry_),
  };
  MerkleTreeLeaf_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MerkleTreeLeaf_descriptor_,
      MerkleTreeLeaf::default_instance_,
      MerkleTreeLeaf_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MerkleTreeLeaf, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MerkleTreeLeaf, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MerkleTreeLeaf));
  MerkleAuditProof_descriptor_ = file->message_type(14);
  static const int MerkleAuditProof_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MerkleAuditProof, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MerkleAuditProof, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MerkleAuditProof, tree_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MerkleAuditProof, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MerkleAuditProof, leaf_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MerkleAuditProof, path_node_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MerkleAuditProof, tree_head_signature_),
  };
  MerkleAuditProof_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MerkleAuditProof_descriptor_,
      MerkleAuditProof::default_instance_,
      MerkleAuditProof_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MerkleAuditProof, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MerkleAuditProof, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MerkleAuditProof));
  ShortMerkleAuditProof_descriptor_ = file->message_type(15);
  static const int ShortMerkleAuditProof_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShortMerkleAuditProof, leaf_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShortMerkleAuditProof, path_node_),
  };
  ShortMerkleAuditProof_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShortMerkleAuditProof_descriptor_,
      ShortMerkleAuditProof::default_instance_,
      ShortMerkleAuditProof_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShortMerkleAuditProof, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShortMerkleAuditProof, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShortMerkleAuditProof));
  LoggedEntryPB_descriptor_ = file->message_type(16);
  static const int LoggedEntryPB_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoggedEntryPB, sequence_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoggedEntryPB, merkle_leaf_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoggedEntryPB, contents_),
  };
  LoggedEntryPB_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LoggedEntryPB_descriptor_,
      LoggedEntryPB::default_instance_,
      LoggedEntryPB_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoggedEntryPB, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoggedEntryPB, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LoggedEntryPB));
  LoggedEntryPB_Contents_descriptor_ = LoggedEntryPB_descriptor_->nested_type(0);
  static const int LoggedEntryPB_Contents_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoggedEntryPB_Contents, sct_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoggedEntryPB_Contents, entry_),
  };
  LoggedEntryPB_Contents_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LoggedEntryPB_Contents_descriptor_,
      LoggedEntryPB_Contents::default_instance_,
      LoggedEntryPB_Contents_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoggedEntryPB_Contents, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoggedEntryPB_Contents, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LoggedEntryPB_Contents));
  SthExtension_descriptor_ = file->message_type(17);
  static const int SthExtension_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SthExtension, sth_extension_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SthExtension, sth_extension_data_),
  };
  SthExtension_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SthExtension_descriptor_,
      SthExtension::default_instance_,
      SthExtension_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SthExtension, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SthExtension, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SthExtension));
  SignedTreeHead_descriptor_ = file->message_type(18);
  static const int SignedTreeHead_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedTreeHead, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedTreeHead, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedTreeHead, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedTreeHead, tree_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedTreeHead, sha256_root_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedTreeHead, signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedTreeHead, sth_extension_),
  };
  SignedTreeHead_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SignedTreeHead_descriptor_,
      SignedTreeHead::default_instance_,
      SignedTreeHead_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedTreeHead, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedTreeHead, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SignedTreeHead));
  SSLClientCTData_descriptor_ = file->message_type(19);
  static const int SSLClientCTData_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSLClientCTData, reconstructed_entry_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSLClientCTData, certificate_sha256_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSLClientCTData, attached_sct_info_),
  };
  SSLClientCTData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SSLClientCTData_descriptor_,
      SSLClientCTData::default_instance_,
      SSLClientCTData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSLClientCTData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSLClientCTData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SSLClientCTData));
  SSLClientCTData_SCTInfo_descriptor_ = SSLClientCTData_descriptor_->nested_type(0);
  static const int SSLClientCTData_SCTInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSLClientCTData_SCTInfo, sct_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSLClientCTData_SCTInfo, merkle_leaf_hash_),
  };
  SSLClientCTData_SCTInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SSLClientCTData_SCTInfo_descriptor_,
      SSLClientCTData_SCTInfo::default_instance_,
      SSLClientCTData_SCTInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSLClientCTData_SCTInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSLClientCTData_SCTInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SSLClientCTData_SCTInfo));
  ClusterNodeState_descriptor_ = file->message_type(20);
  static const int ClusterNodeState_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterNodeState, node_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterNodeState, contiguous_tree_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterNodeState, newest_sth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterNodeState, current_serving_sth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterNodeState, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterNodeState, log_port_),
  };
  ClusterNodeState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClusterNodeState_descriptor_,
      ClusterNodeState::default_instance_,
      ClusterNodeState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterNodeState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterNodeState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClusterNodeState));
  ClusterControl_descriptor_ = file->message_type(21);
  static const int ClusterControl_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterControl, accept_new_entries_),
  };
  ClusterControl_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClusterControl_descriptor_,
      ClusterControl::default_instance_,
      ClusterControl_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterControl, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterControl, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClusterControl));
  ClusterConfig_descriptor_ = file->message_type(22);
  static const int ClusterConfig_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterConfig, minimum_serving_nodes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterConfig, minimum_serving_fraction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterConfig, etcd_reject_add_pending_threshold_),
  };
  ClusterConfig_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClusterConfig_descriptor_,
      ClusterConfig::default_instance_,
      ClusterConfig_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterConfig, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClusterConfig, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClusterConfig));
  SequenceMapping_descriptor_ = file->message_type(23);
  static const int SequenceMapping_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SequenceMapping, mapping_),
  };
  SequenceMapping_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SequenceMapping_descriptor_,
      SequenceMapping::default_instance_,
      SequenceMapping_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SequenceMapping, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SequenceMapping, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SequenceMapping));
  SequenceMapping_Mapping_descriptor_ = SequenceMapping_descriptor_->nested_type(0);
  static const int SequenceMapping_Mapping_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SequenceMapping_Mapping, entry_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SequenceMapping_Mapping, sequence_number_),
  };
  SequenceMapping_Mapping_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SequenceMapping_Mapping_descriptor_,
      SequenceMapping_Mapping::default_instance_,
      SequenceMapping_Mapping_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SequenceMapping_Mapping, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SequenceMapping_Mapping, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SequenceMapping_Mapping));
  LogEntryType_descriptor_ = file->enum_type(0);
  SignatureType_descriptor_ = file->enum_type(1);
  Version_descriptor_ = file->enum_type(2);
  MerkleLeafType_descriptor_ = file->enum_type(3);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_proto_2fct_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DigitallySigned_descriptor_, &DigitallySigned::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    X509ChainEntry_descriptor_, &X509ChainEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PreCert_descriptor_, &PreCert::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CertInfo_descriptor_, &CertInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PrecertChainEntry_descriptor_, &PrecertChainEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    XJSONEntry_descriptor_, &XJSONEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogEntry_descriptor_, &LogEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogID_descriptor_, &LogID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SctExtension_descriptor_, &SctExtension::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignedCertificateTimestamp_descriptor_, &SignedCertificateTimestamp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignedCertificateTimestampList_descriptor_, &SignedCertificateTimestampList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignedEntry_descriptor_, &SignedEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TimestampedEntry_descriptor_, &TimestampedEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MerkleTreeLeaf_descriptor_, &MerkleTreeLeaf::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MerkleAuditProof_descriptor_, &MerkleAuditProof::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShortMerkleAuditProof_descriptor_, &ShortMerkleAuditProof::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LoggedEntryPB_descriptor_, &LoggedEntryPB::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LoggedEntryPB_Contents_descriptor_, &LoggedEntryPB_Contents::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SthExtension_descriptor_, &SthExtension::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignedTreeHead_descriptor_, &SignedTreeHead::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SSLClientCTData_descriptor_, &SSLClientCTData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SSLClientCTData_SCTInfo_descriptor_, &SSLClientCTData_SCTInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClusterNodeState_descriptor_, &ClusterNodeState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClusterControl_descriptor_, &ClusterControl::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClusterConfig_descriptor_, &ClusterConfig::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SequenceMapping_descriptor_, &SequenceMapping::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SequenceMapping_Mapping_descriptor_, &SequenceMapping_Mapping::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_proto_2fct_2eproto() {
  delete DigitallySigned::default_instance_;
  delete DigitallySigned_reflection_;
  delete X509ChainEntry::default_instance_;
  delete X509ChainEntry_reflection_;
  delete PreCert::default_instance_;
  delete PreCert_reflection_;
  delete CertInfo::default_instance_;
  delete CertInfo_reflection_;
  delete PrecertChainEntry::default_instance_;
  delete PrecertChainEntry_reflection_;
  delete XJSONEntry::default_instance_;
  delete XJSONEntry_reflection_;
  delete LogEntry::default_instance_;
  delete LogEntry_reflection_;
  delete LogID::default_instance_;
  delete LogID_reflection_;
  delete SctExtension::default_instance_;
  delete SctExtension_reflection_;
  delete SignedCertificateTimestamp::default_instance_;
  delete SignedCertificateTimestamp_reflection_;
  delete SignedCertificateTimestampList::default_instance_;
  delete SignedCertificateTimestampList_reflection_;
  delete SignedEntry::default_instance_;
  delete SignedEntry_reflection_;
  delete TimestampedEntry::default_instance_;
  delete TimestampedEntry_reflection_;
  delete MerkleTreeLeaf::default_instance_;
  delete MerkleTreeLeaf_reflection_;
  delete MerkleAuditProof::default_instance_;
  delete MerkleAuditProof_reflection_;
  delete ShortMerkleAuditProof::default_instance_;
  delete ShortMerkleAuditProof_reflection_;
  delete LoggedEntryPB::default_instance_;
  delete LoggedEntryPB_reflection_;
  delete LoggedEntryPB_Contents::default_instance_;
  delete LoggedEntryPB_Contents_reflection_;
  delete SthExtension::default_instance_;
  delete SthExtension_reflection_;
  delete SignedTreeHead::default_instance_;
  delete SignedTreeHead_reflection_;
  delete SSLClientCTData::default_instance_;
  delete SSLClientCTData_reflection_;
  delete SSLClientCTData_SCTInfo::default_instance_;
  delete SSLClientCTData_SCTInfo_reflection_;
  delete ClusterNodeState::default_instance_;
  delete ClusterNodeState_reflection_;
  delete ClusterControl::default_instance_;
  delete ClusterControl_reflection_;
  delete ClusterConfig::default_instance_;
  delete ClusterConfig_reflection_;
  delete SequenceMapping::default_instance_;
  delete SequenceMapping_reflection_;
  delete SequenceMapping_Mapping::default_instance_;
  delete SequenceMapping_Mapping_reflection_;
}

void protobuf_AddDesc_proto_2fct_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016proto/ct.proto\022\002ct\"\317\002\n\017DigitallySigned"
    "\022\?\n\016hash_algorithm\030\001 \001(\0162!.ct.DigitallyS"
    "igned.HashAlgorithm:\004NONE\022H\n\rsig_algorit"
    "hm\030\002 \001(\0162&.ct.DigitallySigned.SignatureA"
    "lgorithm:\tANONYMOUS\022\021\n\tsignature\030\003 \001(\014\"\\"
    "\n\rHashAlgorithm\022\010\n\004NONE\020\000\022\007\n\003MD5\020\001\022\010\n\004SH"
    "A1\020\002\022\n\n\006SHA224\020\003\022\n\n\006SHA256\020\004\022\n\n\006SHA384\020\005"
    "\022\n\n\006SHA512\020\006\"@\n\022SignatureAlgorithm\022\r\n\tAN"
    "ONYMOUS\020\000\022\007\n\003RSA\020\001\022\007\n\003DSA\020\002\022\t\n\005ECDSA\020\003\"f"
    "\n\016X509ChainEntry\022\030\n\020leaf_certificate\030\001 \001"
    "(\014\022\037\n\tcert_info\030\003 \001(\0132\014.ct.CertInfo\022\031\n\021c"
    "ertificate_chain\030\002 \003(\014\";\n\007PreCert\022\027\n\017iss"
    "uer_key_hash\030\001 \001(\014\022\027\n\017tbs_certificate\030\002 "
    "\001(\014\"<\n\010CertInfo\022\027\n\017issuer_key_hash\030\001 \001(\014"
    "\022\027\n\017tbs_certificate\030\002 \001(\014\"\212\001\n\021PrecertCha"
    "inEntry\022\027\n\017pre_certificate\030\001 \001(\014\022\034\n\024prec"
    "ertificate_chain\030\002 \003(\014\022\035\n\010pre_cert\030\003 \001(\013"
    "2\013.ct.PreCert\022\037\n\tcert_info\030\004 \001(\0132\014.ct.Ce"
    "rtInfo\"\032\n\nXJSONEntry\022\014\n\004json\030\001 \001(\t\"\272\001\n\010L"
    "ogEntry\0222\n\004type\030\001 \001(\0162\020.ct.LogEntryType:"
    "\022UNKNOWN_ENTRY_TYPE\022&\n\nx509_entry\030\002 \001(\0132"
    "\022.ct.X509ChainEntry\022,\n\rprecert_entry\030\003 \001"
    "(\0132\025.ct.PrecertChainEntry\022$\n\014x_json_entr"
    "y\030\004 \001(\0132\016.ct.XJSONEntry\"\027\n\005LogID\022\016\n\006key_"
    "id\030\001 \001(\014\"F\n\014SctExtension\022\032\n\022sct_extensio"
    "n_type\030\001 \001(\r\022\032\n\022sct_extension_data\030\002 \001(\014"
    "\"\332\001\n\032SignedCertificateTimestamp\022-\n\007versi"
    "on\030\001 \001(\0162\013.ct.Version:\017UNKNOWN_VERSION\022\025"
    "\n\002id\030\002 \001(\0132\t.ct.LogID\022\021\n\ttimestamp\030\003 \001(\004"
    "\022&\n\tsignature\030\004 \001(\0132\023.ct.DigitallySigned"
    "\022\022\n\nextensions\030\005 \001(\014\022\'\n\rsct_extension\030\006 "
    "\003(\0132\020.ct.SctExtension\"2\n\036SignedCertifica"
    "teTimestampList\022\020\n\010sct_list\030\001 \003(\014\"h\n\013Sig"
    "nedEntry\022\014\n\004x509\030\001 \001(\014\022\034\n\007precert\030\002 \001(\0132"
    "\013.ct.PreCert\022\014\n\004json\030\003 \001(\014\022\037\n\tcert_info\030"
    "\004 \001(\0132\014.ct.CertInfo\"\257\001\n\020TimestampedEntry"
    "\022\021\n\ttimestamp\030\001 \001(\004\022$\n\nentry_type\030\002 \001(\0162"
    "\020.ct.LogEntryType\022%\n\014signed_entry\030\003 \001(\0132"
    "\017.ct.SignedEntry\022\022\n\nextensions\030\004 \001(\014\022\'\n\r"
    "sct_extension\030\005 \003(\0132\020.ct.SctExtension\"\245\001"
    "\n\016MerkleTreeLeaf\022-\n\007version\030\001 \001(\0162\013.ct.V"
    "ersion:\017UNKNOWN_VERSION\0223\n\004type\030\002 \001(\0162\022."
    "ct.MerkleLeafType:\021UNKNOWN_LEAF_TYPE\022/\n\021"
    "timestamped_entry\030\003 \001(\0132\024.ct.Timestamped"
    "Entry\"\327\001\n\020MerkleAuditProof\022-\n\007version\030\001 "
    "\001(\0162\013.ct.Version:\017UNKNOWN_VERSION\022\025\n\002id\030"
    "\002 \001(\0132\t.ct.LogID\022\021\n\ttree_size\030\003 \001(\003\022\021\n\tt"
    "imestamp\030\004 \001(\004\022\022\n\nleaf_index\030\005 \001(\003\022\021\n\tpa"
    "th_node\030\006 \003(\014\0220\n\023tree_head_signature\030\007 \001"
    "(\0132\023.ct.DigitallySigned\">\n\025ShortMerkleAu"
    "ditProof\022\022\n\nleaf_index\030\001 \002(\003\022\021\n\tpath_nod"
    "e\030\002 \003(\014\"\306\001\n\rLoggedEntryPB\022\027\n\017sequence_nu"
    "mber\030\001 \001(\003\022\030\n\020merkle_leaf_hash\030\002 \001(\014\022,\n\010"
    "contents\030\003 \002(\0132\032.ct.LoggedEntryPB.Conten"
    "ts\032T\n\010Contents\022+\n\003sct\030\001 \001(\0132\036.ct.SignedC"
    "ertificateTimestamp\022\033\n\005entry\030\002 \001(\0132\014.ct."
    "LogEntry\"F\n\014SthExtension\022\032\n\022sth_extensio"
    "n_type\030\001 \001(\r\022\032\n\022sth_extension_data\030\002 \001(\014"
    "\"\347\001\n\016SignedTreeHead\022-\n\007version\030\001 \001(\0162\013.c"
    "t.Version:\017UNKNOWN_VERSION\022\025\n\002id\030\002 \001(\0132\t"
    ".ct.LogID\022\021\n\ttimestamp\030\003 \001(\004\022\021\n\ttree_siz"
    "e\030\004 \001(\003\022\030\n\020sha256_root_hash\030\005 \001(\014\022&\n\tsig"
    "nature\030\006 \001(\0132\023.ct.DigitallySigned\022\'\n\rsth"
    "_extension\030\007 \003(\0132\020.ct.SthExtension\"\347\001\n\017S"
    "SLClientCTData\022)\n\023reconstructed_entry\030\001 "
    "\001(\0132\014.ct.LogEntry\022\037\n\027certificate_sha256_"
    "hash\030\002 \001(\014\0226\n\021attached_sct_info\030\003 \003(\0132\033."
    "ct.SSLClientCTData.SCTInfo\032P\n\007SCTInfo\022+\n"
    "\003sct\030\001 \001(\0132\036.ct.SignedCertificateTimesta"
    "mp\022\030\n\020merkle_leaf_hash\030\002 \001(\014\"\302\001\n\020Cluster"
    "NodeState\022\017\n\007node_id\030\001 \001(\t\022 \n\024contiguous"
    "_tree_size\030\002 \001(\003B\002\030\001\022&\n\nnewest_sth\030\003 \001(\013"
    "2\022.ct.SignedTreeHead\022/\n\023current_serving_"
    "sth\030\004 \001(\0132\022.ct.SignedTreeHead\022\020\n\010hostnam"
    "e\030\005 \001(\t\022\020\n\010log_port\030\006 \001(\005\"2\n\016ClusterCont"
    "rol\022 \n\022accept_new_entries\030\001 \001(\010:\004true\"\202\001"
    "\n\rClusterConfig\022\035\n\025minimum_serving_nodes"
    "\030\001 \001(\005\022 \n\030minimum_serving_fraction\030\002 \001(\001"
    "\0220\n!etcd_reject_add_pending_threshold\030\003 "
    "\001(\001:\00530000\"w\n\017SequenceMapping\022,\n\007mapping"
    "\030\001 \003(\0132\033.ct.SequenceMapping.Mapping\0326\n\007M"
    "apping\022\022\n\nentry_hash\030\001 \001(\014\022\027\n\017sequence_n"
    "umber\030\002 \001(\003*u\n\014LogEntryType\022\016\n\nX509_ENTR"
    "Y\020\000\022\021\n\rPRECERT_ENTRY\020\001\022\024\n\020PRECERT_ENTRY_"
    "V2\020\002\022\022\n\014X_JSON_ENTRY\020\200\200\002\022\030\n\022UNKNOWN_ENTR"
    "Y_TYPE\020\200\200\004*9\n\rSignatureType\022\031\n\025CERTIFICA"
    "TE_TIMESTAMP\020\000\022\r\n\tTREE_HEAD\020\001*/\n\007Version"
    "\022\006\n\002V1\020\000\022\006\n\002V2\020\001\022\024\n\017UNKNOWN_VERSION\020\200\002*\?"
    "\n\016MerkleLeafType\022\025\n\021TIMESTAMPED_ENTRY\020\000\022"
    "\026\n\021UNKNOWN_LEAF_TYPE\020\200\002", 3583);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "proto/ct.proto", &protobuf_RegisterTypes);
  DigitallySigned::default_instance_ = new DigitallySigned();
  X509ChainEntry::default_instance_ = new X509ChainEntry();
  PreCert::default_instance_ = new PreCert();
  CertInfo::default_instance_ = new CertInfo();
  PrecertChainEntry::default_instance_ = new PrecertChainEntry();
  XJSONEntry::default_instance_ = new XJSONEntry();
  LogEntry::default_instance_ = new LogEntry();
  LogID::default_instance_ = new LogID();
  SctExtension::default_instance_ = new SctExtension();
  SignedCertificateTimestamp::default_instance_ = new SignedCertificateTimestamp();
  SignedCertificateTimestampList::default_instance_ = new SignedCertificateTimestampList();
  SignedEntry::default_instance_ = new SignedEntry();
  TimestampedEntry::default_instance_ = new TimestampedEntry();
  MerkleTreeLeaf::default_instance_ = new MerkleTreeLeaf();
  MerkleAuditProof::default_instance_ = new MerkleAuditProof();
  ShortMerkleAuditProof::default_instance_ = new ShortMerkleAuditProof();
  LoggedEntryPB::default_instance_ = new LoggedEntryPB();
  LoggedEntryPB_Contents::default_instance_ = new LoggedEntryPB_Contents();
  SthExtension::default_instance_ = new SthExtension();
  SignedTreeHead::default_instance_ = new SignedTreeHead();
  SSLClientCTData::default_instance_ = new SSLClientCTData();
  SSLClientCTData_SCTInfo::default_instance_ = new SSLClientCTData_SCTInfo();
  ClusterNodeState::default_instance_ = new ClusterNodeState();
  ClusterControl::default_instance_ = new ClusterControl();
  ClusterConfig::default_instance_ = new ClusterConfig();
  SequenceMapping::default_instance_ = new SequenceMapping();
  SequenceMapping_Mapping::default_instance_ = new SequenceMapping_Mapping();
  DigitallySigned::default_instance_->InitAsDefaultInstance();
  X509ChainEntry::default_instance_->InitAsDefaultInstance();
  PreCert::default_instance_->InitAsDefaultInstance();
  CertInfo::default_instance_->InitAsDefaultInstance();
  PrecertChainEntry::default_instance_->InitAsDefaultInstance();
  XJSONEntry::default_instance_->InitAsDefaultInstance();
  LogEntry::default_instance_->InitAsDefaultInstance();
  LogID::default_instance_->InitAsDefaultInstance();
  SctExtension::default_instance_->InitAsDefaultInstance();
  SignedCertificateTimestamp::default_instance_->InitAsDefaultInstance();
  SignedCertificateTimestampList::default_instance_->InitAsDefaultInstance();
  SignedEntry::default_instance_->InitAsDefaultInstance();
  TimestampedEntry::default_instance_->InitAsDefaultInstance();
  MerkleTreeLeaf::default_instance_->InitAsDefaultInstance();
  MerkleAuditProof::default_instance_->InitAsDefaultInstance();
  ShortMerkleAuditProof::default_instance_->InitAsDefaultInstance();
  LoggedEntryPB::default_instance_->InitAsDefaultInstance();
  LoggedEntryPB_Contents::default_instance_->InitAsDefaultInstance();
  SthExtension::default_instance_->InitAsDefaultInstance();
  SignedTreeHead::default_instance_->InitAsDefaultInstance();
  SSLClientCTData::default_instance_->InitAsDefaultInstance();
  SSLClientCTData_SCTInfo::default_instance_->InitAsDefaultInstance();
  ClusterNodeState::default_instance_->InitAsDefaultInstance();
  ClusterControl::default_instance_->InitAsDefaultInstance();
  ClusterConfig::default_instance_->InitAsDefaultInstance();
  SequenceMapping::default_instance_->InitAsDefaultInstance();
  SequenceMapping_Mapping::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_proto_2fct_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_proto_2fct_2eproto {
  StaticDescriptorInitializer_proto_2fct_2eproto() {
    protobuf_AddDesc_proto_2fct_2eproto();
  }
} static_descriptor_initializer_proto_2fct_2eproto_;
const ::google::protobuf::EnumDescriptor* LogEntryType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogEntryType_descriptor_;
}
bool LogEntryType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 32768:
    case 65536:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* SignatureType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignatureType_descriptor_;
}
bool SignatureType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* Version_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Version_descriptor_;
}
bool Version_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 256:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* MerkleLeafType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MerkleLeafType_descriptor_;
}
bool MerkleLeafType_IsValid(int value) {
  switch(value) {
    case 0:
    case 256:
      return true;
    default:
      return false;
  }
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* DigitallySigned_HashAlgorithm_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DigitallySigned_HashAlgorithm_descriptor_;
}
bool DigitallySigned_HashAlgorithm_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DigitallySigned_HashAlgorithm DigitallySigned::NONE;
const DigitallySigned_HashAlgorithm DigitallySigned::MD5;
const DigitallySigned_HashAlgorithm DigitallySigned::SHA1;
const DigitallySigned_HashAlgorithm DigitallySigned::SHA224;
const DigitallySigned_HashAlgorithm DigitallySigned::SHA256;
const DigitallySigned_HashAlgorithm DigitallySigned::SHA384;
const DigitallySigned_HashAlgorithm DigitallySigned::SHA512;
const DigitallySigned_HashAlgorithm DigitallySigned::HashAlgorithm_MIN;
const DigitallySigned_HashAlgorithm DigitallySigned::HashAlgorithm_MAX;
const int DigitallySigned::HashAlgorithm_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* DigitallySigned_SignatureAlgorithm_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DigitallySigned_SignatureAlgorithm_descriptor_;
}
bool DigitallySigned_SignatureAlgorithm_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DigitallySigned_SignatureAlgorithm DigitallySigned::ANONYMOUS;
const DigitallySigned_SignatureAlgorithm DigitallySigned::RSA;
const DigitallySigned_SignatureAlgorithm DigitallySigned::DSA;
const DigitallySigned_SignatureAlgorithm DigitallySigned::ECDSA;
const DigitallySigned_SignatureAlgorithm DigitallySigned::SignatureAlgorithm_MIN;
const DigitallySigned_SignatureAlgorithm DigitallySigned::SignatureAlgorithm_MAX;
const int DigitallySigned::SignatureAlgorithm_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int DigitallySigned::kHashAlgorithmFieldNumber;
const int DigitallySigned::kSigAlgorithmFieldNumber;
const int DigitallySigned::kSignatureFieldNumber;
#endif  // !_MSC_VER

DigitallySigned::DigitallySigned()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.DigitallySigned)
}

void DigitallySigned::InitAsDefaultInstance() {
}

DigitallySigned::DigitallySigned(const DigitallySigned& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.DigitallySigned)
}

void DigitallySigned::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  hash_algorithm_ = 0;
  sig_algorithm_ = 0;
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DigitallySigned::~DigitallySigned() {
  // @@protoc_insertion_point(destructor:ct.DigitallySigned)
  SharedDtor();
}

void DigitallySigned::SharedDtor() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (this != default_instance_) {
  }
}

void DigitallySigned::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DigitallySigned::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DigitallySigned_descriptor_;
}

const DigitallySigned& DigitallySigned::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

DigitallySigned* DigitallySigned::default_instance_ = NULL;

DigitallySigned* DigitallySigned::New() const {
  return new DigitallySigned;
}

void DigitallySigned::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DigitallySigned*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(hash_algorithm_, sig_algorithm_);
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        signature_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DigitallySigned::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.DigitallySigned)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ct.DigitallySigned.HashAlgorithm hash_algorithm = 1 [default = NONE];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ct::DigitallySigned_HashAlgorithm_IsValid(value)) {
            set_hash_algorithm(static_cast< ::ct::DigitallySigned_HashAlgorithm >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_sig_algorithm;
        break;
      }

      // optional .ct.DigitallySigned.SignatureAlgorithm sig_algorithm = 2 [default = ANONYMOUS];
      case 2: {
        if (tag == 16) {
         parse_sig_algorithm:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ct::DigitallySigned_SignatureAlgorithm_IsValid(value)) {
            set_sig_algorithm(static_cast< ::ct::DigitallySigned_SignatureAlgorithm >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_signature;
        break;
      }

      // optional bytes signature = 3;
      case 3: {
        if (tag == 26) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.DigitallySigned)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.DigitallySigned)
  return false;
#undef DO_
}

void DigitallySigned::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.DigitallySigned)
  // optional .ct.DigitallySigned.HashAlgorithm hash_algorithm = 1 [default = NONE];
  if (has_hash_algorithm()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->hash_algorithm(), output);
  }

  // optional .ct.DigitallySigned.SignatureAlgorithm sig_algorithm = 2 [default = ANONYMOUS];
  if (has_sig_algorithm()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->sig_algorithm(), output);
  }

  // optional bytes signature = 3;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->signature(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.DigitallySigned)
}

::google::protobuf::uint8* DigitallySigned::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.DigitallySigned)
  // optional .ct.DigitallySigned.HashAlgorithm hash_algorithm = 1 [default = NONE];
  if (has_hash_algorithm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->hash_algorithm(), target);
  }

  // optional .ct.DigitallySigned.SignatureAlgorithm sig_algorithm = 2 [default = ANONYMOUS];
  if (has_sig_algorithm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->sig_algorithm(), target);
  }

  // optional bytes signature = 3;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->signature(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.DigitallySigned)
  return target;
}

int DigitallySigned::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ct.DigitallySigned.HashAlgorithm hash_algorithm = 1 [default = NONE];
    if (has_hash_algorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->hash_algorithm());
    }

    // optional .ct.DigitallySigned.SignatureAlgorithm sig_algorithm = 2 [default = ANONYMOUS];
    if (has_sig_algorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sig_algorithm());
    }

    // optional bytes signature = 3;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DigitallySigned::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DigitallySigned* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DigitallySigned*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DigitallySigned::MergeFrom(const DigitallySigned& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hash_algorithm()) {
      set_hash_algorithm(from.hash_algorithm());
    }
    if (from.has_sig_algorithm()) {
      set_sig_algorithm(from.sig_algorithm());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DigitallySigned::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DigitallySigned::CopyFrom(const DigitallySigned& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DigitallySigned::IsInitialized() const {

  return true;
}

void DigitallySigned::Swap(DigitallySigned* other) {
  if (other != this) {
    std::swap(hash_algorithm_, other->hash_algorithm_);
    std::swap(sig_algorithm_, other->sig_algorithm_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DigitallySigned::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DigitallySigned_descriptor_;
  metadata.reflection = DigitallySigned_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int X509ChainEntry::kLeafCertificateFieldNumber;
const int X509ChainEntry::kCertInfoFieldNumber;
const int X509ChainEntry::kCertificateChainFieldNumber;
#endif  // !_MSC_VER

X509ChainEntry::X509ChainEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.X509ChainEntry)
}

void X509ChainEntry::InitAsDefaultInstance() {
  cert_info_ = const_cast< ::ct::CertInfo*>(&::ct::CertInfo::default_instance());
}

X509ChainEntry::X509ChainEntry(const X509ChainEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.X509ChainEntry)
}

void X509ChainEntry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  leaf_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cert_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

X509ChainEntry::~X509ChainEntry() {
  // @@protoc_insertion_point(destructor:ct.X509ChainEntry)
  SharedDtor();
}

void X509ChainEntry::SharedDtor() {
  if (leaf_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete leaf_certificate_;
  }
  if (this != default_instance_) {
    delete cert_info_;
  }
}

void X509ChainEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* X509ChainEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return X509ChainEntry_descriptor_;
}

const X509ChainEntry& X509ChainEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

X509ChainEntry* X509ChainEntry::default_instance_ = NULL;

X509ChainEntry* X509ChainEntry::New() const {
  return new X509ChainEntry;
}

void X509ChainEntry::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_leaf_certificate()) {
      if (leaf_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        leaf_certificate_->clear();
      }
    }
    if (has_cert_info()) {
      if (cert_info_ != NULL) cert_info_->::ct::CertInfo::Clear();
    }
  }
  certificate_chain_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool X509ChainEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.X509ChainEntry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes leaf_certificate = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_leaf_certificate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_certificate_chain;
        break;
      }

      // repeated bytes certificate_chain = 2;
      case 2: {
        if (tag == 18) {
         parse_certificate_chain:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_certificate_chain()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_certificate_chain;
        if (input->ExpectTag(26)) goto parse_cert_info;
        break;
      }

      // optional .ct.CertInfo cert_info = 3;
      case 3: {
        if (tag == 26) {
         parse_cert_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cert_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.X509ChainEntry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.X509ChainEntry)
  return false;
#undef DO_
}

void X509ChainEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.X509ChainEntry)
  // optional bytes leaf_certificate = 1;
  if (has_leaf_certificate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->leaf_certificate(), output);
  }

  // repeated bytes certificate_chain = 2;
  for (int i = 0; i < this->certificate_chain_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->certificate_chain(i), output);
  }

  // optional .ct.CertInfo cert_info = 3;
  if (has_cert_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->cert_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.X509ChainEntry)
}

::google::protobuf::uint8* X509ChainEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.X509ChainEntry)
  // optional bytes leaf_certificate = 1;
  if (has_leaf_certificate()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->leaf_certificate(), target);
  }

  // repeated bytes certificate_chain = 2;
  for (int i = 0; i < this->certificate_chain_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(2, this->certificate_chain(i), target);
  }

  // optional .ct.CertInfo cert_info = 3;
  if (has_cert_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->cert_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.X509ChainEntry)
  return target;
}

int X509ChainEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes leaf_certificate = 1;
    if (has_leaf_certificate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->leaf_certificate());
    }

    // optional .ct.CertInfo cert_info = 3;
    if (has_cert_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cert_info());
    }

  }
  // repeated bytes certificate_chain = 2;
  total_size += 1 * this->certificate_chain_size();
  for (int i = 0; i < this->certificate_chain_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->certificate_chain(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void X509ChainEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const X509ChainEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const X509ChainEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void X509ChainEntry::MergeFrom(const X509ChainEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  certificate_chain_.MergeFrom(from.certificate_chain_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_leaf_certificate()) {
      set_leaf_certificate(from.leaf_certificate());
    }
    if (from.has_cert_info()) {
      mutable_cert_info()->::ct::CertInfo::MergeFrom(from.cert_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void X509ChainEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void X509ChainEntry::CopyFrom(const X509ChainEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool X509ChainEntry::IsInitialized() const {

  return true;
}

void X509ChainEntry::Swap(X509ChainEntry* other) {
  if (other != this) {
    std::swap(leaf_certificate_, other->leaf_certificate_);
    std::swap(cert_info_, other->cert_info_);
    certificate_chain_.Swap(&other->certificate_chain_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata X509ChainEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = X509ChainEntry_descriptor_;
  metadata.reflection = X509ChainEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PreCert::kIssuerKeyHashFieldNumber;
const int PreCert::kTbsCertificateFieldNumber;
#endif  // !_MSC_VER

PreCert::PreCert()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.PreCert)
}

void PreCert::InitAsDefaultInstance() {
}

PreCert::PreCert(const PreCert& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.PreCert)
}

void PreCert::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  issuer_key_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tbs_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PreCert::~PreCert() {
  // @@protoc_insertion_point(destructor:ct.PreCert)
  SharedDtor();
}

void PreCert::SharedDtor() {
  if (issuer_key_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete issuer_key_hash_;
  }
  if (tbs_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tbs_certificate_;
  }
  if (this != default_instance_) {
  }
}

void PreCert::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PreCert::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PreCert_descriptor_;
}

const PreCert& PreCert::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

PreCert* PreCert::default_instance_ = NULL;

PreCert* PreCert::New() const {
  return new PreCert;
}

void PreCert::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_issuer_key_hash()) {
      if (issuer_key_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        issuer_key_hash_->clear();
      }
    }
    if (has_tbs_certificate()) {
      if (tbs_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        tbs_certificate_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PreCert::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.PreCert)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes issuer_key_hash = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_issuer_key_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_tbs_certificate;
        break;
      }

      // optional bytes tbs_certificate = 2;
      case 2: {
        if (tag == 18) {
         parse_tbs_certificate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_tbs_certificate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.PreCert)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.PreCert)
  return false;
#undef DO_
}

void PreCert::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.PreCert)
  // optional bytes issuer_key_hash = 1;
  if (has_issuer_key_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->issuer_key_hash(), output);
  }

  // optional bytes tbs_certificate = 2;
  if (has_tbs_certificate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->tbs_certificate(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.PreCert)
}

::google::protobuf::uint8* PreCert::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.PreCert)
  // optional bytes issuer_key_hash = 1;
  if (has_issuer_key_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->issuer_key_hash(), target);
  }

  // optional bytes tbs_certificate = 2;
  if (has_tbs_certificate()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->tbs_certificate(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.PreCert)
  return target;
}

int PreCert::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes issuer_key_hash = 1;
    if (has_issuer_key_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->issuer_key_hash());
    }

    // optional bytes tbs_certificate = 2;
    if (has_tbs_certificate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->tbs_certificate());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PreCert::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PreCert* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PreCert*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PreCert::MergeFrom(const PreCert& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_issuer_key_hash()) {
      set_issuer_key_hash(from.issuer_key_hash());
    }
    if (from.has_tbs_certificate()) {
      set_tbs_certificate(from.tbs_certificate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PreCert::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PreCert::CopyFrom(const PreCert& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PreCert::IsInitialized() const {

  return true;
}

void PreCert::Swap(PreCert* other) {
  if (other != this) {
    std::swap(issuer_key_hash_, other->issuer_key_hash_);
    std::swap(tbs_certificate_, other->tbs_certificate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PreCert::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PreCert_descriptor_;
  metadata.reflection = PreCert_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CertInfo::kIssuerKeyHashFieldNumber;
const int CertInfo::kTbsCertificateFieldNumber;
#endif  // !_MSC_VER

CertInfo::CertInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.CertInfo)
}

void CertInfo::InitAsDefaultInstance() {
}

CertInfo::CertInfo(const CertInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.CertInfo)
}

void CertInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  issuer_key_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tbs_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CertInfo::~CertInfo() {
  // @@protoc_insertion_point(destructor:ct.CertInfo)
  SharedDtor();
}

void CertInfo::SharedDtor() {
  if (issuer_key_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete issuer_key_hash_;
  }
  if (tbs_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tbs_certificate_;
  }
  if (this != default_instance_) {
  }
}

void CertInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CertInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CertInfo_descriptor_;
}

const CertInfo& CertInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

CertInfo* CertInfo::default_instance_ = NULL;

CertInfo* CertInfo::New() const {
  return new CertInfo;
}

void CertInfo::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_issuer_key_hash()) {
      if (issuer_key_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        issuer_key_hash_->clear();
      }
    }
    if (has_tbs_certificate()) {
      if (tbs_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        tbs_certificate_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CertInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.CertInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes issuer_key_hash = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_issuer_key_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_tbs_certificate;
        break;
      }

      // optional bytes tbs_certificate = 2;
      case 2: {
        if (tag == 18) {
         parse_tbs_certificate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_tbs_certificate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.CertInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.CertInfo)
  return false;
#undef DO_
}

void CertInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.CertInfo)
  // optional bytes issuer_key_hash = 1;
  if (has_issuer_key_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->issuer_key_hash(), output);
  }

  // optional bytes tbs_certificate = 2;
  if (has_tbs_certificate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->tbs_certificate(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.CertInfo)
}

::google::protobuf::uint8* CertInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.CertInfo)
  // optional bytes issuer_key_hash = 1;
  if (has_issuer_key_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->issuer_key_hash(), target);
  }

  // optional bytes tbs_certificate = 2;
  if (has_tbs_certificate()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->tbs_certificate(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.CertInfo)
  return target;
}

int CertInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes issuer_key_hash = 1;
    if (has_issuer_key_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->issuer_key_hash());
    }

    // optional bytes tbs_certificate = 2;
    if (has_tbs_certificate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->tbs_certificate());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CertInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CertInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CertInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CertInfo::MergeFrom(const CertInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_issuer_key_hash()) {
      set_issuer_key_hash(from.issuer_key_hash());
    }
    if (from.has_tbs_certificate()) {
      set_tbs_certificate(from.tbs_certificate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CertInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CertInfo::CopyFrom(const CertInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertInfo::IsInitialized() const {

  return true;
}

void CertInfo::Swap(CertInfo* other) {
  if (other != this) {
    std::swap(issuer_key_hash_, other->issuer_key_hash_);
    std::swap(tbs_certificate_, other->tbs_certificate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CertInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CertInfo_descriptor_;
  metadata.reflection = CertInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PrecertChainEntry::kPreCertificateFieldNumber;
const int PrecertChainEntry::kPrecertificateChainFieldNumber;
const int PrecertChainEntry::kPreCertFieldNumber;
const int PrecertChainEntry::kCertInfoFieldNumber;
#endif  // !_MSC_VER

PrecertChainEntry::PrecertChainEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.PrecertChainEntry)
}

void PrecertChainEntry::InitAsDefaultInstance() {
  pre_cert_ = const_cast< ::ct::PreCert*>(&::ct::PreCert::default_instance());
  cert_info_ = const_cast< ::ct::CertInfo*>(&::ct::CertInfo::default_instance());
}

PrecertChainEntry::PrecertChainEntry(const PrecertChainEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.PrecertChainEntry)
}

void PrecertChainEntry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  pre_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pre_cert_ = NULL;
  cert_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PrecertChainEntry::~PrecertChainEntry() {
  // @@protoc_insertion_point(destructor:ct.PrecertChainEntry)
  SharedDtor();
}

void PrecertChainEntry::SharedDtor() {
  if (pre_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pre_certificate_;
  }
  if (this != default_instance_) {
    delete pre_cert_;
    delete cert_info_;
  }
}

void PrecertChainEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PrecertChainEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PrecertChainEntry_descriptor_;
}

const PrecertChainEntry& PrecertChainEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

PrecertChainEntry* PrecertChainEntry::default_instance_ = NULL;

PrecertChainEntry* PrecertChainEntry::New() const {
  return new PrecertChainEntry;
}

void PrecertChainEntry::Clear() {
  if (_has_bits_[0 / 32] & 13) {
    if (has_pre_certificate()) {
      if (pre_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        pre_certificate_->clear();
      }
    }
    if (has_pre_cert()) {
      if (pre_cert_ != NULL) pre_cert_->::ct::PreCert::Clear();
    }
    if (has_cert_info()) {
      if (cert_info_ != NULL) cert_info_->::ct::CertInfo::Clear();
    }
  }
  precertificate_chain_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PrecertChainEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.PrecertChainEntry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes pre_certificate = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pre_certificate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_precertificate_chain;
        break;
      }

      // repeated bytes precertificate_chain = 2;
      case 2: {
        if (tag == 18) {
         parse_precertificate_chain:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_precertificate_chain()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_precertificate_chain;
        if (input->ExpectTag(26)) goto parse_pre_cert;
        break;
      }

      // optional .ct.PreCert pre_cert = 3;
      case 3: {
        if (tag == 26) {
         parse_pre_cert:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pre_cert()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_cert_info;
        break;
      }

      // optional .ct.CertInfo cert_info = 4;
      case 4: {
        if (tag == 34) {
         parse_cert_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cert_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.PrecertChainEntry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.PrecertChainEntry)
  return false;
#undef DO_
}

void PrecertChainEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.PrecertChainEntry)
  // optional bytes pre_certificate = 1;
  if (has_pre_certificate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->pre_certificate(), output);
  }

  // repeated bytes precertificate_chain = 2;
  for (int i = 0; i < this->precertificate_chain_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->precertificate_chain(i), output);
  }

  // optional .ct.PreCert pre_cert = 3;
  if (has_pre_cert()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->pre_cert(), output);
  }

  // optional .ct.CertInfo cert_info = 4;
  if (has_cert_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->cert_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.PrecertChainEntry)
}

::google::protobuf::uint8* PrecertChainEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.PrecertChainEntry)
  // optional bytes pre_certificate = 1;
  if (has_pre_certificate()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->pre_certificate(), target);
  }

  // repeated bytes precertificate_chain = 2;
  for (int i = 0; i < this->precertificate_chain_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(2, this->precertificate_chain(i), target);
  }

  // optional .ct.PreCert pre_cert = 3;
  if (has_pre_cert()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->pre_cert(), target);
  }

  // optional .ct.CertInfo cert_info = 4;
  if (has_cert_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->cert_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.PrecertChainEntry)
  return target;
}

int PrecertChainEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes pre_certificate = 1;
    if (has_pre_certificate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pre_certificate());
    }

    // optional .ct.PreCert pre_cert = 3;
    if (has_pre_cert()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pre_cert());
    }

    // optional .ct.CertInfo cert_info = 4;
    if (has_cert_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cert_info());
    }

  }
  // repeated bytes precertificate_chain = 2;
  total_size += 1 * this->precertificate_chain_size();
  for (int i = 0; i < this->precertificate_chain_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->precertificate_chain(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PrecertChainEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PrecertChainEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PrecertChainEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PrecertChainEntry::MergeFrom(const PrecertChainEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  precertificate_chain_.MergeFrom(from.precertificate_chain_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pre_certificate()) {
      set_pre_certificate(from.pre_certificate());
    }
    if (from.has_pre_cert()) {
      mutable_pre_cert()->::ct::PreCert::MergeFrom(from.pre_cert());
    }
    if (from.has_cert_info()) {
      mutable_cert_info()->::ct::CertInfo::MergeFrom(from.cert_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PrecertChainEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PrecertChainEntry::CopyFrom(const PrecertChainEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrecertChainEntry::IsInitialized() const {

  return true;
}

void PrecertChainEntry::Swap(PrecertChainEntry* other) {
  if (other != this) {
    std::swap(pre_certificate_, other->pre_certificate_);
    precertificate_chain_.Swap(&other->precertificate_chain_);
    std::swap(pre_cert_, other->pre_cert_);
    std::swap(cert_info_, other->cert_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PrecertChainEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PrecertChainEntry_descriptor_;
  metadata.reflection = PrecertChainEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int XJSONEntry::kJsonFieldNumber;
#endif  // !_MSC_VER

XJSONEntry::XJSONEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.XJSONEntry)
}

void XJSONEntry::InitAsDefaultInstance() {
}

XJSONEntry::XJSONEntry(const XJSONEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.XJSONEntry)
}

void XJSONEntry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  json_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

XJSONEntry::~XJSONEntry() {
  // @@protoc_insertion_point(destructor:ct.XJSONEntry)
  SharedDtor();
}

void XJSONEntry::SharedDtor() {
  if (json_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete json_;
  }
  if (this != default_instance_) {
  }
}

void XJSONEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* XJSONEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return XJSONEntry_descriptor_;
}

const XJSONEntry& XJSONEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

XJSONEntry* XJSONEntry::default_instance_ = NULL;

XJSONEntry* XJSONEntry::New() const {
  return new XJSONEntry;
}

void XJSONEntry::Clear() {
  if (has_json()) {
    if (json_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      json_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool XJSONEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.XJSONEntry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string json = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_json()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->json().data(), this->json().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "json");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.XJSONEntry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.XJSONEntry)
  return false;
#undef DO_
}

void XJSONEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.XJSONEntry)
  // optional string json = 1;
  if (has_json()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->json().data(), this->json().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "json");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->json(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.XJSONEntry)
}

::google::protobuf::uint8* XJSONEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.XJSONEntry)
  // optional string json = 1;
  if (has_json()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->json().data(), this->json().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "json");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->json(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.XJSONEntry)
  return target;
}

int XJSONEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string json = 1;
    if (has_json()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->json());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void XJSONEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const XJSONEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const XJSONEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void XJSONEntry::MergeFrom(const XJSONEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_json()) {
      set_json(from.json());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void XJSONEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void XJSONEntry::CopyFrom(const XJSONEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool XJSONEntry::IsInitialized() const {

  return true;
}

void XJSONEntry::Swap(XJSONEntry* other) {
  if (other != this) {
    std::swap(json_, other->json_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata XJSONEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = XJSONEntry_descriptor_;
  metadata.reflection = XJSONEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LogEntry::kTypeFieldNumber;
const int LogEntry::kX509EntryFieldNumber;
const int LogEntry::kPrecertEntryFieldNumber;
const int LogEntry::kXJsonEntryFieldNumber;
#endif  // !_MSC_VER

LogEntry::LogEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.LogEntry)
}

void LogEntry::InitAsDefaultInstance() {
  x509_entry_ = const_cast< ::ct::X509ChainEntry*>(&::ct::X509ChainEntry::default_instance());
  precert_entry_ = const_cast< ::ct::PrecertChainEntry*>(&::ct::PrecertChainEntry::default_instance());
  x_json_entry_ = const_cast< ::ct::XJSONEntry*>(&::ct::XJSONEntry::default_instance());
}

LogEntry::LogEntry(const LogEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.LogEntry)
}

void LogEntry::SharedCtor() {
  _cached_size_ = 0;
  type_ = 65536;
  x509_entry_ = NULL;
  precert_entry_ = NULL;
  x_json_entry_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogEntry::~LogEntry() {
  // @@protoc_insertion_point(destructor:ct.LogEntry)
  SharedDtor();
}

void LogEntry::SharedDtor() {
  if (this != default_instance_) {
    delete x509_entry_;
    delete precert_entry_;
    delete x_json_entry_;
  }
}

void LogEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogEntry_descriptor_;
}

const LogEntry& LogEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

LogEntry* LogEntry::default_instance_ = NULL;

LogEntry* LogEntry::New() const {
  return new LogEntry;
}

void LogEntry::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    type_ = 65536;
    if (has_x509_entry()) {
      if (x509_entry_ != NULL) x509_entry_->::ct::X509ChainEntry::Clear();
    }
    if (has_precert_entry()) {
      if (precert_entry_ != NULL) precert_entry_->::ct::PrecertChainEntry::Clear();
    }
    if (has_x_json_entry()) {
      if (x_json_entry_ != NULL) x_json_entry_->::ct::XJSONEntry::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.LogEntry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ct.LogEntryType type = 1 [default = UNKNOWN_ENTRY_TYPE];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ct::LogEntryType_IsValid(value)) {
            set_type(static_cast< ::ct::LogEntryType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_x509_entry;
        break;
      }

      // optional .ct.X509ChainEntry x509_entry = 2;
      case 2: {
        if (tag == 18) {
         parse_x509_entry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_x509_entry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_precert_entry;
        break;
      }

      // optional .ct.PrecertChainEntry precert_entry = 3;
      case 3: {
        if (tag == 26) {
         parse_precert_entry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_precert_entry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_x_json_entry;
        break;
      }

      // optional .ct.XJSONEntry x_json_entry = 4;
      case 4: {
        if (tag == 34) {
         parse_x_json_entry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_x_json_entry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.LogEntry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.LogEntry)
  return false;
#undef DO_
}

void LogEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.LogEntry)
  // optional .ct.LogEntryType type = 1 [default = UNKNOWN_ENTRY_TYPE];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .ct.X509ChainEntry x509_entry = 2;
  if (has_x509_entry()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->x509_entry(), output);
  }

  // optional .ct.PrecertChainEntry precert_entry = 3;
  if (has_precert_entry()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->precert_entry(), output);
  }

  // optional .ct.XJSONEntry x_json_entry = 4;
  if (has_x_json_entry()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->x_json_entry(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.LogEntry)
}

::google::protobuf::uint8* LogEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.LogEntry)
  // optional .ct.LogEntryType type = 1 [default = UNKNOWN_ENTRY_TYPE];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .ct.X509ChainEntry x509_entry = 2;
  if (has_x509_entry()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->x509_entry(), target);
  }

  // optional .ct.PrecertChainEntry precert_entry = 3;
  if (has_precert_entry()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->precert_entry(), target);
  }

  // optional .ct.XJSONEntry x_json_entry = 4;
  if (has_x_json_entry()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->x_json_entry(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.LogEntry)
  return target;
}

int LogEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ct.LogEntryType type = 1 [default = UNKNOWN_ENTRY_TYPE];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .ct.X509ChainEntry x509_entry = 2;
    if (has_x509_entry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->x509_entry());
    }

    // optional .ct.PrecertChainEntry precert_entry = 3;
    if (has_precert_entry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->precert_entry());
    }

    // optional .ct.XJSONEntry x_json_entry = 4;
    if (has_x_json_entry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->x_json_entry());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogEntry::MergeFrom(const LogEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_x509_entry()) {
      mutable_x509_entry()->::ct::X509ChainEntry::MergeFrom(from.x509_entry());
    }
    if (from.has_precert_entry()) {
      mutable_precert_entry()->::ct::PrecertChainEntry::MergeFrom(from.precert_entry());
    }
    if (from.has_x_json_entry()) {
      mutable_x_json_entry()->::ct::XJSONEntry::MergeFrom(from.x_json_entry());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogEntry::CopyFrom(const LogEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogEntry::IsInitialized() const {

  return true;
}

void LogEntry::Swap(LogEntry* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(x509_entry_, other->x509_entry_);
    std::swap(precert_entry_, other->precert_entry_);
    std::swap(x_json_entry_, other->x_json_entry_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogEntry_descriptor_;
  metadata.reflection = LogEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LogID::kKeyIdFieldNumber;
#endif  // !_MSC_VER

LogID::LogID()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.LogID)
}

void LogID::InitAsDefaultInstance() {
}

LogID::LogID(const LogID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.LogID)
}

void LogID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  key_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogID::~LogID() {
  // @@protoc_insertion_point(destructor:ct.LogID)
  SharedDtor();
}

void LogID::SharedDtor() {
  if (key_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_id_;
  }
  if (this != default_instance_) {
  }
}

void LogID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogID_descriptor_;
}

const LogID& LogID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

LogID* LogID::default_instance_ = NULL;

LogID* LogID::New() const {
  return new LogID;
}

void LogID::Clear() {
  if (has_key_id()) {
    if (key_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      key_id_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.LogID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes key_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.LogID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.LogID)
  return false;
#undef DO_
}

void LogID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.LogID)
  // optional bytes key_id = 1;
  if (has_key_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->key_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.LogID)
}

::google::protobuf::uint8* LogID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.LogID)
  // optional bytes key_id = 1;
  if (has_key_id()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->key_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.LogID)
  return target;
}

int LogID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes key_id = 1;
    if (has_key_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogID::MergeFrom(const LogID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key_id()) {
      set_key_id(from.key_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogID::CopyFrom(const LogID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogID::IsInitialized() const {

  return true;
}

void LogID::Swap(LogID* other) {
  if (other != this) {
    std::swap(key_id_, other->key_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogID_descriptor_;
  metadata.reflection = LogID_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SctExtension::kSctExtensionTypeFieldNumber;
const int SctExtension::kSctExtensionDataFieldNumber;
#endif  // !_MSC_VER

SctExtension::SctExtension()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.SctExtension)
}

void SctExtension::InitAsDefaultInstance() {
}

SctExtension::SctExtension(const SctExtension& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.SctExtension)
}

void SctExtension::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  sct_extension_type_ = 0u;
  sct_extension_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SctExtension::~SctExtension() {
  // @@protoc_insertion_point(destructor:ct.SctExtension)
  SharedDtor();
}

void SctExtension::SharedDtor() {
  if (sct_extension_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sct_extension_data_;
  }
  if (this != default_instance_) {
  }
}

void SctExtension::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SctExtension::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SctExtension_descriptor_;
}

const SctExtension& SctExtension::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

SctExtension* SctExtension::default_instance_ = NULL;

SctExtension* SctExtension::New() const {
  return new SctExtension;
}

void SctExtension::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    sct_extension_type_ = 0u;
    if (has_sct_extension_data()) {
      if (sct_extension_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        sct_extension_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SctExtension::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.SctExtension)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 sct_extension_type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sct_extension_type_)));
          set_has_sct_extension_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_sct_extension_data;
        break;
      }

      // optional bytes sct_extension_data = 2;
      case 2: {
        if (tag == 18) {
         parse_sct_extension_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_sct_extension_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.SctExtension)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.SctExtension)
  return false;
#undef DO_
}

void SctExtension::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.SctExtension)
  // optional uint32 sct_extension_type = 1;
  if (has_sct_extension_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sct_extension_type(), output);
  }

  // optional bytes sct_extension_data = 2;
  if (has_sct_extension_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->sct_extension_data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.SctExtension)
}

::google::protobuf::uint8* SctExtension::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.SctExtension)
  // optional uint32 sct_extension_type = 1;
  if (has_sct_extension_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sct_extension_type(), target);
  }

  // optional bytes sct_extension_data = 2;
  if (has_sct_extension_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->sct_extension_data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.SctExtension)
  return target;
}

int SctExtension::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 sct_extension_type = 1;
    if (has_sct_extension_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sct_extension_type());
    }

    // optional bytes sct_extension_data = 2;
    if (has_sct_extension_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->sct_extension_data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SctExtension::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SctExtension* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SctExtension*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SctExtension::MergeFrom(const SctExtension& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sct_extension_type()) {
      set_sct_extension_type(from.sct_extension_type());
    }
    if (from.has_sct_extension_data()) {
      set_sct_extension_data(from.sct_extension_data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SctExtension::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SctExtension::CopyFrom(const SctExtension& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SctExtension::IsInitialized() const {

  return true;
}

void SctExtension::Swap(SctExtension* other) {
  if (other != this) {
    std::swap(sct_extension_type_, other->sct_extension_type_);
    std::swap(sct_extension_data_, other->sct_extension_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SctExtension::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SctExtension_descriptor_;
  metadata.reflection = SctExtension_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SignedCertificateTimestamp::kVersionFieldNumber;
const int SignedCertificateTimestamp::kIdFieldNumber;
const int SignedCertificateTimestamp::kTimestampFieldNumber;
const int SignedCertificateTimestamp::kSignatureFieldNumber;
const int SignedCertificateTimestamp::kExtensionsFieldNumber;
const int SignedCertificateTimestamp::kSctExtensionFieldNumber;
#endif  // !_MSC_VER

SignedCertificateTimestamp::SignedCertificateTimestamp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.SignedCertificateTimestamp)
}

void SignedCertificateTimestamp::InitAsDefaultInstance() {
  id_ = const_cast< ::ct::LogID*>(&::ct::LogID::default_instance());
  signature_ = const_cast< ::ct::DigitallySigned*>(&::ct::DigitallySigned::default_instance());
}

SignedCertificateTimestamp::SignedCertificateTimestamp(const SignedCertificateTimestamp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.SignedCertificateTimestamp)
}

void SignedCertificateTimestamp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  version_ = 256;
  id_ = NULL;
  timestamp_ = GOOGLE_ULONGLONG(0);
  signature_ = NULL;
  extensions_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignedCertificateTimestamp::~SignedCertificateTimestamp() {
  // @@protoc_insertion_point(destructor:ct.SignedCertificateTimestamp)
  SharedDtor();
}

void SignedCertificateTimestamp::SharedDtor() {
  if (extensions_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extensions_;
  }
  if (this != default_instance_) {
    delete id_;
    delete signature_;
  }
}

void SignedCertificateTimestamp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignedCertificateTimestamp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignedCertificateTimestamp_descriptor_;
}

const SignedCertificateTimestamp& SignedCertificateTimestamp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

SignedCertificateTimestamp* SignedCertificateTimestamp::default_instance_ = NULL;

SignedCertificateTimestamp* SignedCertificateTimestamp::New() const {
  return new SignedCertificateTimestamp;
}

void SignedCertificateTimestamp::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    version_ = 256;
    if (has_id()) {
      if (id_ != NULL) id_->::ct::LogID::Clear();
    }
    timestamp_ = GOOGLE_ULONGLONG(0);
    if (has_signature()) {
      if (signature_ != NULL) signature_->::ct::DigitallySigned::Clear();
    }
    if (has_extensions()) {
      if (extensions_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        extensions_->clear();
      }
    }
  }
  sct_extension_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignedCertificateTimestamp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.SignedCertificateTimestamp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ct::Version_IsValid(value)) {
            set_version(static_cast< ::ct::Version >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_id;
        break;
      }

      // optional .ct.LogID id = 2;
      case 2: {
        if (tag == 18) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_timestamp;
        break;
      }

      // optional uint64 timestamp = 3;
      case 3: {
        if (tag == 24) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_signature;
        break;
      }

      // optional .ct.DigitallySigned signature = 4;
      case 4: {
        if (tag == 34) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_extensions;
        break;
      }

      // optional bytes extensions = 5;
      case 5: {
        if (tag == 42) {
         parse_extensions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_extensions()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_sct_extension;
        break;
      }

      // repeated .ct.SctExtension sct_extension = 6;
      case 6: {
        if (tag == 50) {
         parse_sct_extension:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sct_extension()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_sct_extension;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.SignedCertificateTimestamp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.SignedCertificateTimestamp)
  return false;
#undef DO_
}

void SignedCertificateTimestamp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.SignedCertificateTimestamp)
  // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->version(), output);
  }

  // optional .ct.LogID id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->id(), output);
  }

  // optional uint64 timestamp = 3;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->timestamp(), output);
  }

  // optional .ct.DigitallySigned signature = 4;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->signature(), output);
  }

  // optional bytes extensions = 5;
  if (has_extensions()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->extensions(), output);
  }

  // repeated .ct.SctExtension sct_extension = 6;
  for (int i = 0; i < this->sct_extension_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->sct_extension(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.SignedCertificateTimestamp)
}

::google::protobuf::uint8* SignedCertificateTimestamp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.SignedCertificateTimestamp)
  // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->version(), target);
  }

  // optional .ct.LogID id = 2;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->id(), target);
  }

  // optional uint64 timestamp = 3;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->timestamp(), target);
  }

  // optional .ct.DigitallySigned signature = 4;
  if (has_signature()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->signature(), target);
  }

  // optional bytes extensions = 5;
  if (has_extensions()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->extensions(), target);
  }

  // repeated .ct.SctExtension sct_extension = 6;
  for (int i = 0; i < this->sct_extension_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->sct_extension(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.SignedCertificateTimestamp)
  return target;
}

int SignedCertificateTimestamp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->version());
    }

    // optional .ct.LogID id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }

    // optional uint64 timestamp = 3;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->timestamp());
    }

    // optional .ct.DigitallySigned signature = 4;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->signature());
    }

    // optional bytes extensions = 5;
    if (has_extensions()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->extensions());
    }

  }
  // repeated .ct.SctExtension sct_extension = 6;
  total_size += 1 * this->sct_extension_size();
  for (int i = 0; i < this->sct_extension_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sct_extension(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignedCertificateTimestamp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignedCertificateTimestamp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SignedCertificateTimestamp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignedCertificateTimestamp::MergeFrom(const SignedCertificateTimestamp& from) {
  GOOGLE_CHECK_NE(&from, this);
  sct_extension_.MergeFrom(from.sct_extension_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_id()) {
      mutable_id()->::ct::LogID::MergeFrom(from.id());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_signature()) {
      mutable_signature()->::ct::DigitallySigned::MergeFrom(from.signature());
    }
    if (from.has_extensions()) {
      set_extensions(from.extensions());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignedCertificateTimestamp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignedCertificateTimestamp::CopyFrom(const SignedCertificateTimestamp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignedCertificateTimestamp::IsInitialized() const {

  return true;
}

void SignedCertificateTimestamp::Swap(SignedCertificateTimestamp* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(id_, other->id_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(signature_, other->signature_);
    std::swap(extensions_, other->extensions_);
    sct_extension_.Swap(&other->sct_extension_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SignedCertificateTimestamp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SignedCertificateTimestamp_descriptor_;
  metadata.reflection = SignedCertificateTimestamp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SignedCertificateTimestampList::kSctListFieldNumber;
#endif  // !_MSC_VER

SignedCertificateTimestampList::SignedCertificateTimestampList()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.SignedCertificateTimestampList)
}

void SignedCertificateTimestampList::InitAsDefaultInstance() {
}

SignedCertificateTimestampList::SignedCertificateTimestampList(const SignedCertificateTimestampList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.SignedCertificateTimestampList)
}

void SignedCertificateTimestampList::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignedCertificateTimestampList::~SignedCertificateTimestampList() {
  // @@protoc_insertion_point(destructor:ct.SignedCertificateTimestampList)
  SharedDtor();
}

void SignedCertificateTimestampList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SignedCertificateTimestampList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignedCertificateTimestampList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignedCertificateTimestampList_descriptor_;
}

const SignedCertificateTimestampList& SignedCertificateTimestampList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

SignedCertificateTimestampList* SignedCertificateTimestampList::default_instance_ = NULL;

SignedCertificateTimestampList* SignedCertificateTimestampList::New() const {
  return new SignedCertificateTimestampList;
}

void SignedCertificateTimestampList::Clear() {
  sct_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignedCertificateTimestampList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.SignedCertificateTimestampList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes sct_list = 1;
      case 1: {
        if (tag == 10) {
         parse_sct_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_sct_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_sct_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.SignedCertificateTimestampList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.SignedCertificateTimestampList)
  return false;
#undef DO_
}

void SignedCertificateTimestampList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.SignedCertificateTimestampList)
  // repeated bytes sct_list = 1;
  for (int i = 0; i < this->sct_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->sct_list(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.SignedCertificateTimestampList)
}

::google::protobuf::uint8* SignedCertificateTimestampList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.SignedCertificateTimestampList)
  // repeated bytes sct_list = 1;
  for (int i = 0; i < this->sct_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(1, this->sct_list(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.SignedCertificateTimestampList)
  return target;
}

int SignedCertificateTimestampList::ByteSize() const {
  int total_size = 0;

  // repeated bytes sct_list = 1;
  total_size += 1 * this->sct_list_size();
  for (int i = 0; i < this->sct_list_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->sct_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignedCertificateTimestampList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignedCertificateTimestampList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SignedCertificateTimestampList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignedCertificateTimestampList::MergeFrom(const SignedCertificateTimestampList& from) {
  GOOGLE_CHECK_NE(&from, this);
  sct_list_.MergeFrom(from.sct_list_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignedCertificateTimestampList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignedCertificateTimestampList::CopyFrom(const SignedCertificateTimestampList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignedCertificateTimestampList::IsInitialized() const {

  return true;
}

void SignedCertificateTimestampList::Swap(SignedCertificateTimestampList* other) {
  if (other != this) {
    sct_list_.Swap(&other->sct_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SignedCertificateTimestampList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SignedCertificateTimestampList_descriptor_;
  metadata.reflection = SignedCertificateTimestampList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SignedEntry::kX509FieldNumber;
const int SignedEntry::kPrecertFieldNumber;
const int SignedEntry::kJsonFieldNumber;
const int SignedEntry::kCertInfoFieldNumber;
#endif  // !_MSC_VER

SignedEntry::SignedEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.SignedEntry)
}

void SignedEntry::InitAsDefaultInstance() {
  precert_ = const_cast< ::ct::PreCert*>(&::ct::PreCert::default_instance());
  cert_info_ = const_cast< ::ct::CertInfo*>(&::ct::CertInfo::default_instance());
}

SignedEntry::SignedEntry(const SignedEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.SignedEntry)
}

void SignedEntry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  x509_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  precert_ = NULL;
  json_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cert_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignedEntry::~SignedEntry() {
  // @@protoc_insertion_point(destructor:ct.SignedEntry)
  SharedDtor();
}

void SignedEntry::SharedDtor() {
  if (x509_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete x509_;
  }
  if (json_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete json_;
  }
  if (this != default_instance_) {
    delete precert_;
    delete cert_info_;
  }
}

void SignedEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignedEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignedEntry_descriptor_;
}

const SignedEntry& SignedEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

SignedEntry* SignedEntry::default_instance_ = NULL;

SignedEntry* SignedEntry::New() const {
  return new SignedEntry;
}

void SignedEntry::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_x509()) {
      if (x509_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        x509_->clear();
      }
    }
    if (has_precert()) {
      if (precert_ != NULL) precert_->::ct::PreCert::Clear();
    }
    if (has_json()) {
      if (json_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        json_->clear();
      }
    }
    if (has_cert_info()) {
      if (cert_info_ != NULL) cert_info_->::ct::CertInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignedEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.SignedEntry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes x509 = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_x509()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_precert;
        break;
      }

      // optional .ct.PreCert precert = 2;
      case 2: {
        if (tag == 18) {
         parse_precert:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_precert()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_json;
        break;
      }

      // optional bytes json = 3;
      case 3: {
        if (tag == 26) {
         parse_json:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_json()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_cert_info;
        break;
      }

      // optional .ct.CertInfo cert_info = 4;
      case 4: {
        if (tag == 34) {
         parse_cert_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cert_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.SignedEntry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.SignedEntry)
  return false;
#undef DO_
}

void SignedEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.SignedEntry)
  // optional bytes x509 = 1;
  if (has_x509()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->x509(), output);
  }

  // optional .ct.PreCert precert = 2;
  if (has_precert()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->precert(), output);
  }

  // optional bytes json = 3;
  if (has_json()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->json(), output);
  }

  // optional .ct.CertInfo cert_info = 4;
  if (has_cert_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->cert_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.SignedEntry)
}

::google::protobuf::uint8* SignedEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.SignedEntry)
  // optional bytes x509 = 1;
  if (has_x509()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->x509(), target);
  }

  // optional .ct.PreCert precert = 2;
  if (has_precert()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->precert(), target);
  }

  // optional bytes json = 3;
  if (has_json()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->json(), target);
  }

  // optional .ct.CertInfo cert_info = 4;
  if (has_cert_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->cert_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.SignedEntry)
  return target;
}

int SignedEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes x509 = 1;
    if (has_x509()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->x509());
    }

    // optional .ct.PreCert precert = 2;
    if (has_precert()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->precert());
    }

    // optional bytes json = 3;
    if (has_json()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->json());
    }

    // optional .ct.CertInfo cert_info = 4;
    if (has_cert_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cert_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignedEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignedEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SignedEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignedEntry::MergeFrom(const SignedEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x509()) {
      set_x509(from.x509());
    }
    if (from.has_precert()) {
      mutable_precert()->::ct::PreCert::MergeFrom(from.precert());
    }
    if (from.has_json()) {
      set_json(from.json());
    }
    if (from.has_cert_info()) {
      mutable_cert_info()->::ct::CertInfo::MergeFrom(from.cert_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignedEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignedEntry::CopyFrom(const SignedEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignedEntry::IsInitialized() const {

  return true;
}

void SignedEntry::Swap(SignedEntry* other) {
  if (other != this) {
    std::swap(x509_, other->x509_);
    std::swap(precert_, other->precert_);
    std::swap(json_, other->json_);
    std::swap(cert_info_, other->cert_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SignedEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SignedEntry_descriptor_;
  metadata.reflection = SignedEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TimestampedEntry::kTimestampFieldNumber;
const int TimestampedEntry::kEntryTypeFieldNumber;
const int TimestampedEntry::kSignedEntryFieldNumber;
const int TimestampedEntry::kExtensionsFieldNumber;
const int TimestampedEntry::kSctExtensionFieldNumber;
#endif  // !_MSC_VER

TimestampedEntry::TimestampedEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.TimestampedEntry)
}

void TimestampedEntry::InitAsDefaultInstance() {
  signed_entry_ = const_cast< ::ct::SignedEntry*>(&::ct::SignedEntry::default_instance());
}

TimestampedEntry::TimestampedEntry(const TimestampedEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.TimestampedEntry)
}

void TimestampedEntry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  timestamp_ = GOOGLE_ULONGLONG(0);
  entry_type_ = 0;
  signed_entry_ = NULL;
  extensions_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TimestampedEntry::~TimestampedEntry() {
  // @@protoc_insertion_point(destructor:ct.TimestampedEntry)
  SharedDtor();
}

void TimestampedEntry::SharedDtor() {
  if (extensions_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extensions_;
  }
  if (this != default_instance_) {
    delete signed_entry_;
  }
}

void TimestampedEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TimestampedEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TimestampedEntry_descriptor_;
}

const TimestampedEntry& TimestampedEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

TimestampedEntry* TimestampedEntry::default_instance_ = NULL;

TimestampedEntry* TimestampedEntry::New() const {
  return new TimestampedEntry;
}

void TimestampedEntry::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    timestamp_ = GOOGLE_ULONGLONG(0);
    entry_type_ = 0;
    if (has_signed_entry()) {
      if (signed_entry_ != NULL) signed_entry_->::ct::SignedEntry::Clear();
    }
    if (has_extensions()) {
      if (extensions_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        extensions_->clear();
      }
    }
  }
  sct_extension_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TimestampedEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.TimestampedEntry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 timestamp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_entry_type;
        break;
      }

      // optional .ct.LogEntryType entry_type = 2;
      case 2: {
        if (tag == 16) {
         parse_entry_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ct::LogEntryType_IsValid(value)) {
            set_entry_type(static_cast< ::ct::LogEntryType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_signed_entry;
        break;
      }

      // optional .ct.SignedEntry signed_entry = 3;
      case 3: {
        if (tag == 26) {
         parse_signed_entry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_signed_entry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_extensions;
        break;
      }

      // optional bytes extensions = 4;
      case 4: {
        if (tag == 34) {
         parse_extensions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_extensions()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_sct_extension;
        break;
      }

      // repeated .ct.SctExtension sct_extension = 5;
      case 5: {
        if (tag == 42) {
         parse_sct_extension:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sct_extension()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_sct_extension;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.TimestampedEntry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.TimestampedEntry)
  return false;
#undef DO_
}

void TimestampedEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.TimestampedEntry)
  // optional uint64 timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->timestamp(), output);
  }

  // optional .ct.LogEntryType entry_type = 2;
  if (has_entry_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->entry_type(), output);
  }

  // optional .ct.SignedEntry signed_entry = 3;
  if (has_signed_entry()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->signed_entry(), output);
  }

  // optional bytes extensions = 4;
  if (has_extensions()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->extensions(), output);
  }

  // repeated .ct.SctExtension sct_extension = 5;
  for (int i = 0; i < this->sct_extension_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->sct_extension(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.TimestampedEntry)
}

::google::protobuf::uint8* TimestampedEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.TimestampedEntry)
  // optional uint64 timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->timestamp(), target);
  }

  // optional .ct.LogEntryType entry_type = 2;
  if (has_entry_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->entry_type(), target);
  }

  // optional .ct.SignedEntry signed_entry = 3;
  if (has_signed_entry()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->signed_entry(), target);
  }

  // optional bytes extensions = 4;
  if (has_extensions()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->extensions(), target);
  }

  // repeated .ct.SctExtension sct_extension = 5;
  for (int i = 0; i < this->sct_extension_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->sct_extension(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.TimestampedEntry)
  return target;
}

int TimestampedEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->timestamp());
    }

    // optional .ct.LogEntryType entry_type = 2;
    if (has_entry_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->entry_type());
    }

    // optional .ct.SignedEntry signed_entry = 3;
    if (has_signed_entry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->signed_entry());
    }

    // optional bytes extensions = 4;
    if (has_extensions()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->extensions());
    }

  }
  // repeated .ct.SctExtension sct_extension = 5;
  total_size += 1 * this->sct_extension_size();
  for (int i = 0; i < this->sct_extension_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sct_extension(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TimestampedEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TimestampedEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TimestampedEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TimestampedEntry::MergeFrom(const TimestampedEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  sct_extension_.MergeFrom(from.sct_extension_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_entry_type()) {
      set_entry_type(from.entry_type());
    }
    if (from.has_signed_entry()) {
      mutable_signed_entry()->::ct::SignedEntry::MergeFrom(from.signed_entry());
    }
    if (from.has_extensions()) {
      set_extensions(from.extensions());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TimestampedEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TimestampedEntry::CopyFrom(const TimestampedEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimestampedEntry::IsInitialized() const {

  return true;
}

void TimestampedEntry::Swap(TimestampedEntry* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(entry_type_, other->entry_type_);
    std::swap(signed_entry_, other->signed_entry_);
    std::swap(extensions_, other->extensions_);
    sct_extension_.Swap(&other->sct_extension_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TimestampedEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TimestampedEntry_descriptor_;
  metadata.reflection = TimestampedEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MerkleTreeLeaf::kVersionFieldNumber;
const int MerkleTreeLeaf::kTypeFieldNumber;
const int MerkleTreeLeaf::kTimestampedEntryFieldNumber;
#endif  // !_MSC_VER

MerkleTreeLeaf::MerkleTreeLeaf()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.MerkleTreeLeaf)
}

void MerkleTreeLeaf::InitAsDefaultInstance() {
  timestamped_entry_ = const_cast< ::ct::TimestampedEntry*>(&::ct::TimestampedEntry::default_instance());
}

MerkleTreeLeaf::MerkleTreeLeaf(const MerkleTreeLeaf& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.MerkleTreeLeaf)
}

void MerkleTreeLeaf::SharedCtor() {
  _cached_size_ = 0;
  version_ = 256;
  type_ = 256;
  timestamped_entry_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MerkleTreeLeaf::~MerkleTreeLeaf() {
  // @@protoc_insertion_point(destructor:ct.MerkleTreeLeaf)
  SharedDtor();
}

void MerkleTreeLeaf::SharedDtor() {
  if (this != default_instance_) {
    delete timestamped_entry_;
  }
}

void MerkleTreeLeaf::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MerkleTreeLeaf::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MerkleTreeLeaf_descriptor_;
}

const MerkleTreeLeaf& MerkleTreeLeaf::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

MerkleTreeLeaf* MerkleTreeLeaf::default_instance_ = NULL;

MerkleTreeLeaf* MerkleTreeLeaf::New() const {
  return new MerkleTreeLeaf;
}

void MerkleTreeLeaf::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    version_ = 256;
    type_ = 256;
    if (has_timestamped_entry()) {
      if (timestamped_entry_ != NULL) timestamped_entry_->::ct::TimestampedEntry::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MerkleTreeLeaf::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.MerkleTreeLeaf)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ct::Version_IsValid(value)) {
            set_version(static_cast< ::ct::Version >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional .ct.MerkleLeafType type = 2 [default = UNKNOWN_LEAF_TYPE];
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ct::MerkleLeafType_IsValid(value)) {
            set_type(static_cast< ::ct::MerkleLeafType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_timestamped_entry;
        break;
      }

      // optional .ct.TimestampedEntry timestamped_entry = 3;
      case 3: {
        if (tag == 26) {
         parse_timestamped_entry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamped_entry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.MerkleTreeLeaf)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.MerkleTreeLeaf)
  return false;
#undef DO_
}

void MerkleTreeLeaf::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.MerkleTreeLeaf)
  // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->version(), output);
  }

  // optional .ct.MerkleLeafType type = 2 [default = UNKNOWN_LEAF_TYPE];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional .ct.TimestampedEntry timestamped_entry = 3;
  if (has_timestamped_entry()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->timestamped_entry(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.MerkleTreeLeaf)
}

::google::protobuf::uint8* MerkleTreeLeaf::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.MerkleTreeLeaf)
  // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->version(), target);
  }

  // optional .ct.MerkleLeafType type = 2 [default = UNKNOWN_LEAF_TYPE];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // optional .ct.TimestampedEntry timestamped_entry = 3;
  if (has_timestamped_entry()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->timestamped_entry(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.MerkleTreeLeaf)
  return target;
}

int MerkleTreeLeaf::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->version());
    }

    // optional .ct.MerkleLeafType type = 2 [default = UNKNOWN_LEAF_TYPE];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .ct.TimestampedEntry timestamped_entry = 3;
    if (has_timestamped_entry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->timestamped_entry());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MerkleTreeLeaf::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MerkleTreeLeaf* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MerkleTreeLeaf*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MerkleTreeLeaf::MergeFrom(const MerkleTreeLeaf& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_timestamped_entry()) {
      mutable_timestamped_entry()->::ct::TimestampedEntry::MergeFrom(from.timestamped_entry());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MerkleTreeLeaf::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MerkleTreeLeaf::CopyFrom(const MerkleTreeLeaf& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MerkleTreeLeaf::IsInitialized() const {

  return true;
}

void MerkleTreeLeaf::Swap(MerkleTreeLeaf* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(type_, other->type_);
    std::swap(timestamped_entry_, other->timestamped_entry_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MerkleTreeLeaf::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MerkleTreeLeaf_descriptor_;
  metadata.reflection = MerkleTreeLeaf_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MerkleAuditProof::kVersionFieldNumber;
const int MerkleAuditProof::kIdFieldNumber;
const int MerkleAuditProof::kTreeSizeFieldNumber;
const int MerkleAuditProof::kTimestampFieldNumber;
const int MerkleAuditProof::kLeafIndexFieldNumber;
const int MerkleAuditProof::kPathNodeFieldNumber;
const int MerkleAuditProof::kTreeHeadSignatureFieldNumber;
#endif  // !_MSC_VER

MerkleAuditProof::MerkleAuditProof()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.MerkleAuditProof)
}

void MerkleAuditProof::InitAsDefaultInstance() {
  id_ = const_cast< ::ct::LogID*>(&::ct::LogID::default_instance());
  tree_head_signature_ = const_cast< ::ct::DigitallySigned*>(&::ct::DigitallySigned::default_instance());
}

MerkleAuditProof::MerkleAuditProof(const MerkleAuditProof& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.MerkleAuditProof)
}

void MerkleAuditProof::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  version_ = 256;
  id_ = NULL;
  tree_size_ = GOOGLE_LONGLONG(0);
  timestamp_ = GOOGLE_ULONGLONG(0);
  leaf_index_ = GOOGLE_LONGLONG(0);
  tree_head_signature_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MerkleAuditProof::~MerkleAuditProof() {
  // @@protoc_insertion_point(destructor:ct.MerkleAuditProof)
  SharedDtor();
}

void MerkleAuditProof::SharedDtor() {
  if (this != default_instance_) {
    delete id_;
    delete tree_head_signature_;
  }
}

void MerkleAuditProof::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MerkleAuditProof::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MerkleAuditProof_descriptor_;
}

const MerkleAuditProof& MerkleAuditProof::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

MerkleAuditProof* MerkleAuditProof::default_instance_ = NULL;

MerkleAuditProof* MerkleAuditProof::New() const {
  return new MerkleAuditProof;
}

void MerkleAuditProof::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MerkleAuditProof*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 95) {
    ZR_(tree_size_, leaf_index_);
    version_ = 256;
    if (has_id()) {
      if (id_ != NULL) id_->::ct::LogID::Clear();
    }
    if (has_tree_head_signature()) {
      if (tree_head_signature_ != NULL) tree_head_signature_->::ct::DigitallySigned::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  path_node_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MerkleAuditProof::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.MerkleAuditProof)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ct::Version_IsValid(value)) {
            set_version(static_cast< ::ct::Version >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_id;
        break;
      }

      // optional .ct.LogID id = 2;
      case 2: {
        if (tag == 18) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_tree_size;
        break;
      }

      // optional int64 tree_size = 3;
      case 3: {
        if (tag == 24) {
         parse_tree_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &tree_size_)));
          set_has_tree_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_timestamp;
        break;
      }

      // optional uint64 timestamp = 4;
      case 4: {
        if (tag == 32) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_leaf_index;
        break;
      }

      // optional int64 leaf_index = 5;
      case 5: {
        if (tag == 40) {
         parse_leaf_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &leaf_index_)));
          set_has_leaf_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_path_node;
        break;
      }

      // repeated bytes path_node = 6;
      case 6: {
        if (tag == 50) {
         parse_path_node:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_path_node()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_path_node;
        if (input->ExpectTag(58)) goto parse_tree_head_signature;
        break;
      }

      // optional .ct.DigitallySigned tree_head_signature = 7;
      case 7: {
        if (tag == 58) {
         parse_tree_head_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tree_head_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.MerkleAuditProof)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.MerkleAuditProof)
  return false;
#undef DO_
}

void MerkleAuditProof::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.MerkleAuditProof)
  // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->version(), output);
  }

  // optional .ct.LogID id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->id(), output);
  }

  // optional int64 tree_size = 3;
  if (has_tree_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->tree_size(), output);
  }

  // optional uint64 timestamp = 4;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->timestamp(), output);
  }

  // optional int64 leaf_index = 5;
  if (has_leaf_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->leaf_index(), output);
  }

  // repeated bytes path_node = 6;
  for (int i = 0; i < this->path_node_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->path_node(i), output);
  }

  // optional .ct.DigitallySigned tree_head_signature = 7;
  if (has_tree_head_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->tree_head_signature(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.MerkleAuditProof)
}

::google::protobuf::uint8* MerkleAuditProof::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.MerkleAuditProof)
  // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->version(), target);
  }

  // optional .ct.LogID id = 2;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->id(), target);
  }

  // optional int64 tree_size = 3;
  if (has_tree_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->tree_size(), target);
  }

  // optional uint64 timestamp = 4;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->timestamp(), target);
  }

  // optional int64 leaf_index = 5;
  if (has_leaf_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->leaf_index(), target);
  }

  // repeated bytes path_node = 6;
  for (int i = 0; i < this->path_node_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(6, this->path_node(i), target);
  }

  // optional .ct.DigitallySigned tree_head_signature = 7;
  if (has_tree_head_signature()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->tree_head_signature(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.MerkleAuditProof)
  return target;
}

int MerkleAuditProof::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->version());
    }

    // optional .ct.LogID id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }

    // optional int64 tree_size = 3;
    if (has_tree_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->tree_size());
    }

    // optional uint64 timestamp = 4;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->timestamp());
    }

    // optional int64 leaf_index = 5;
    if (has_leaf_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->leaf_index());
    }

    // optional .ct.DigitallySigned tree_head_signature = 7;
    if (has_tree_head_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tree_head_signature());
    }

  }
  // repeated bytes path_node = 6;
  total_size += 1 * this->path_node_size();
  for (int i = 0; i < this->path_node_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->path_node(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MerkleAuditProof::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MerkleAuditProof* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MerkleAuditProof*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MerkleAuditProof::MergeFrom(const MerkleAuditProof& from) {
  GOOGLE_CHECK_NE(&from, this);
  path_node_.MergeFrom(from.path_node_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_id()) {
      mutable_id()->::ct::LogID::MergeFrom(from.id());
    }
    if (from.has_tree_size()) {
      set_tree_size(from.tree_size());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_leaf_index()) {
      set_leaf_index(from.leaf_index());
    }
    if (from.has_tree_head_signature()) {
      mutable_tree_head_signature()->::ct::DigitallySigned::MergeFrom(from.tree_head_signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MerkleAuditProof::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MerkleAuditProof::CopyFrom(const MerkleAuditProof& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MerkleAuditProof::IsInitialized() const {

  return true;
}

void MerkleAuditProof::Swap(MerkleAuditProof* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(id_, other->id_);
    std::swap(tree_size_, other->tree_size_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(leaf_index_, other->leaf_index_);
    path_node_.Swap(&other->path_node_);
    std::swap(tree_head_signature_, other->tree_head_signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MerkleAuditProof::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MerkleAuditProof_descriptor_;
  metadata.reflection = MerkleAuditProof_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShortMerkleAuditProof::kLeafIndexFieldNumber;
const int ShortMerkleAuditProof::kPathNodeFieldNumber;
#endif  // !_MSC_VER

ShortMerkleAuditProof::ShortMerkleAuditProof()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.ShortMerkleAuditProof)
}

void ShortMerkleAuditProof::InitAsDefaultInstance() {
}

ShortMerkleAuditProof::ShortMerkleAuditProof(const ShortMerkleAuditProof& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.ShortMerkleAuditProof)
}

void ShortMerkleAuditProof::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  leaf_index_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShortMerkleAuditProof::~ShortMerkleAuditProof() {
  // @@protoc_insertion_point(destructor:ct.ShortMerkleAuditProof)
  SharedDtor();
}

void ShortMerkleAuditProof::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ShortMerkleAuditProof::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShortMerkleAuditProof::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShortMerkleAuditProof_descriptor_;
}

const ShortMerkleAuditProof& ShortMerkleAuditProof::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

ShortMerkleAuditProof* ShortMerkleAuditProof::default_instance_ = NULL;

ShortMerkleAuditProof* ShortMerkleAuditProof::New() const {
  return new ShortMerkleAuditProof;
}

void ShortMerkleAuditProof::Clear() {
  leaf_index_ = GOOGLE_LONGLONG(0);
  path_node_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShortMerkleAuditProof::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.ShortMerkleAuditProof)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 leaf_index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &leaf_index_)));
          set_has_leaf_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_path_node;
        break;
      }

      // repeated bytes path_node = 2;
      case 2: {
        if (tag == 18) {
         parse_path_node:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_path_node()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_path_node;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.ShortMerkleAuditProof)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.ShortMerkleAuditProof)
  return false;
#undef DO_
}

void ShortMerkleAuditProof::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.ShortMerkleAuditProof)
  // required int64 leaf_index = 1;
  if (has_leaf_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->leaf_index(), output);
  }

  // repeated bytes path_node = 2;
  for (int i = 0; i < this->path_node_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->path_node(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.ShortMerkleAuditProof)
}

::google::protobuf::uint8* ShortMerkleAuditProof::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.ShortMerkleAuditProof)
  // required int64 leaf_index = 1;
  if (has_leaf_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->leaf_index(), target);
  }

  // repeated bytes path_node = 2;
  for (int i = 0; i < this->path_node_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(2, this->path_node(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.ShortMerkleAuditProof)
  return target;
}

int ShortMerkleAuditProof::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 leaf_index = 1;
    if (has_leaf_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->leaf_index());
    }

  }
  // repeated bytes path_node = 2;
  total_size += 1 * this->path_node_size();
  for (int i = 0; i < this->path_node_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->path_node(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShortMerkleAuditProof::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShortMerkleAuditProof* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShortMerkleAuditProof*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShortMerkleAuditProof::MergeFrom(const ShortMerkleAuditProof& from) {
  GOOGLE_CHECK_NE(&from, this);
  path_node_.MergeFrom(from.path_node_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_leaf_index()) {
      set_leaf_index(from.leaf_index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShortMerkleAuditProof::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShortMerkleAuditProof::CopyFrom(const ShortMerkleAuditProof& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShortMerkleAuditProof::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ShortMerkleAuditProof::Swap(ShortMerkleAuditProof* other) {
  if (other != this) {
    std::swap(leaf_index_, other->leaf_index_);
    path_node_.Swap(&other->path_node_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShortMerkleAuditProof::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShortMerkleAuditProof_descriptor_;
  metadata.reflection = ShortMerkleAuditProof_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LoggedEntryPB_Contents::kSctFieldNumber;
const int LoggedEntryPB_Contents::kEntryFieldNumber;
#endif  // !_MSC_VER

LoggedEntryPB_Contents::LoggedEntryPB_Contents()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.LoggedEntryPB.Contents)
}

void LoggedEntryPB_Contents::InitAsDefaultInstance() {
  sct_ = const_cast< ::ct::SignedCertificateTimestamp*>(&::ct::SignedCertificateTimestamp::default_instance());
  entry_ = const_cast< ::ct::LogEntry*>(&::ct::LogEntry::default_instance());
}

LoggedEntryPB_Contents::LoggedEntryPB_Contents(const LoggedEntryPB_Contents& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.LoggedEntryPB.Contents)
}

void LoggedEntryPB_Contents::SharedCtor() {
  _cached_size_ = 0;
  sct_ = NULL;
  entry_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoggedEntryPB_Contents::~LoggedEntryPB_Contents() {
  // @@protoc_insertion_point(destructor:ct.LoggedEntryPB.Contents)
  SharedDtor();
}

void LoggedEntryPB_Contents::SharedDtor() {
  if (this != default_instance_) {
    delete sct_;
    delete entry_;
  }
}

void LoggedEntryPB_Contents::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoggedEntryPB_Contents::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoggedEntryPB_Contents_descriptor_;
}

const LoggedEntryPB_Contents& LoggedEntryPB_Contents::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

LoggedEntryPB_Contents* LoggedEntryPB_Contents::default_instance_ = NULL;

LoggedEntryPB_Contents* LoggedEntryPB_Contents::New() const {
  return new LoggedEntryPB_Contents;
}

void LoggedEntryPB_Contents::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_sct()) {
      if (sct_ != NULL) sct_->::ct::SignedCertificateTimestamp::Clear();
    }
    if (has_entry()) {
      if (entry_ != NULL) entry_->::ct::LogEntry::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LoggedEntryPB_Contents::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.LoggedEntryPB.Contents)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ct.SignedCertificateTimestamp sct = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sct()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_entry;
        break;
      }

      // optional .ct.LogEntry entry = 2;
      case 2: {
        if (tag == 18) {
         parse_entry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_entry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.LoggedEntryPB.Contents)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.LoggedEntryPB.Contents)
  return false;
#undef DO_
}

void LoggedEntryPB_Contents::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.LoggedEntryPB.Contents)
  // optional .ct.SignedCertificateTimestamp sct = 1;
  if (has_sct()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->sct(), output);
  }

  // optional .ct.LogEntry entry = 2;
  if (has_entry()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->entry(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.LoggedEntryPB.Contents)
}

::google::protobuf::uint8* LoggedEntryPB_Contents::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.LoggedEntryPB.Contents)
  // optional .ct.SignedCertificateTimestamp sct = 1;
  if (has_sct()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->sct(), target);
  }

  // optional .ct.LogEntry entry = 2;
  if (has_entry()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->entry(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.LoggedEntryPB.Contents)
  return target;
}

int LoggedEntryPB_Contents::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ct.SignedCertificateTimestamp sct = 1;
    if (has_sct()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sct());
    }

    // optional .ct.LogEntry entry = 2;
    if (has_entry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->entry());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoggedEntryPB_Contents::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LoggedEntryPB_Contents* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LoggedEntryPB_Contents*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LoggedEntryPB_Contents::MergeFrom(const LoggedEntryPB_Contents& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sct()) {
      mutable_sct()->::ct::SignedCertificateTimestamp::MergeFrom(from.sct());
    }
    if (from.has_entry()) {
      mutable_entry()->::ct::LogEntry::MergeFrom(from.entry());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LoggedEntryPB_Contents::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoggedEntryPB_Contents::CopyFrom(const LoggedEntryPB_Contents& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoggedEntryPB_Contents::IsInitialized() const {

  return true;
}

void LoggedEntryPB_Contents::Swap(LoggedEntryPB_Contents* other) {
  if (other != this) {
    std::swap(sct_, other->sct_);
    std::swap(entry_, other->entry_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LoggedEntryPB_Contents::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LoggedEntryPB_Contents_descriptor_;
  metadata.reflection = LoggedEntryPB_Contents_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int LoggedEntryPB::kSequenceNumberFieldNumber;
const int LoggedEntryPB::kMerkleLeafHashFieldNumber;
const int LoggedEntryPB::kContentsFieldNumber;
#endif  // !_MSC_VER

LoggedEntryPB::LoggedEntryPB()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.LoggedEntryPB)
}

void LoggedEntryPB::InitAsDefaultInstance() {
  contents_ = const_cast< ::ct::LoggedEntryPB_Contents*>(&::ct::LoggedEntryPB_Contents::default_instance());
}

LoggedEntryPB::LoggedEntryPB(const LoggedEntryPB& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.LoggedEntryPB)
}

void LoggedEntryPB::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  sequence_number_ = GOOGLE_LONGLONG(0);
  merkle_leaf_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  contents_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoggedEntryPB::~LoggedEntryPB() {
  // @@protoc_insertion_point(destructor:ct.LoggedEntryPB)
  SharedDtor();
}

void LoggedEntryPB::SharedDtor() {
  if (merkle_leaf_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete merkle_leaf_hash_;
  }
  if (this != default_instance_) {
    delete contents_;
  }
}

void LoggedEntryPB::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoggedEntryPB::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoggedEntryPB_descriptor_;
}

const LoggedEntryPB& LoggedEntryPB::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

LoggedEntryPB* LoggedEntryPB::default_instance_ = NULL;

LoggedEntryPB* LoggedEntryPB::New() const {
  return new LoggedEntryPB;
}

void LoggedEntryPB::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    sequence_number_ = GOOGLE_LONGLONG(0);
    if (has_merkle_leaf_hash()) {
      if (merkle_leaf_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        merkle_leaf_hash_->clear();
      }
    }
    if (has_contents()) {
      if (contents_ != NULL) contents_->::ct::LoggedEntryPB_Contents::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LoggedEntryPB::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.LoggedEntryPB)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 sequence_number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &sequence_number_)));
          set_has_sequence_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_merkle_leaf_hash;
        break;
      }

      // optional bytes merkle_leaf_hash = 2;
      case 2: {
        if (tag == 18) {
         parse_merkle_leaf_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_merkle_leaf_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_contents;
        break;
      }

      // required .ct.LoggedEntryPB.Contents contents = 3;
      case 3: {
        if (tag == 26) {
         parse_contents:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_contents()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.LoggedEntryPB)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.LoggedEntryPB)
  return false;
#undef DO_
}

void LoggedEntryPB::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.LoggedEntryPB)
  // optional int64 sequence_number = 1;
  if (has_sequence_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->sequence_number(), output);
  }

  // optional bytes merkle_leaf_hash = 2;
  if (has_merkle_leaf_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->merkle_leaf_hash(), output);
  }

  // required .ct.LoggedEntryPB.Contents contents = 3;
  if (has_contents()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->contents(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.LoggedEntryPB)
}

::google::protobuf::uint8* LoggedEntryPB::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.LoggedEntryPB)
  // optional int64 sequence_number = 1;
  if (has_sequence_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->sequence_number(), target);
  }

  // optional bytes merkle_leaf_hash = 2;
  if (has_merkle_leaf_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->merkle_leaf_hash(), target);
  }

  // required .ct.LoggedEntryPB.Contents contents = 3;
  if (has_contents()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->contents(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.LoggedEntryPB)
  return target;
}

int LoggedEntryPB::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 sequence_number = 1;
    if (has_sequence_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->sequence_number());
    }

    // optional bytes merkle_leaf_hash = 2;
    if (has_merkle_leaf_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->merkle_leaf_hash());
    }

    // required .ct.LoggedEntryPB.Contents contents = 3;
    if (has_contents()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->contents());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoggedEntryPB::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LoggedEntryPB* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LoggedEntryPB*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LoggedEntryPB::MergeFrom(const LoggedEntryPB& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sequence_number()) {
      set_sequence_number(from.sequence_number());
    }
    if (from.has_merkle_leaf_hash()) {
      set_merkle_leaf_hash(from.merkle_leaf_hash());
    }
    if (from.has_contents()) {
      mutable_contents()->::ct::LoggedEntryPB_Contents::MergeFrom(from.contents());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LoggedEntryPB::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoggedEntryPB::CopyFrom(const LoggedEntryPB& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoggedEntryPB::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;

  return true;
}

void LoggedEntryPB::Swap(LoggedEntryPB* other) {
  if (other != this) {
    std::swap(sequence_number_, other->sequence_number_);
    std::swap(merkle_leaf_hash_, other->merkle_leaf_hash_);
    std::swap(contents_, other->contents_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LoggedEntryPB::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LoggedEntryPB_descriptor_;
  metadata.reflection = LoggedEntryPB_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SthExtension::kSthExtensionTypeFieldNumber;
const int SthExtension::kSthExtensionDataFieldNumber;
#endif  // !_MSC_VER

SthExtension::SthExtension()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.SthExtension)
}

void SthExtension::InitAsDefaultInstance() {
}

SthExtension::SthExtension(const SthExtension& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.SthExtension)
}

void SthExtension::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  sth_extension_type_ = 0u;
  sth_extension_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SthExtension::~SthExtension() {
  // @@protoc_insertion_point(destructor:ct.SthExtension)
  SharedDtor();
}

void SthExtension::SharedDtor() {
  if (sth_extension_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sth_extension_data_;
  }
  if (this != default_instance_) {
  }
}

void SthExtension::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SthExtension::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SthExtension_descriptor_;
}

const SthExtension& SthExtension::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

SthExtension* SthExtension::default_instance_ = NULL;

SthExtension* SthExtension::New() const {
  return new SthExtension;
}

void SthExtension::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    sth_extension_type_ = 0u;
    if (has_sth_extension_data()) {
      if (sth_extension_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        sth_extension_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SthExtension::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.SthExtension)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 sth_extension_type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sth_extension_type_)));
          set_has_sth_extension_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_sth_extension_data;
        break;
      }

      // optional bytes sth_extension_data = 2;
      case 2: {
        if (tag == 18) {
         parse_sth_extension_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_sth_extension_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.SthExtension)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.SthExtension)
  return false;
#undef DO_
}

void SthExtension::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.SthExtension)
  // optional uint32 sth_extension_type = 1;
  if (has_sth_extension_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sth_extension_type(), output);
  }

  // optional bytes sth_extension_data = 2;
  if (has_sth_extension_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->sth_extension_data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.SthExtension)
}

::google::protobuf::uint8* SthExtension::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.SthExtension)
  // optional uint32 sth_extension_type = 1;
  if (has_sth_extension_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sth_extension_type(), target);
  }

  // optional bytes sth_extension_data = 2;
  if (has_sth_extension_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->sth_extension_data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.SthExtension)
  return target;
}

int SthExtension::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 sth_extension_type = 1;
    if (has_sth_extension_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sth_extension_type());
    }

    // optional bytes sth_extension_data = 2;
    if (has_sth_extension_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->sth_extension_data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SthExtension::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SthExtension* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SthExtension*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SthExtension::MergeFrom(const SthExtension& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sth_extension_type()) {
      set_sth_extension_type(from.sth_extension_type());
    }
    if (from.has_sth_extension_data()) {
      set_sth_extension_data(from.sth_extension_data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SthExtension::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SthExtension::CopyFrom(const SthExtension& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SthExtension::IsInitialized() const {

  return true;
}

void SthExtension::Swap(SthExtension* other) {
  if (other != this) {
    std::swap(sth_extension_type_, other->sth_extension_type_);
    std::swap(sth_extension_data_, other->sth_extension_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SthExtension::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SthExtension_descriptor_;
  metadata.reflection = SthExtension_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SignedTreeHead::kVersionFieldNumber;
const int SignedTreeHead::kIdFieldNumber;
const int SignedTreeHead::kTimestampFieldNumber;
const int SignedTreeHead::kTreeSizeFieldNumber;
const int SignedTreeHead::kSha256RootHashFieldNumber;
const int SignedTreeHead::kSignatureFieldNumber;
const int SignedTreeHead::kSthExtensionFieldNumber;
#endif  // !_MSC_VER

SignedTreeHead::SignedTreeHead()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.SignedTreeHead)
}

void SignedTreeHead::InitAsDefaultInstance() {
  id_ = const_cast< ::ct::LogID*>(&::ct::LogID::default_instance());
  signature_ = const_cast< ::ct::DigitallySigned*>(&::ct::DigitallySigned::default_instance());
}

SignedTreeHead::SignedTreeHead(const SignedTreeHead& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.SignedTreeHead)
}

void SignedTreeHead::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  version_ = 256;
  id_ = NULL;
  timestamp_ = GOOGLE_ULONGLONG(0);
  tree_size_ = GOOGLE_LONGLONG(0);
  sha256_root_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignedTreeHead::~SignedTreeHead() {
  // @@protoc_insertion_point(destructor:ct.SignedTreeHead)
  SharedDtor();
}

void SignedTreeHead::SharedDtor() {
  if (sha256_root_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sha256_root_hash_;
  }
  if (this != default_instance_) {
    delete id_;
    delete signature_;
  }
}

void SignedTreeHead::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignedTreeHead::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignedTreeHead_descriptor_;
}

const SignedTreeHead& SignedTreeHead::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

SignedTreeHead* SignedTreeHead::default_instance_ = NULL;

SignedTreeHead* SignedTreeHead::New() const {
  return new SignedTreeHead;
}

void SignedTreeHead::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SignedTreeHead*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(timestamp_, tree_size_);
    version_ = 256;
    if (has_id()) {
      if (id_ != NULL) id_->::ct::LogID::Clear();
    }
    if (has_sha256_root_hash()) {
      if (sha256_root_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        sha256_root_hash_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != NULL) signature_->::ct::DigitallySigned::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  sth_extension_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignedTreeHead::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.SignedTreeHead)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ct::Version_IsValid(value)) {
            set_version(static_cast< ::ct::Version >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_id;
        break;
      }

      // optional .ct.LogID id = 2;
      case 2: {
        if (tag == 18) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_timestamp;
        break;
      }

      // optional uint64 timestamp = 3;
      case 3: {
        if (tag == 24) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_tree_size;
        break;
      }

      // optional int64 tree_size = 4;
      case 4: {
        if (tag == 32) {
         parse_tree_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &tree_size_)));
          set_has_tree_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_sha256_root_hash;
        break;
      }

      // optional bytes sha256_root_hash = 5;
      case 5: {
        if (tag == 42) {
         parse_sha256_root_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_sha256_root_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_signature;
        break;
      }

      // optional .ct.DigitallySigned signature = 6;
      case 6: {
        if (tag == 50) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_sth_extension;
        break;
      }

      // repeated .ct.SthExtension sth_extension = 7;
      case 7: {
        if (tag == 58) {
         parse_sth_extension:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sth_extension()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_sth_extension;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.SignedTreeHead)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.SignedTreeHead)
  return false;
#undef DO_
}

void SignedTreeHead::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.SignedTreeHead)
  // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->version(), output);
  }

  // optional .ct.LogID id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->id(), output);
  }

  // optional uint64 timestamp = 3;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->timestamp(), output);
  }

  // optional int64 tree_size = 4;
  if (has_tree_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->tree_size(), output);
  }

  // optional bytes sha256_root_hash = 5;
  if (has_sha256_root_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->sha256_root_hash(), output);
  }

  // optional .ct.DigitallySigned signature = 6;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->signature(), output);
  }

  // repeated .ct.SthExtension sth_extension = 7;
  for (int i = 0; i < this->sth_extension_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->sth_extension(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.SignedTreeHead)
}

::google::protobuf::uint8* SignedTreeHead::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.SignedTreeHead)
  // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->version(), target);
  }

  // optional .ct.LogID id = 2;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->id(), target);
  }

  // optional uint64 timestamp = 3;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->timestamp(), target);
  }

  // optional int64 tree_size = 4;
  if (has_tree_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->tree_size(), target);
  }

  // optional bytes sha256_root_hash = 5;
  if (has_sha256_root_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->sha256_root_hash(), target);
  }

  // optional .ct.DigitallySigned signature = 6;
  if (has_signature()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->signature(), target);
  }

  // repeated .ct.SthExtension sth_extension = 7;
  for (int i = 0; i < this->sth_extension_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->sth_extension(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.SignedTreeHead)
  return target;
}

int SignedTreeHead::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->version());
    }

    // optional .ct.LogID id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }

    // optional uint64 timestamp = 3;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->timestamp());
    }

    // optional int64 tree_size = 4;
    if (has_tree_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->tree_size());
    }

    // optional bytes sha256_root_hash = 5;
    if (has_sha256_root_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->sha256_root_hash());
    }

    // optional .ct.DigitallySigned signature = 6;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->signature());
    }

  }
  // repeated .ct.SthExtension sth_extension = 7;
  total_size += 1 * this->sth_extension_size();
  for (int i = 0; i < this->sth_extension_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sth_extension(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignedTreeHead::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignedTreeHead* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SignedTreeHead*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignedTreeHead::MergeFrom(const SignedTreeHead& from) {
  GOOGLE_CHECK_NE(&from, this);
  sth_extension_.MergeFrom(from.sth_extension_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_id()) {
      mutable_id()->::ct::LogID::MergeFrom(from.id());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_tree_size()) {
      set_tree_size(from.tree_size());
    }
    if (from.has_sha256_root_hash()) {
      set_sha256_root_hash(from.sha256_root_hash());
    }
    if (from.has_signature()) {
      mutable_signature()->::ct::DigitallySigned::MergeFrom(from.signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignedTreeHead::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignedTreeHead::CopyFrom(const SignedTreeHead& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignedTreeHead::IsInitialized() const {

  return true;
}

void SignedTreeHead::Swap(SignedTreeHead* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(id_, other->id_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(tree_size_, other->tree_size_);
    std::swap(sha256_root_hash_, other->sha256_root_hash_);
    std::swap(signature_, other->signature_);
    sth_extension_.Swap(&other->sth_extension_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SignedTreeHead::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SignedTreeHead_descriptor_;
  metadata.reflection = SignedTreeHead_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SSLClientCTData_SCTInfo::kSctFieldNumber;
const int SSLClientCTData_SCTInfo::kMerkleLeafHashFieldNumber;
#endif  // !_MSC_VER

SSLClientCTData_SCTInfo::SSLClientCTData_SCTInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.SSLClientCTData.SCTInfo)
}

void SSLClientCTData_SCTInfo::InitAsDefaultInstance() {
  sct_ = const_cast< ::ct::SignedCertificateTimestamp*>(&::ct::SignedCertificateTimestamp::default_instance());
}

SSLClientCTData_SCTInfo::SSLClientCTData_SCTInfo(const SSLClientCTData_SCTInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.SSLClientCTData.SCTInfo)
}

void SSLClientCTData_SCTInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  sct_ = NULL;
  merkle_leaf_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SSLClientCTData_SCTInfo::~SSLClientCTData_SCTInfo() {
  // @@protoc_insertion_point(destructor:ct.SSLClientCTData.SCTInfo)
  SharedDtor();
}

void SSLClientCTData_SCTInfo::SharedDtor() {
  if (merkle_leaf_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete merkle_leaf_hash_;
  }
  if (this != default_instance_) {
    delete sct_;
  }
}

void SSLClientCTData_SCTInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SSLClientCTData_SCTInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SSLClientCTData_SCTInfo_descriptor_;
}

const SSLClientCTData_SCTInfo& SSLClientCTData_SCTInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

SSLClientCTData_SCTInfo* SSLClientCTData_SCTInfo::default_instance_ = NULL;

SSLClientCTData_SCTInfo* SSLClientCTData_SCTInfo::New() const {
  return new SSLClientCTData_SCTInfo;
}

void SSLClientCTData_SCTInfo::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_sct()) {
      if (sct_ != NULL) sct_->::ct::SignedCertificateTimestamp::Clear();
    }
    if (has_merkle_leaf_hash()) {
      if (merkle_leaf_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        merkle_leaf_hash_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SSLClientCTData_SCTInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.SSLClientCTData.SCTInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ct.SignedCertificateTimestamp sct = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sct()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_merkle_leaf_hash;
        break;
      }

      // optional bytes merkle_leaf_hash = 2;
      case 2: {
        if (tag == 18) {
         parse_merkle_leaf_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_merkle_leaf_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.SSLClientCTData.SCTInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.SSLClientCTData.SCTInfo)
  return false;
#undef DO_
}

void SSLClientCTData_SCTInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.SSLClientCTData.SCTInfo)
  // optional .ct.SignedCertificateTimestamp sct = 1;
  if (has_sct()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->sct(), output);
  }

  // optional bytes merkle_leaf_hash = 2;
  if (has_merkle_leaf_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->merkle_leaf_hash(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.SSLClientCTData.SCTInfo)
}

::google::protobuf::uint8* SSLClientCTData_SCTInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.SSLClientCTData.SCTInfo)
  // optional .ct.SignedCertificateTimestamp sct = 1;
  if (has_sct()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->sct(), target);
  }

  // optional bytes merkle_leaf_hash = 2;
  if (has_merkle_leaf_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->merkle_leaf_hash(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.SSLClientCTData.SCTInfo)
  return target;
}

int SSLClientCTData_SCTInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ct.SignedCertificateTimestamp sct = 1;
    if (has_sct()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sct());
    }

    // optional bytes merkle_leaf_hash = 2;
    if (has_merkle_leaf_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->merkle_leaf_hash());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SSLClientCTData_SCTInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SSLClientCTData_SCTInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SSLClientCTData_SCTInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SSLClientCTData_SCTInfo::MergeFrom(const SSLClientCTData_SCTInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sct()) {
      mutable_sct()->::ct::SignedCertificateTimestamp::MergeFrom(from.sct());
    }
    if (from.has_merkle_leaf_hash()) {
      set_merkle_leaf_hash(from.merkle_leaf_hash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SSLClientCTData_SCTInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SSLClientCTData_SCTInfo::CopyFrom(const SSLClientCTData_SCTInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SSLClientCTData_SCTInfo::IsInitialized() const {

  return true;
}

void SSLClientCTData_SCTInfo::Swap(SSLClientCTData_SCTInfo* other) {
  if (other != this) {
    std::swap(sct_, other->sct_);
    std::swap(merkle_leaf_hash_, other->merkle_leaf_hash_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SSLClientCTData_SCTInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SSLClientCTData_SCTInfo_descriptor_;
  metadata.reflection = SSLClientCTData_SCTInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SSLClientCTData::kReconstructedEntryFieldNumber;
const int SSLClientCTData::kCertificateSha256HashFieldNumber;
const int SSLClientCTData::kAttachedSctInfoFieldNumber;
#endif  // !_MSC_VER

SSLClientCTData::SSLClientCTData()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.SSLClientCTData)
}

void SSLClientCTData::InitAsDefaultInstance() {
  reconstructed_entry_ = const_cast< ::ct::LogEntry*>(&::ct::LogEntry::default_instance());
}

SSLClientCTData::SSLClientCTData(const SSLClientCTData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.SSLClientCTData)
}

void SSLClientCTData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  reconstructed_entry_ = NULL;
  certificate_sha256_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SSLClientCTData::~SSLClientCTData() {
  // @@protoc_insertion_point(destructor:ct.SSLClientCTData)
  SharedDtor();
}

void SSLClientCTData::SharedDtor() {
  if (certificate_sha256_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete certificate_sha256_hash_;
  }
  if (this != default_instance_) {
    delete reconstructed_entry_;
  }
}

void SSLClientCTData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SSLClientCTData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SSLClientCTData_descriptor_;
}

const SSLClientCTData& SSLClientCTData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

SSLClientCTData* SSLClientCTData::default_instance_ = NULL;

SSLClientCTData* SSLClientCTData::New() const {
  return new SSLClientCTData;
}

void SSLClientCTData::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_reconstructed_entry()) {
      if (reconstructed_entry_ != NULL) reconstructed_entry_->::ct::LogEntry::Clear();
    }
    if (has_certificate_sha256_hash()) {
      if (certificate_sha256_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        certificate_sha256_hash_->clear();
      }
    }
  }
  attached_sct_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SSLClientCTData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.SSLClientCTData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ct.LogEntry reconstructed_entry = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reconstructed_entry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_certificate_sha256_hash;
        break;
      }

      // optional bytes certificate_sha256_hash = 2;
      case 2: {
        if (tag == 18) {
         parse_certificate_sha256_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_certificate_sha256_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_attached_sct_info;
        break;
      }

      // repeated .ct.SSLClientCTData.SCTInfo attached_sct_info = 3;
      case 3: {
        if (tag == 26) {
         parse_attached_sct_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_attached_sct_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_attached_sct_info;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.SSLClientCTData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.SSLClientCTData)
  return false;
#undef DO_
}

void SSLClientCTData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.SSLClientCTData)
  // optional .ct.LogEntry reconstructed_entry = 1;
  if (has_reconstructed_entry()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->reconstructed_entry(), output);
  }

  // optional bytes certificate_sha256_hash = 2;
  if (has_certificate_sha256_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->certificate_sha256_hash(), output);
  }

  // repeated .ct.SSLClientCTData.SCTInfo attached_sct_info = 3;
  for (int i = 0; i < this->attached_sct_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->attached_sct_info(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.SSLClientCTData)
}

::google::protobuf::uint8* SSLClientCTData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.SSLClientCTData)
  // optional .ct.LogEntry reconstructed_entry = 1;
  if (has_reconstructed_entry()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->reconstructed_entry(), target);
  }

  // optional bytes certificate_sha256_hash = 2;
  if (has_certificate_sha256_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->certificate_sha256_hash(), target);
  }

  // repeated .ct.SSLClientCTData.SCTInfo attached_sct_info = 3;
  for (int i = 0; i < this->attached_sct_info_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->attached_sct_info(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.SSLClientCTData)
  return target;
}

int SSLClientCTData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ct.LogEntry reconstructed_entry = 1;
    if (has_reconstructed_entry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reconstructed_entry());
    }

    // optional bytes certificate_sha256_hash = 2;
    if (has_certificate_sha256_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->certificate_sha256_hash());
    }

  }
  // repeated .ct.SSLClientCTData.SCTInfo attached_sct_info = 3;
  total_size += 1 * this->attached_sct_info_size();
  for (int i = 0; i < this->attached_sct_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->attached_sct_info(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SSLClientCTData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SSLClientCTData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SSLClientCTData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SSLClientCTData::MergeFrom(const SSLClientCTData& from) {
  GOOGLE_CHECK_NE(&from, this);
  attached_sct_info_.MergeFrom(from.attached_sct_info_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reconstructed_entry()) {
      mutable_reconstructed_entry()->::ct::LogEntry::MergeFrom(from.reconstructed_entry());
    }
    if (from.has_certificate_sha256_hash()) {
      set_certificate_sha256_hash(from.certificate_sha256_hash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SSLClientCTData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SSLClientCTData::CopyFrom(const SSLClientCTData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SSLClientCTData::IsInitialized() const {

  return true;
}

void SSLClientCTData::Swap(SSLClientCTData* other) {
  if (other != this) {
    std::swap(reconstructed_entry_, other->reconstructed_entry_);
    std::swap(certificate_sha256_hash_, other->certificate_sha256_hash_);
    attached_sct_info_.Swap(&other->attached_sct_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SSLClientCTData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SSLClientCTData_descriptor_;
  metadata.reflection = SSLClientCTData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClusterNodeState::kNodeIdFieldNumber;
const int ClusterNodeState::kContiguousTreeSizeFieldNumber;
const int ClusterNodeState::kNewestSthFieldNumber;
const int ClusterNodeState::kCurrentServingSthFieldNumber;
const int ClusterNodeState::kHostnameFieldNumber;
const int ClusterNodeState::kLogPortFieldNumber;
#endif  // !_MSC_VER

ClusterNodeState::ClusterNodeState()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.ClusterNodeState)
}

void ClusterNodeState::InitAsDefaultInstance() {
  newest_sth_ = const_cast< ::ct::SignedTreeHead*>(&::ct::SignedTreeHead::default_instance());
  current_serving_sth_ = const_cast< ::ct::SignedTreeHead*>(&::ct::SignedTreeHead::default_instance());
}

ClusterNodeState::ClusterNodeState(const ClusterNodeState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.ClusterNodeState)
}

void ClusterNodeState::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  contiguous_tree_size_ = GOOGLE_LONGLONG(0);
  newest_sth_ = NULL;
  current_serving_sth_ = NULL;
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  log_port_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClusterNodeState::~ClusterNodeState() {
  // @@protoc_insertion_point(destructor:ct.ClusterNodeState)
  SharedDtor();
}

void ClusterNodeState::SharedDtor() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_id_;
  }
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (this != default_instance_) {
    delete newest_sth_;
    delete current_serving_sth_;
  }
}

void ClusterNodeState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClusterNodeState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClusterNodeState_descriptor_;
}

const ClusterNodeState& ClusterNodeState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

ClusterNodeState* ClusterNodeState::default_instance_ = NULL;

ClusterNodeState* ClusterNodeState::New() const {
  return new ClusterNodeState;
}

void ClusterNodeState::Clear() {
  if (_has_bits_[0 / 32] & 63) {
    if (has_node_id()) {
      if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        node_id_->clear();
      }
    }
    contiguous_tree_size_ = GOOGLE_LONGLONG(0);
    if (has_newest_sth()) {
      if (newest_sth_ != NULL) newest_sth_->::ct::SignedTreeHead::Clear();
    }
    if (has_current_serving_sth()) {
      if (current_serving_sth_ != NULL) current_serving_sth_->::ct::SignedTreeHead::Clear();
    }
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hostname_->clear();
      }
    }
    log_port_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClusterNodeState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.ClusterNodeState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string node_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_node_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->node_id().data(), this->node_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "node_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_contiguous_tree_size;
        break;
      }

      // optional int64 contiguous_tree_size = 2 [deprecated = true];
      case 2: {
        if (tag == 16) {
         parse_contiguous_tree_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &contiguous_tree_size_)));
          set_has_contiguous_tree_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_newest_sth;
        break;
      }

      // optional .ct.SignedTreeHead newest_sth = 3;
      case 3: {
        if (tag == 26) {
         parse_newest_sth:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_newest_sth()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_current_serving_sth;
        break;
      }

      // optional .ct.SignedTreeHead current_serving_sth = 4;
      case 4: {
        if (tag == 34) {
         parse_current_serving_sth:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_current_serving_sth()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_hostname;
        break;
      }

      // optional string hostname = 5;
      case 5: {
        if (tag == 42) {
         parse_hostname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hostname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_log_port;
        break;
      }

      // optional int32 log_port = 6;
      case 6: {
        if (tag == 48) {
         parse_log_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &log_port_)));
          set_has_log_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.ClusterNodeState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.ClusterNodeState)
  return false;
#undef DO_
}

void ClusterNodeState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.ClusterNodeState)
  // optional string node_id = 1;
  if (has_node_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->node_id().data(), this->node_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "node_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->node_id(), output);
  }

  // optional int64 contiguous_tree_size = 2 [deprecated = true];
  if (has_contiguous_tree_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->contiguous_tree_size(), output);
  }

  // optional .ct.SignedTreeHead newest_sth = 3;
  if (has_newest_sth()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->newest_sth(), output);
  }

  // optional .ct.SignedTreeHead current_serving_sth = 4;
  if (has_current_serving_sth()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->current_serving_sth(), output);
  }

  // optional string hostname = 5;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->hostname(), output);
  }

  // optional int32 log_port = 6;
  if (has_log_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->log_port(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.ClusterNodeState)
}

::google::protobuf::uint8* ClusterNodeState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.ClusterNodeState)
  // optional string node_id = 1;
  if (has_node_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->node_id().data(), this->node_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "node_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->node_id(), target);
  }

  // optional int64 contiguous_tree_size = 2 [deprecated = true];
  if (has_contiguous_tree_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->contiguous_tree_size(), target);
  }

  // optional .ct.SignedTreeHead newest_sth = 3;
  if (has_newest_sth()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->newest_sth(), target);
  }

  // optional .ct.SignedTreeHead current_serving_sth = 4;
  if (has_current_serving_sth()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->current_serving_sth(), target);
  }

  // optional string hostname = 5;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->hostname(), target);
  }

  // optional int32 log_port = 6;
  if (has_log_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->log_port(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.ClusterNodeState)
  return target;
}

int ClusterNodeState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string node_id = 1;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->node_id());
    }

    // optional int64 contiguous_tree_size = 2 [deprecated = true];
    if (has_contiguous_tree_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->contiguous_tree_size());
    }

    // optional .ct.SignedTreeHead newest_sth = 3;
    if (has_newest_sth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->newest_sth());
    }

    // optional .ct.SignedTreeHead current_serving_sth = 4;
    if (has_current_serving_sth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->current_serving_sth());
    }

    // optional string hostname = 5;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // optional int32 log_port = 6;
    if (has_log_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->log_port());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClusterNodeState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClusterNodeState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClusterNodeState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClusterNodeState::MergeFrom(const ClusterNodeState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_node_id()) {
      set_node_id(from.node_id());
    }
    if (from.has_contiguous_tree_size()) {
      set_contiguous_tree_size(from.contiguous_tree_size());
    }
    if (from.has_newest_sth()) {
      mutable_newest_sth()->::ct::SignedTreeHead::MergeFrom(from.newest_sth());
    }
    if (from.has_current_serving_sth()) {
      mutable_current_serving_sth()->::ct::SignedTreeHead::MergeFrom(from.current_serving_sth());
    }
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
    if (from.has_log_port()) {
      set_log_port(from.log_port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClusterNodeState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClusterNodeState::CopyFrom(const ClusterNodeState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClusterNodeState::IsInitialized() const {

  return true;
}

void ClusterNodeState::Swap(ClusterNodeState* other) {
  if (other != this) {
    std::swap(node_id_, other->node_id_);
    std::swap(contiguous_tree_size_, other->contiguous_tree_size_);
    std::swap(newest_sth_, other->newest_sth_);
    std::swap(current_serving_sth_, other->current_serving_sth_);
    std::swap(hostname_, other->hostname_);
    std::swap(log_port_, other->log_port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClusterNodeState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClusterNodeState_descriptor_;
  metadata.reflection = ClusterNodeState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClusterControl::kAcceptNewEntriesFieldNumber;
#endif  // !_MSC_VER

ClusterControl::ClusterControl()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.ClusterControl)
}

void ClusterControl::InitAsDefaultInstance() {
}

ClusterControl::ClusterControl(const ClusterControl& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.ClusterControl)
}

void ClusterControl::SharedCtor() {
  _cached_size_ = 0;
  accept_new_entries_ = true;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClusterControl::~ClusterControl() {
  // @@protoc_insertion_point(destructor:ct.ClusterControl)
  SharedDtor();
}

void ClusterControl::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClusterControl::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClusterControl::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClusterControl_descriptor_;
}

const ClusterControl& ClusterControl::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

ClusterControl* ClusterControl::default_instance_ = NULL;

ClusterControl* ClusterControl::New() const {
  return new ClusterControl;
}

void ClusterControl::Clear() {
  accept_new_entries_ = true;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClusterControl::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.ClusterControl)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool accept_new_entries = 1 [default = true];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &accept_new_entries_)));
          set_has_accept_new_entries();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.ClusterControl)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.ClusterControl)
  return false;
#undef DO_
}

void ClusterControl::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.ClusterControl)
  // optional bool accept_new_entries = 1 [default = true];
  if (has_accept_new_entries()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->accept_new_entries(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.ClusterControl)
}

::google::protobuf::uint8* ClusterControl::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.ClusterControl)
  // optional bool accept_new_entries = 1 [default = true];
  if (has_accept_new_entries()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->accept_new_entries(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.ClusterControl)
  return target;
}

int ClusterControl::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool accept_new_entries = 1 [default = true];
    if (has_accept_new_entries()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClusterControl::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClusterControl* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClusterControl*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClusterControl::MergeFrom(const ClusterControl& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_accept_new_entries()) {
      set_accept_new_entries(from.accept_new_entries());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClusterControl::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClusterControl::CopyFrom(const ClusterControl& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClusterControl::IsInitialized() const {

  return true;
}

void ClusterControl::Swap(ClusterControl* other) {
  if (other != this) {
    std::swap(accept_new_entries_, other->accept_new_entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClusterControl::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClusterControl_descriptor_;
  metadata.reflection = ClusterControl_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClusterConfig::kMinimumServingNodesFieldNumber;
const int ClusterConfig::kMinimumServingFractionFieldNumber;
const int ClusterConfig::kEtcdRejectAddPendingThresholdFieldNumber;
#endif  // !_MSC_VER

ClusterConfig::ClusterConfig()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.ClusterConfig)
}

void ClusterConfig::InitAsDefaultInstance() {
}

ClusterConfig::ClusterConfig(const ClusterConfig& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.ClusterConfig)
}

void ClusterConfig::SharedCtor() {
  _cached_size_ = 0;
  minimum_serving_nodes_ = 0;
  minimum_serving_fraction_ = 0;
  etcd_reject_add_pending_threshold_ = 30000;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClusterConfig::~ClusterConfig() {
  // @@protoc_insertion_point(destructor:ct.ClusterConfig)
  SharedDtor();
}

void ClusterConfig::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClusterConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClusterConfig::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClusterConfig_descriptor_;
}

const ClusterConfig& ClusterConfig::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

ClusterConfig* ClusterConfig::default_instance_ = NULL;

ClusterConfig* ClusterConfig::New() const {
  return new ClusterConfig;
}

void ClusterConfig::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    minimum_serving_nodes_ = 0;
    minimum_serving_fraction_ = 0;
    etcd_reject_add_pending_threshold_ = 30000;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClusterConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.ClusterConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 minimum_serving_nodes = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &minimum_serving_nodes_)));
          set_has_minimum_serving_nodes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_minimum_serving_fraction;
        break;
      }

      // optional double minimum_serving_fraction = 2;
      case 2: {
        if (tag == 17) {
         parse_minimum_serving_fraction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &minimum_serving_fraction_)));
          set_has_minimum_serving_fraction();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_etcd_reject_add_pending_threshold;
        break;
      }

      // optional double etcd_reject_add_pending_threshold = 3 [default = 30000];
      case 3: {
        if (tag == 25) {
         parse_etcd_reject_add_pending_threshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &etcd_reject_add_pending_threshold_)));
          set_has_etcd_reject_add_pending_threshold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.ClusterConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.ClusterConfig)
  return false;
#undef DO_
}

void ClusterConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.ClusterConfig)
  // optional int32 minimum_serving_nodes = 1;
  if (has_minimum_serving_nodes()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->minimum_serving_nodes(), output);
  }

  // optional double minimum_serving_fraction = 2;
  if (has_minimum_serving_fraction()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->minimum_serving_fraction(), output);
  }

  // optional double etcd_reject_add_pending_threshold = 3 [default = 30000];
  if (has_etcd_reject_add_pending_threshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->etcd_reject_add_pending_threshold(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.ClusterConfig)
}

::google::protobuf::uint8* ClusterConfig::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.ClusterConfig)
  // optional int32 minimum_serving_nodes = 1;
  if (has_minimum_serving_nodes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->minimum_serving_nodes(), target);
  }

  // optional double minimum_serving_fraction = 2;
  if (has_minimum_serving_fraction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->minimum_serving_fraction(), target);
  }

  // optional double etcd_reject_add_pending_threshold = 3 [default = 30000];
  if (has_etcd_reject_add_pending_threshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->etcd_reject_add_pending_threshold(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.ClusterConfig)
  return target;
}

int ClusterConfig::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 minimum_serving_nodes = 1;
    if (has_minimum_serving_nodes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->minimum_serving_nodes());
    }

    // optional double minimum_serving_fraction = 2;
    if (has_minimum_serving_fraction()) {
      total_size += 1 + 8;
    }

    // optional double etcd_reject_add_pending_threshold = 3 [default = 30000];
    if (has_etcd_reject_add_pending_threshold()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClusterConfig::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClusterConfig* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClusterConfig*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClusterConfig::MergeFrom(const ClusterConfig& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_minimum_serving_nodes()) {
      set_minimum_serving_nodes(from.minimum_serving_nodes());
    }
    if (from.has_minimum_serving_fraction()) {
      set_minimum_serving_fraction(from.minimum_serving_fraction());
    }
    if (from.has_etcd_reject_add_pending_threshold()) {
      set_etcd_reject_add_pending_threshold(from.etcd_reject_add_pending_threshold());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClusterConfig::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClusterConfig::CopyFrom(const ClusterConfig& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClusterConfig::IsInitialized() const {

  return true;
}

void ClusterConfig::Swap(ClusterConfig* other) {
  if (other != this) {
    std::swap(minimum_serving_nodes_, other->minimum_serving_nodes_);
    std::swap(minimum_serving_fraction_, other->minimum_serving_fraction_);
    std::swap(etcd_reject_add_pending_threshold_, other->etcd_reject_add_pending_threshold_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClusterConfig::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClusterConfig_descriptor_;
  metadata.reflection = ClusterConfig_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SequenceMapping_Mapping::kEntryHashFieldNumber;
const int SequenceMapping_Mapping::kSequenceNumberFieldNumber;
#endif  // !_MSC_VER

SequenceMapping_Mapping::SequenceMapping_Mapping()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.SequenceMapping.Mapping)
}

void SequenceMapping_Mapping::InitAsDefaultInstance() {
}

SequenceMapping_Mapping::SequenceMapping_Mapping(const SequenceMapping_Mapping& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.SequenceMapping.Mapping)
}

void SequenceMapping_Mapping::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  entry_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sequence_number_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SequenceMapping_Mapping::~SequenceMapping_Mapping() {
  // @@protoc_insertion_point(destructor:ct.SequenceMapping.Mapping)
  SharedDtor();
}

void SequenceMapping_Mapping::SharedDtor() {
  if (entry_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete entry_hash_;
  }
  if (this != default_instance_) {
  }
}

void SequenceMapping_Mapping::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SequenceMapping_Mapping::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SequenceMapping_Mapping_descriptor_;
}

const SequenceMapping_Mapping& SequenceMapping_Mapping::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

SequenceMapping_Mapping* SequenceMapping_Mapping::default_instance_ = NULL;

SequenceMapping_Mapping* SequenceMapping_Mapping::New() const {
  return new SequenceMapping_Mapping;
}

void SequenceMapping_Mapping::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_entry_hash()) {
      if (entry_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        entry_hash_->clear();
      }
    }
    sequence_number_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SequenceMapping_Mapping::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.SequenceMapping.Mapping)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes entry_hash = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_entry_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_sequence_number;
        break;
      }

      // optional int64 sequence_number = 2;
      case 2: {
        if (tag == 16) {
         parse_sequence_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &sequence_number_)));
          set_has_sequence_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.SequenceMapping.Mapping)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.SequenceMapping.Mapping)
  return false;
#undef DO_
}

void SequenceMapping_Mapping::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.SequenceMapping.Mapping)
  // optional bytes entry_hash = 1;
  if (has_entry_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->entry_hash(), output);
  }

  // optional int64 sequence_number = 2;
  if (has_sequence_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->sequence_number(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.SequenceMapping.Mapping)
}

::google::protobuf::uint8* SequenceMapping_Mapping::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.SequenceMapping.Mapping)
  // optional bytes entry_hash = 1;
  if (has_entry_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->entry_hash(), target);
  }

  // optional int64 sequence_number = 2;
  if (has_sequence_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->sequence_number(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.SequenceMapping.Mapping)
  return target;
}

int SequenceMapping_Mapping::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes entry_hash = 1;
    if (has_entry_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->entry_hash());
    }

    // optional int64 sequence_number = 2;
    if (has_sequence_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->sequence_number());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SequenceMapping_Mapping::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SequenceMapping_Mapping* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SequenceMapping_Mapping*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SequenceMapping_Mapping::MergeFrom(const SequenceMapping_Mapping& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_entry_hash()) {
      set_entry_hash(from.entry_hash());
    }
    if (from.has_sequence_number()) {
      set_sequence_number(from.sequence_number());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SequenceMapping_Mapping::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SequenceMapping_Mapping::CopyFrom(const SequenceMapping_Mapping& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SequenceMapping_Mapping::IsInitialized() const {

  return true;
}

void SequenceMapping_Mapping::Swap(SequenceMapping_Mapping* other) {
  if (other != this) {
    std::swap(entry_hash_, other->entry_hash_);
    std::swap(sequence_number_, other->sequence_number_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SequenceMapping_Mapping::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SequenceMapping_Mapping_descriptor_;
  metadata.reflection = SequenceMapping_Mapping_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SequenceMapping::kMappingFieldNumber;
#endif  // !_MSC_VER

SequenceMapping::SequenceMapping()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ct.SequenceMapping)
}

void SequenceMapping::InitAsDefaultInstance() {
}

SequenceMapping::SequenceMapping(const SequenceMapping& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ct.SequenceMapping)
}

void SequenceMapping::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SequenceMapping::~SequenceMapping() {
  // @@protoc_insertion_point(destructor:ct.SequenceMapping)
  SharedDtor();
}

void SequenceMapping::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SequenceMapping::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SequenceMapping::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SequenceMapping_descriptor_;
}

const SequenceMapping& SequenceMapping::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fct_2eproto();
  return *default_instance_;
}

SequenceMapping* SequenceMapping::default_instance_ = NULL;

SequenceMapping* SequenceMapping::New() const {
  return new SequenceMapping;
}

void SequenceMapping::Clear() {
  mapping_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SequenceMapping::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ct.SequenceMapping)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ct.SequenceMapping.Mapping mapping = 1;
      case 1: {
        if (tag == 10) {
         parse_mapping:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_mapping()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_mapping;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ct.SequenceMapping)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ct.SequenceMapping)
  return false;
#undef DO_
}

void SequenceMapping::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ct.SequenceMapping)
  // repeated .ct.SequenceMapping.Mapping mapping = 1;
  for (int i = 0; i < this->mapping_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->mapping(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ct.SequenceMapping)
}

::google::protobuf::uint8* SequenceMapping::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ct.SequenceMapping)
  // repeated .ct.SequenceMapping.Mapping mapping = 1;
  for (int i = 0; i < this->mapping_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->mapping(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ct.SequenceMapping)
  return target;
}

int SequenceMapping::ByteSize() const {
  int total_size = 0;

  // repeated .ct.SequenceMapping.Mapping mapping = 1;
  total_size += 1 * this->mapping_size();
  for (int i = 0; i < this->mapping_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->mapping(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SequenceMapping::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SequenceMapping* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SequenceMapping*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SequenceMapping::MergeFrom(const SequenceMapping& from) {
  GOOGLE_CHECK_NE(&from, this);
  mapping_.MergeFrom(from.mapping_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SequenceMapping::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SequenceMapping::CopyFrom(const SequenceMapping& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SequenceMapping::IsInitialized() const {

  return true;
}

void SequenceMapping::Swap(SequenceMapping* other) {
  if (other != this) {
    mapping_.Swap(&other->mapping_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SequenceMapping::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SequenceMapping_descriptor_;
  metadata.reflection = SequenceMapping_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ct

// @@protoc_insertion_point(global_scope)
