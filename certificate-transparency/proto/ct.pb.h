// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/ct.proto

#ifndef PROTOBUF_proto_2fct_2eproto__INCLUDED
#define PROTOBUF_proto_2fct_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ct {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_2fct_2eproto();
void protobuf_AssignDesc_proto_2fct_2eproto();
void protobuf_ShutdownFile_proto_2fct_2eproto();

class DigitallySigned;
class X509ChainEntry;
class PreCert;
class CertInfo;
class PrecertChainEntry;
class XJSONEntry;
class LogEntry;
class LogID;
class SctExtension;
class SignedCertificateTimestamp;
class SignedCertificateTimestampList;
class SignedEntry;
class TimestampedEntry;
class MerkleTreeLeaf;
class MerkleAuditProof;
class ShortMerkleAuditProof;
class LoggedEntryPB;
class LoggedEntryPB_Contents;
class SthExtension;
class SignedTreeHead;
class SSLClientCTData;
class SSLClientCTData_SCTInfo;
class ClusterNodeState;
class ClusterControl;
class ClusterConfig;
class SequenceMapping;
class SequenceMapping_Mapping;

enum DigitallySigned_HashAlgorithm {
  DigitallySigned_HashAlgorithm_NONE = 0,
  DigitallySigned_HashAlgorithm_MD5 = 1,
  DigitallySigned_HashAlgorithm_SHA1 = 2,
  DigitallySigned_HashAlgorithm_SHA224 = 3,
  DigitallySigned_HashAlgorithm_SHA256 = 4,
  DigitallySigned_HashAlgorithm_SHA384 = 5,
  DigitallySigned_HashAlgorithm_SHA512 = 6
};
bool DigitallySigned_HashAlgorithm_IsValid(int value);
const DigitallySigned_HashAlgorithm DigitallySigned_HashAlgorithm_HashAlgorithm_MIN = DigitallySigned_HashAlgorithm_NONE;
const DigitallySigned_HashAlgorithm DigitallySigned_HashAlgorithm_HashAlgorithm_MAX = DigitallySigned_HashAlgorithm_SHA512;
const int DigitallySigned_HashAlgorithm_HashAlgorithm_ARRAYSIZE = DigitallySigned_HashAlgorithm_HashAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* DigitallySigned_HashAlgorithm_descriptor();
inline const ::std::string& DigitallySigned_HashAlgorithm_Name(DigitallySigned_HashAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    DigitallySigned_HashAlgorithm_descriptor(), value);
}
inline bool DigitallySigned_HashAlgorithm_Parse(
    const ::std::string& name, DigitallySigned_HashAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DigitallySigned_HashAlgorithm>(
    DigitallySigned_HashAlgorithm_descriptor(), name, value);
}
enum DigitallySigned_SignatureAlgorithm {
  DigitallySigned_SignatureAlgorithm_ANONYMOUS = 0,
  DigitallySigned_SignatureAlgorithm_RSA = 1,
  DigitallySigned_SignatureAlgorithm_DSA = 2,
  DigitallySigned_SignatureAlgorithm_ECDSA = 3
};
bool DigitallySigned_SignatureAlgorithm_IsValid(int value);
const DigitallySigned_SignatureAlgorithm DigitallySigned_SignatureAlgorithm_SignatureAlgorithm_MIN = DigitallySigned_SignatureAlgorithm_ANONYMOUS;
const DigitallySigned_SignatureAlgorithm DigitallySigned_SignatureAlgorithm_SignatureAlgorithm_MAX = DigitallySigned_SignatureAlgorithm_ECDSA;
const int DigitallySigned_SignatureAlgorithm_SignatureAlgorithm_ARRAYSIZE = DigitallySigned_SignatureAlgorithm_SignatureAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* DigitallySigned_SignatureAlgorithm_descriptor();
inline const ::std::string& DigitallySigned_SignatureAlgorithm_Name(DigitallySigned_SignatureAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    DigitallySigned_SignatureAlgorithm_descriptor(), value);
}
inline bool DigitallySigned_SignatureAlgorithm_Parse(
    const ::std::string& name, DigitallySigned_SignatureAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DigitallySigned_SignatureAlgorithm>(
    DigitallySigned_SignatureAlgorithm_descriptor(), name, value);
}
enum LogEntryType {
  X509_ENTRY = 0,
  PRECERT_ENTRY = 1,
  PRECERT_ENTRY_V2 = 2,
  X_JSON_ENTRY = 32768,
  UNKNOWN_ENTRY_TYPE = 65536
};
bool LogEntryType_IsValid(int value);
const LogEntryType LogEntryType_MIN = X509_ENTRY;
const LogEntryType LogEntryType_MAX = UNKNOWN_ENTRY_TYPE;
const int LogEntryType_ARRAYSIZE = LogEntryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogEntryType_descriptor();
inline const ::std::string& LogEntryType_Name(LogEntryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogEntryType_descriptor(), value);
}
inline bool LogEntryType_Parse(
    const ::std::string& name, LogEntryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogEntryType>(
    LogEntryType_descriptor(), name, value);
}
enum SignatureType {
  CERTIFICATE_TIMESTAMP = 0,
  TREE_HEAD = 1
};
bool SignatureType_IsValid(int value);
const SignatureType SignatureType_MIN = CERTIFICATE_TIMESTAMP;
const SignatureType SignatureType_MAX = TREE_HEAD;
const int SignatureType_ARRAYSIZE = SignatureType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignatureType_descriptor();
inline const ::std::string& SignatureType_Name(SignatureType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignatureType_descriptor(), value);
}
inline bool SignatureType_Parse(
    const ::std::string& name, SignatureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignatureType>(
    SignatureType_descriptor(), name, value);
}
enum Version {
  V1 = 0,
  V2 = 1,
  UNKNOWN_VERSION = 256
};
bool Version_IsValid(int value);
const Version Version_MIN = V1;
const Version Version_MAX = UNKNOWN_VERSION;
const int Version_ARRAYSIZE = Version_MAX + 1;

const ::google::protobuf::EnumDescriptor* Version_descriptor();
inline const ::std::string& Version_Name(Version value) {
  return ::google::protobuf::internal::NameOfEnum(
    Version_descriptor(), value);
}
inline bool Version_Parse(
    const ::std::string& name, Version* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Version>(
    Version_descriptor(), name, value);
}
enum MerkleLeafType {
  TIMESTAMPED_ENTRY = 0,
  UNKNOWN_LEAF_TYPE = 256
};
bool MerkleLeafType_IsValid(int value);
const MerkleLeafType MerkleLeafType_MIN = TIMESTAMPED_ENTRY;
const MerkleLeafType MerkleLeafType_MAX = UNKNOWN_LEAF_TYPE;
const int MerkleLeafType_ARRAYSIZE = MerkleLeafType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MerkleLeafType_descriptor();
inline const ::std::string& MerkleLeafType_Name(MerkleLeafType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MerkleLeafType_descriptor(), value);
}
inline bool MerkleLeafType_Parse(
    const ::std::string& name, MerkleLeafType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MerkleLeafType>(
    MerkleLeafType_descriptor(), name, value);
}
// ===================================================================

class DigitallySigned : public ::google::protobuf::Message {
 public:
  DigitallySigned();
  virtual ~DigitallySigned();

  DigitallySigned(const DigitallySigned& from);

  inline DigitallySigned& operator=(const DigitallySigned& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DigitallySigned& default_instance();

  void Swap(DigitallySigned* other);

  // implements Message ----------------------------------------------

  DigitallySigned* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DigitallySigned& from);
  void MergeFrom(const DigitallySigned& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DigitallySigned_HashAlgorithm HashAlgorithm;
  static const HashAlgorithm NONE = DigitallySigned_HashAlgorithm_NONE;
  static const HashAlgorithm MD5 = DigitallySigned_HashAlgorithm_MD5;
  static const HashAlgorithm SHA1 = DigitallySigned_HashAlgorithm_SHA1;
  static const HashAlgorithm SHA224 = DigitallySigned_HashAlgorithm_SHA224;
  static const HashAlgorithm SHA256 = DigitallySigned_HashAlgorithm_SHA256;
  static const HashAlgorithm SHA384 = DigitallySigned_HashAlgorithm_SHA384;
  static const HashAlgorithm SHA512 = DigitallySigned_HashAlgorithm_SHA512;
  static inline bool HashAlgorithm_IsValid(int value) {
    return DigitallySigned_HashAlgorithm_IsValid(value);
  }
  static const HashAlgorithm HashAlgorithm_MIN =
    DigitallySigned_HashAlgorithm_HashAlgorithm_MIN;
  static const HashAlgorithm HashAlgorithm_MAX =
    DigitallySigned_HashAlgorithm_HashAlgorithm_MAX;
  static const int HashAlgorithm_ARRAYSIZE =
    DigitallySigned_HashAlgorithm_HashAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HashAlgorithm_descriptor() {
    return DigitallySigned_HashAlgorithm_descriptor();
  }
  static inline const ::std::string& HashAlgorithm_Name(HashAlgorithm value) {
    return DigitallySigned_HashAlgorithm_Name(value);
  }
  static inline bool HashAlgorithm_Parse(const ::std::string& name,
      HashAlgorithm* value) {
    return DigitallySigned_HashAlgorithm_Parse(name, value);
  }

  typedef DigitallySigned_SignatureAlgorithm SignatureAlgorithm;
  static const SignatureAlgorithm ANONYMOUS = DigitallySigned_SignatureAlgorithm_ANONYMOUS;
  static const SignatureAlgorithm RSA = DigitallySigned_SignatureAlgorithm_RSA;
  static const SignatureAlgorithm DSA = DigitallySigned_SignatureAlgorithm_DSA;
  static const SignatureAlgorithm ECDSA = DigitallySigned_SignatureAlgorithm_ECDSA;
  static inline bool SignatureAlgorithm_IsValid(int value) {
    return DigitallySigned_SignatureAlgorithm_IsValid(value);
  }
  static const SignatureAlgorithm SignatureAlgorithm_MIN =
    DigitallySigned_SignatureAlgorithm_SignatureAlgorithm_MIN;
  static const SignatureAlgorithm SignatureAlgorithm_MAX =
    DigitallySigned_SignatureAlgorithm_SignatureAlgorithm_MAX;
  static const int SignatureAlgorithm_ARRAYSIZE =
    DigitallySigned_SignatureAlgorithm_SignatureAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SignatureAlgorithm_descriptor() {
    return DigitallySigned_SignatureAlgorithm_descriptor();
  }
  static inline const ::std::string& SignatureAlgorithm_Name(SignatureAlgorithm value) {
    return DigitallySigned_SignatureAlgorithm_Name(value);
  }
  static inline bool SignatureAlgorithm_Parse(const ::std::string& name,
      SignatureAlgorithm* value) {
    return DigitallySigned_SignatureAlgorithm_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .ct.DigitallySigned.HashAlgorithm hash_algorithm = 1 [default = NONE];
  inline bool has_hash_algorithm() const;
  inline void clear_hash_algorithm();
  static const int kHashAlgorithmFieldNumber = 1;
  inline ::ct::DigitallySigned_HashAlgorithm hash_algorithm() const;
  inline void set_hash_algorithm(::ct::DigitallySigned_HashAlgorithm value);

  // optional .ct.DigitallySigned.SignatureAlgorithm sig_algorithm = 2 [default = ANONYMOUS];
  inline bool has_sig_algorithm() const;
  inline void clear_sig_algorithm();
  static const int kSigAlgorithmFieldNumber = 2;
  inline ::ct::DigitallySigned_SignatureAlgorithm sig_algorithm() const;
  inline void set_sig_algorithm(::ct::DigitallySigned_SignatureAlgorithm value);

  // optional bytes signature = 3;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 3;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:ct.DigitallySigned)
 private:
  inline void set_has_hash_algorithm();
  inline void clear_has_hash_algorithm();
  inline void set_has_sig_algorithm();
  inline void clear_has_sig_algorithm();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int hash_algorithm_;
  int sig_algorithm_;
  ::std::string* signature_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static DigitallySigned* default_instance_;
};
// -------------------------------------------------------------------

class X509ChainEntry : public ::google::protobuf::Message {
 public:
  X509ChainEntry();
  virtual ~X509ChainEntry();

  X509ChainEntry(const X509ChainEntry& from);

  inline X509ChainEntry& operator=(const X509ChainEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const X509ChainEntry& default_instance();

  void Swap(X509ChainEntry* other);

  // implements Message ----------------------------------------------

  X509ChainEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X509ChainEntry& from);
  void MergeFrom(const X509ChainEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes leaf_certificate = 1;
  inline bool has_leaf_certificate() const;
  inline void clear_leaf_certificate();
  static const int kLeafCertificateFieldNumber = 1;
  inline const ::std::string& leaf_certificate() const;
  inline void set_leaf_certificate(const ::std::string& value);
  inline void set_leaf_certificate(const char* value);
  inline void set_leaf_certificate(const void* value, size_t size);
  inline ::std::string* mutable_leaf_certificate();
  inline ::std::string* release_leaf_certificate();
  inline void set_allocated_leaf_certificate(::std::string* leaf_certificate);

  // optional .ct.CertInfo cert_info = 3;
  inline bool has_cert_info() const;
  inline void clear_cert_info();
  static const int kCertInfoFieldNumber = 3;
  inline const ::ct::CertInfo& cert_info() const;
  inline ::ct::CertInfo* mutable_cert_info();
  inline ::ct::CertInfo* release_cert_info();
  inline void set_allocated_cert_info(::ct::CertInfo* cert_info);

  // repeated bytes certificate_chain = 2;
  inline int certificate_chain_size() const;
  inline void clear_certificate_chain();
  static const int kCertificateChainFieldNumber = 2;
  inline const ::std::string& certificate_chain(int index) const;
  inline ::std::string* mutable_certificate_chain(int index);
  inline void set_certificate_chain(int index, const ::std::string& value);
  inline void set_certificate_chain(int index, const char* value);
  inline void set_certificate_chain(int index, const void* value, size_t size);
  inline ::std::string* add_certificate_chain();
  inline void add_certificate_chain(const ::std::string& value);
  inline void add_certificate_chain(const char* value);
  inline void add_certificate_chain(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& certificate_chain() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_certificate_chain();

  // @@protoc_insertion_point(class_scope:ct.X509ChainEntry)
 private:
  inline void set_has_leaf_certificate();
  inline void clear_has_leaf_certificate();
  inline void set_has_cert_info();
  inline void clear_has_cert_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* leaf_certificate_;
  ::ct::CertInfo* cert_info_;
  ::google::protobuf::RepeatedPtrField< ::std::string> certificate_chain_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static X509ChainEntry* default_instance_;
};
// -------------------------------------------------------------------

class PreCert : public ::google::protobuf::Message {
 public:
  PreCert();
  virtual ~PreCert();

  PreCert(const PreCert& from);

  inline PreCert& operator=(const PreCert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PreCert& default_instance();

  void Swap(PreCert* other);

  // implements Message ----------------------------------------------

  PreCert* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PreCert& from);
  void MergeFrom(const PreCert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes issuer_key_hash = 1;
  inline bool has_issuer_key_hash() const;
  inline void clear_issuer_key_hash();
  static const int kIssuerKeyHashFieldNumber = 1;
  inline const ::std::string& issuer_key_hash() const;
  inline void set_issuer_key_hash(const ::std::string& value);
  inline void set_issuer_key_hash(const char* value);
  inline void set_issuer_key_hash(const void* value, size_t size);
  inline ::std::string* mutable_issuer_key_hash();
  inline ::std::string* release_issuer_key_hash();
  inline void set_allocated_issuer_key_hash(::std::string* issuer_key_hash);

  // optional bytes tbs_certificate = 2;
  inline bool has_tbs_certificate() const;
  inline void clear_tbs_certificate();
  static const int kTbsCertificateFieldNumber = 2;
  inline const ::std::string& tbs_certificate() const;
  inline void set_tbs_certificate(const ::std::string& value);
  inline void set_tbs_certificate(const char* value);
  inline void set_tbs_certificate(const void* value, size_t size);
  inline ::std::string* mutable_tbs_certificate();
  inline ::std::string* release_tbs_certificate();
  inline void set_allocated_tbs_certificate(::std::string* tbs_certificate);

  // @@protoc_insertion_point(class_scope:ct.PreCert)
 private:
  inline void set_has_issuer_key_hash();
  inline void clear_has_issuer_key_hash();
  inline void set_has_tbs_certificate();
  inline void clear_has_tbs_certificate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* issuer_key_hash_;
  ::std::string* tbs_certificate_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static PreCert* default_instance_;
};
// -------------------------------------------------------------------

class CertInfo : public ::google::protobuf::Message {
 public:
  CertInfo();
  virtual ~CertInfo();

  CertInfo(const CertInfo& from);

  inline CertInfo& operator=(const CertInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CertInfo& default_instance();

  void Swap(CertInfo* other);

  // implements Message ----------------------------------------------

  CertInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CertInfo& from);
  void MergeFrom(const CertInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes issuer_key_hash = 1;
  inline bool has_issuer_key_hash() const;
  inline void clear_issuer_key_hash();
  static const int kIssuerKeyHashFieldNumber = 1;
  inline const ::std::string& issuer_key_hash() const;
  inline void set_issuer_key_hash(const ::std::string& value);
  inline void set_issuer_key_hash(const char* value);
  inline void set_issuer_key_hash(const void* value, size_t size);
  inline ::std::string* mutable_issuer_key_hash();
  inline ::std::string* release_issuer_key_hash();
  inline void set_allocated_issuer_key_hash(::std::string* issuer_key_hash);

  // optional bytes tbs_certificate = 2;
  inline bool has_tbs_certificate() const;
  inline void clear_tbs_certificate();
  static const int kTbsCertificateFieldNumber = 2;
  inline const ::std::string& tbs_certificate() const;
  inline void set_tbs_certificate(const ::std::string& value);
  inline void set_tbs_certificate(const char* value);
  inline void set_tbs_certificate(const void* value, size_t size);
  inline ::std::string* mutable_tbs_certificate();
  inline ::std::string* release_tbs_certificate();
  inline void set_allocated_tbs_certificate(::std::string* tbs_certificate);

  // @@protoc_insertion_point(class_scope:ct.CertInfo)
 private:
  inline void set_has_issuer_key_hash();
  inline void clear_has_issuer_key_hash();
  inline void set_has_tbs_certificate();
  inline void clear_has_tbs_certificate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* issuer_key_hash_;
  ::std::string* tbs_certificate_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static CertInfo* default_instance_;
};
// -------------------------------------------------------------------

class PrecertChainEntry : public ::google::protobuf::Message {
 public:
  PrecertChainEntry();
  virtual ~PrecertChainEntry();

  PrecertChainEntry(const PrecertChainEntry& from);

  inline PrecertChainEntry& operator=(const PrecertChainEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrecertChainEntry& default_instance();

  void Swap(PrecertChainEntry* other);

  // implements Message ----------------------------------------------

  PrecertChainEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrecertChainEntry& from);
  void MergeFrom(const PrecertChainEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes pre_certificate = 1;
  inline bool has_pre_certificate() const;
  inline void clear_pre_certificate();
  static const int kPreCertificateFieldNumber = 1;
  inline const ::std::string& pre_certificate() const;
  inline void set_pre_certificate(const ::std::string& value);
  inline void set_pre_certificate(const char* value);
  inline void set_pre_certificate(const void* value, size_t size);
  inline ::std::string* mutable_pre_certificate();
  inline ::std::string* release_pre_certificate();
  inline void set_allocated_pre_certificate(::std::string* pre_certificate);

  // repeated bytes precertificate_chain = 2;
  inline int precertificate_chain_size() const;
  inline void clear_precertificate_chain();
  static const int kPrecertificateChainFieldNumber = 2;
  inline const ::std::string& precertificate_chain(int index) const;
  inline ::std::string* mutable_precertificate_chain(int index);
  inline void set_precertificate_chain(int index, const ::std::string& value);
  inline void set_precertificate_chain(int index, const char* value);
  inline void set_precertificate_chain(int index, const void* value, size_t size);
  inline ::std::string* add_precertificate_chain();
  inline void add_precertificate_chain(const ::std::string& value);
  inline void add_precertificate_chain(const char* value);
  inline void add_precertificate_chain(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& precertificate_chain() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_precertificate_chain();

  // optional .ct.PreCert pre_cert = 3;
  inline bool has_pre_cert() const;
  inline void clear_pre_cert();
  static const int kPreCertFieldNumber = 3;
  inline const ::ct::PreCert& pre_cert() const;
  inline ::ct::PreCert* mutable_pre_cert();
  inline ::ct::PreCert* release_pre_cert();
  inline void set_allocated_pre_cert(::ct::PreCert* pre_cert);

  // optional .ct.CertInfo cert_info = 4;
  inline bool has_cert_info() const;
  inline void clear_cert_info();
  static const int kCertInfoFieldNumber = 4;
  inline const ::ct::CertInfo& cert_info() const;
  inline ::ct::CertInfo* mutable_cert_info();
  inline ::ct::CertInfo* release_cert_info();
  inline void set_allocated_cert_info(::ct::CertInfo* cert_info);

  // @@protoc_insertion_point(class_scope:ct.PrecertChainEntry)
 private:
  inline void set_has_pre_certificate();
  inline void clear_has_pre_certificate();
  inline void set_has_pre_cert();
  inline void clear_has_pre_cert();
  inline void set_has_cert_info();
  inline void clear_has_cert_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* pre_certificate_;
  ::google::protobuf::RepeatedPtrField< ::std::string> precertificate_chain_;
  ::ct::PreCert* pre_cert_;
  ::ct::CertInfo* cert_info_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static PrecertChainEntry* default_instance_;
};
// -------------------------------------------------------------------

class XJSONEntry : public ::google::protobuf::Message {
 public:
  XJSONEntry();
  virtual ~XJSONEntry();

  XJSONEntry(const XJSONEntry& from);

  inline XJSONEntry& operator=(const XJSONEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const XJSONEntry& default_instance();

  void Swap(XJSONEntry* other);

  // implements Message ----------------------------------------------

  XJSONEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XJSONEntry& from);
  void MergeFrom(const XJSONEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string json = 1;
  inline bool has_json() const;
  inline void clear_json();
  static const int kJsonFieldNumber = 1;
  inline const ::std::string& json() const;
  inline void set_json(const ::std::string& value);
  inline void set_json(const char* value);
  inline void set_json(const char* value, size_t size);
  inline ::std::string* mutable_json();
  inline ::std::string* release_json();
  inline void set_allocated_json(::std::string* json);

  // @@protoc_insertion_point(class_scope:ct.XJSONEntry)
 private:
  inline void set_has_json();
  inline void clear_has_json();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* json_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static XJSONEntry* default_instance_;
};
// -------------------------------------------------------------------

class LogEntry : public ::google::protobuf::Message {
 public:
  LogEntry();
  virtual ~LogEntry();

  LogEntry(const LogEntry& from);

  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogEntry& default_instance();

  void Swap(LogEntry* other);

  // implements Message ----------------------------------------------

  LogEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogEntry& from);
  void MergeFrom(const LogEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ct.LogEntryType type = 1 [default = UNKNOWN_ENTRY_TYPE];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::ct::LogEntryType type() const;
  inline void set_type(::ct::LogEntryType value);

  // optional .ct.X509ChainEntry x509_entry = 2;
  inline bool has_x509_entry() const;
  inline void clear_x509_entry();
  static const int kX509EntryFieldNumber = 2;
  inline const ::ct::X509ChainEntry& x509_entry() const;
  inline ::ct::X509ChainEntry* mutable_x509_entry();
  inline ::ct::X509ChainEntry* release_x509_entry();
  inline void set_allocated_x509_entry(::ct::X509ChainEntry* x509_entry);

  // optional .ct.PrecertChainEntry precert_entry = 3;
  inline bool has_precert_entry() const;
  inline void clear_precert_entry();
  static const int kPrecertEntryFieldNumber = 3;
  inline const ::ct::PrecertChainEntry& precert_entry() const;
  inline ::ct::PrecertChainEntry* mutable_precert_entry();
  inline ::ct::PrecertChainEntry* release_precert_entry();
  inline void set_allocated_precert_entry(::ct::PrecertChainEntry* precert_entry);

  // optional .ct.XJSONEntry x_json_entry = 4;
  inline bool has_x_json_entry() const;
  inline void clear_x_json_entry();
  static const int kXJsonEntryFieldNumber = 4;
  inline const ::ct::XJSONEntry& x_json_entry() const;
  inline ::ct::XJSONEntry* mutable_x_json_entry();
  inline ::ct::XJSONEntry* release_x_json_entry();
  inline void set_allocated_x_json_entry(::ct::XJSONEntry* x_json_entry);

  // @@protoc_insertion_point(class_scope:ct.LogEntry)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_x509_entry();
  inline void clear_has_x509_entry();
  inline void set_has_precert_entry();
  inline void clear_has_precert_entry();
  inline void set_has_x_json_entry();
  inline void clear_has_x_json_entry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ct::X509ChainEntry* x509_entry_;
  ::ct::PrecertChainEntry* precert_entry_;
  ::ct::XJSONEntry* x_json_entry_;
  int type_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static LogEntry* default_instance_;
};
// -------------------------------------------------------------------

class LogID : public ::google::protobuf::Message {
 public:
  LogID();
  virtual ~LogID();

  LogID(const LogID& from);

  inline LogID& operator=(const LogID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogID& default_instance();

  void Swap(LogID* other);

  // implements Message ----------------------------------------------

  LogID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogID& from);
  void MergeFrom(const LogID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key_id = 1;
  inline bool has_key_id() const;
  inline void clear_key_id();
  static const int kKeyIdFieldNumber = 1;
  inline const ::std::string& key_id() const;
  inline void set_key_id(const ::std::string& value);
  inline void set_key_id(const char* value);
  inline void set_key_id(const void* value, size_t size);
  inline ::std::string* mutable_key_id();
  inline ::std::string* release_key_id();
  inline void set_allocated_key_id(::std::string* key_id);

  // @@protoc_insertion_point(class_scope:ct.LogID)
 private:
  inline void set_has_key_id();
  inline void clear_has_key_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_id_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static LogID* default_instance_;
};
// -------------------------------------------------------------------

class SctExtension : public ::google::protobuf::Message {
 public:
  SctExtension();
  virtual ~SctExtension();

  SctExtension(const SctExtension& from);

  inline SctExtension& operator=(const SctExtension& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SctExtension& default_instance();

  void Swap(SctExtension* other);

  // implements Message ----------------------------------------------

  SctExtension* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SctExtension& from);
  void MergeFrom(const SctExtension& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sct_extension_type = 1;
  inline bool has_sct_extension_type() const;
  inline void clear_sct_extension_type();
  static const int kSctExtensionTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 sct_extension_type() const;
  inline void set_sct_extension_type(::google::protobuf::uint32 value);

  // optional bytes sct_extension_data = 2;
  inline bool has_sct_extension_data() const;
  inline void clear_sct_extension_data();
  static const int kSctExtensionDataFieldNumber = 2;
  inline const ::std::string& sct_extension_data() const;
  inline void set_sct_extension_data(const ::std::string& value);
  inline void set_sct_extension_data(const char* value);
  inline void set_sct_extension_data(const void* value, size_t size);
  inline ::std::string* mutable_sct_extension_data();
  inline ::std::string* release_sct_extension_data();
  inline void set_allocated_sct_extension_data(::std::string* sct_extension_data);

  // @@protoc_insertion_point(class_scope:ct.SctExtension)
 private:
  inline void set_has_sct_extension_type();
  inline void clear_has_sct_extension_type();
  inline void set_has_sct_extension_data();
  inline void clear_has_sct_extension_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sct_extension_data_;
  ::google::protobuf::uint32 sct_extension_type_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static SctExtension* default_instance_;
};
// -------------------------------------------------------------------

class SignedCertificateTimestamp : public ::google::protobuf::Message {
 public:
  SignedCertificateTimestamp();
  virtual ~SignedCertificateTimestamp();

  SignedCertificateTimestamp(const SignedCertificateTimestamp& from);

  inline SignedCertificateTimestamp& operator=(const SignedCertificateTimestamp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedCertificateTimestamp& default_instance();

  void Swap(SignedCertificateTimestamp* other);

  // implements Message ----------------------------------------------

  SignedCertificateTimestamp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedCertificateTimestamp& from);
  void MergeFrom(const SignedCertificateTimestamp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::ct::Version version() const;
  inline void set_version(::ct::Version value);

  // optional .ct.LogID id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::ct::LogID& id() const;
  inline ::ct::LogID* mutable_id();
  inline ::ct::LogID* release_id();
  inline void set_allocated_id(::ct::LogID* id);

  // optional uint64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional .ct.DigitallySigned signature = 4;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 4;
  inline const ::ct::DigitallySigned& signature() const;
  inline ::ct::DigitallySigned* mutable_signature();
  inline ::ct::DigitallySigned* release_signature();
  inline void set_allocated_signature(::ct::DigitallySigned* signature);

  // optional bytes extensions = 5;
  inline bool has_extensions() const;
  inline void clear_extensions();
  static const int kExtensionsFieldNumber = 5;
  inline const ::std::string& extensions() const;
  inline void set_extensions(const ::std::string& value);
  inline void set_extensions(const char* value);
  inline void set_extensions(const void* value, size_t size);
  inline ::std::string* mutable_extensions();
  inline ::std::string* release_extensions();
  inline void set_allocated_extensions(::std::string* extensions);

  // repeated .ct.SctExtension sct_extension = 6;
  inline int sct_extension_size() const;
  inline void clear_sct_extension();
  static const int kSctExtensionFieldNumber = 6;
  inline const ::ct::SctExtension& sct_extension(int index) const;
  inline ::ct::SctExtension* mutable_sct_extension(int index);
  inline ::ct::SctExtension* add_sct_extension();
  inline const ::google::protobuf::RepeatedPtrField< ::ct::SctExtension >&
      sct_extension() const;
  inline ::google::protobuf::RepeatedPtrField< ::ct::SctExtension >*
      mutable_sct_extension();

  // @@protoc_insertion_point(class_scope:ct.SignedCertificateTimestamp)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_extensions();
  inline void clear_has_extensions();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ct::LogID* id_;
  ::google::protobuf::uint64 timestamp_;
  ::ct::DigitallySigned* signature_;
  ::std::string* extensions_;
  ::google::protobuf::RepeatedPtrField< ::ct::SctExtension > sct_extension_;
  int version_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static SignedCertificateTimestamp* default_instance_;
};
// -------------------------------------------------------------------

class SignedCertificateTimestampList : public ::google::protobuf::Message {
 public:
  SignedCertificateTimestampList();
  virtual ~SignedCertificateTimestampList();

  SignedCertificateTimestampList(const SignedCertificateTimestampList& from);

  inline SignedCertificateTimestampList& operator=(const SignedCertificateTimestampList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedCertificateTimestampList& default_instance();

  void Swap(SignedCertificateTimestampList* other);

  // implements Message ----------------------------------------------

  SignedCertificateTimestampList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedCertificateTimestampList& from);
  void MergeFrom(const SignedCertificateTimestampList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes sct_list = 1;
  inline int sct_list_size() const;
  inline void clear_sct_list();
  static const int kSctListFieldNumber = 1;
  inline const ::std::string& sct_list(int index) const;
  inline ::std::string* mutable_sct_list(int index);
  inline void set_sct_list(int index, const ::std::string& value);
  inline void set_sct_list(int index, const char* value);
  inline void set_sct_list(int index, const void* value, size_t size);
  inline ::std::string* add_sct_list();
  inline void add_sct_list(const ::std::string& value);
  inline void add_sct_list(const char* value);
  inline void add_sct_list(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& sct_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sct_list();

  // @@protoc_insertion_point(class_scope:ct.SignedCertificateTimestampList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sct_list_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static SignedCertificateTimestampList* default_instance_;
};
// -------------------------------------------------------------------

class SignedEntry : public ::google::protobuf::Message {
 public:
  SignedEntry();
  virtual ~SignedEntry();

  SignedEntry(const SignedEntry& from);

  inline SignedEntry& operator=(const SignedEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedEntry& default_instance();

  void Swap(SignedEntry* other);

  // implements Message ----------------------------------------------

  SignedEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedEntry& from);
  void MergeFrom(const SignedEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes x509 = 1;
  inline bool has_x509() const;
  inline void clear_x509();
  static const int kX509FieldNumber = 1;
  inline const ::std::string& x509() const;
  inline void set_x509(const ::std::string& value);
  inline void set_x509(const char* value);
  inline void set_x509(const void* value, size_t size);
  inline ::std::string* mutable_x509();
  inline ::std::string* release_x509();
  inline void set_allocated_x509(::std::string* x509);

  // optional .ct.PreCert precert = 2;
  inline bool has_precert() const;
  inline void clear_precert();
  static const int kPrecertFieldNumber = 2;
  inline const ::ct::PreCert& precert() const;
  inline ::ct::PreCert* mutable_precert();
  inline ::ct::PreCert* release_precert();
  inline void set_allocated_precert(::ct::PreCert* precert);

  // optional bytes json = 3;
  inline bool has_json() const;
  inline void clear_json();
  static const int kJsonFieldNumber = 3;
  inline const ::std::string& json() const;
  inline void set_json(const ::std::string& value);
  inline void set_json(const char* value);
  inline void set_json(const void* value, size_t size);
  inline ::std::string* mutable_json();
  inline ::std::string* release_json();
  inline void set_allocated_json(::std::string* json);

  // optional .ct.CertInfo cert_info = 4;
  inline bool has_cert_info() const;
  inline void clear_cert_info();
  static const int kCertInfoFieldNumber = 4;
  inline const ::ct::CertInfo& cert_info() const;
  inline ::ct::CertInfo* mutable_cert_info();
  inline ::ct::CertInfo* release_cert_info();
  inline void set_allocated_cert_info(::ct::CertInfo* cert_info);

  // @@protoc_insertion_point(class_scope:ct.SignedEntry)
 private:
  inline void set_has_x509();
  inline void clear_has_x509();
  inline void set_has_precert();
  inline void clear_has_precert();
  inline void set_has_json();
  inline void clear_has_json();
  inline void set_has_cert_info();
  inline void clear_has_cert_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* x509_;
  ::ct::PreCert* precert_;
  ::std::string* json_;
  ::ct::CertInfo* cert_info_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static SignedEntry* default_instance_;
};
// -------------------------------------------------------------------

class TimestampedEntry : public ::google::protobuf::Message {
 public:
  TimestampedEntry();
  virtual ~TimestampedEntry();

  TimestampedEntry(const TimestampedEntry& from);

  inline TimestampedEntry& operator=(const TimestampedEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimestampedEntry& default_instance();

  void Swap(TimestampedEntry* other);

  // implements Message ----------------------------------------------

  TimestampedEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimestampedEntry& from);
  void MergeFrom(const TimestampedEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional .ct.LogEntryType entry_type = 2;
  inline bool has_entry_type() const;
  inline void clear_entry_type();
  static const int kEntryTypeFieldNumber = 2;
  inline ::ct::LogEntryType entry_type() const;
  inline void set_entry_type(::ct::LogEntryType value);

  // optional .ct.SignedEntry signed_entry = 3;
  inline bool has_signed_entry() const;
  inline void clear_signed_entry();
  static const int kSignedEntryFieldNumber = 3;
  inline const ::ct::SignedEntry& signed_entry() const;
  inline ::ct::SignedEntry* mutable_signed_entry();
  inline ::ct::SignedEntry* release_signed_entry();
  inline void set_allocated_signed_entry(::ct::SignedEntry* signed_entry);

  // optional bytes extensions = 4;
  inline bool has_extensions() const;
  inline void clear_extensions();
  static const int kExtensionsFieldNumber = 4;
  inline const ::std::string& extensions() const;
  inline void set_extensions(const ::std::string& value);
  inline void set_extensions(const char* value);
  inline void set_extensions(const void* value, size_t size);
  inline ::std::string* mutable_extensions();
  inline ::std::string* release_extensions();
  inline void set_allocated_extensions(::std::string* extensions);

  // repeated .ct.SctExtension sct_extension = 5;
  inline int sct_extension_size() const;
  inline void clear_sct_extension();
  static const int kSctExtensionFieldNumber = 5;
  inline const ::ct::SctExtension& sct_extension(int index) const;
  inline ::ct::SctExtension* mutable_sct_extension(int index);
  inline ::ct::SctExtension* add_sct_extension();
  inline const ::google::protobuf::RepeatedPtrField< ::ct::SctExtension >&
      sct_extension() const;
  inline ::google::protobuf::RepeatedPtrField< ::ct::SctExtension >*
      mutable_sct_extension();

  // @@protoc_insertion_point(class_scope:ct.TimestampedEntry)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_entry_type();
  inline void clear_has_entry_type();
  inline void set_has_signed_entry();
  inline void clear_has_signed_entry();
  inline void set_has_extensions();
  inline void clear_has_extensions();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::ct::SignedEntry* signed_entry_;
  ::std::string* extensions_;
  ::google::protobuf::RepeatedPtrField< ::ct::SctExtension > sct_extension_;
  int entry_type_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static TimestampedEntry* default_instance_;
};
// -------------------------------------------------------------------

class MerkleTreeLeaf : public ::google::protobuf::Message {
 public:
  MerkleTreeLeaf();
  virtual ~MerkleTreeLeaf();

  MerkleTreeLeaf(const MerkleTreeLeaf& from);

  inline MerkleTreeLeaf& operator=(const MerkleTreeLeaf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MerkleTreeLeaf& default_instance();

  void Swap(MerkleTreeLeaf* other);

  // implements Message ----------------------------------------------

  MerkleTreeLeaf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MerkleTreeLeaf& from);
  void MergeFrom(const MerkleTreeLeaf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::ct::Version version() const;
  inline void set_version(::ct::Version value);

  // optional .ct.MerkleLeafType type = 2 [default = UNKNOWN_LEAF_TYPE];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::ct::MerkleLeafType type() const;
  inline void set_type(::ct::MerkleLeafType value);

  // optional .ct.TimestampedEntry timestamped_entry = 3;
  inline bool has_timestamped_entry() const;
  inline void clear_timestamped_entry();
  static const int kTimestampedEntryFieldNumber = 3;
  inline const ::ct::TimestampedEntry& timestamped_entry() const;
  inline ::ct::TimestampedEntry* mutable_timestamped_entry();
  inline ::ct::TimestampedEntry* release_timestamped_entry();
  inline void set_allocated_timestamped_entry(::ct::TimestampedEntry* timestamped_entry);

  // @@protoc_insertion_point(class_scope:ct.MerkleTreeLeaf)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_timestamped_entry();
  inline void clear_has_timestamped_entry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int version_;
  int type_;
  ::ct::TimestampedEntry* timestamped_entry_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static MerkleTreeLeaf* default_instance_;
};
// -------------------------------------------------------------------

class MerkleAuditProof : public ::google::protobuf::Message {
 public:
  MerkleAuditProof();
  virtual ~MerkleAuditProof();

  MerkleAuditProof(const MerkleAuditProof& from);

  inline MerkleAuditProof& operator=(const MerkleAuditProof& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MerkleAuditProof& default_instance();

  void Swap(MerkleAuditProof* other);

  // implements Message ----------------------------------------------

  MerkleAuditProof* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MerkleAuditProof& from);
  void MergeFrom(const MerkleAuditProof& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::ct::Version version() const;
  inline void set_version(::ct::Version value);

  // optional .ct.LogID id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::ct::LogID& id() const;
  inline ::ct::LogID* mutable_id();
  inline ::ct::LogID* release_id();
  inline void set_allocated_id(::ct::LogID* id);

  // optional int64 tree_size = 3;
  inline bool has_tree_size() const;
  inline void clear_tree_size();
  static const int kTreeSizeFieldNumber = 3;
  inline ::google::protobuf::int64 tree_size() const;
  inline void set_tree_size(::google::protobuf::int64 value);

  // optional uint64 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional int64 leaf_index = 5;
  inline bool has_leaf_index() const;
  inline void clear_leaf_index();
  static const int kLeafIndexFieldNumber = 5;
  inline ::google::protobuf::int64 leaf_index() const;
  inline void set_leaf_index(::google::protobuf::int64 value);

  // repeated bytes path_node = 6;
  inline int path_node_size() const;
  inline void clear_path_node();
  static const int kPathNodeFieldNumber = 6;
  inline const ::std::string& path_node(int index) const;
  inline ::std::string* mutable_path_node(int index);
  inline void set_path_node(int index, const ::std::string& value);
  inline void set_path_node(int index, const char* value);
  inline void set_path_node(int index, const void* value, size_t size);
  inline ::std::string* add_path_node();
  inline void add_path_node(const ::std::string& value);
  inline void add_path_node(const char* value);
  inline void add_path_node(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& path_node() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_path_node();

  // optional .ct.DigitallySigned tree_head_signature = 7;
  inline bool has_tree_head_signature() const;
  inline void clear_tree_head_signature();
  static const int kTreeHeadSignatureFieldNumber = 7;
  inline const ::ct::DigitallySigned& tree_head_signature() const;
  inline ::ct::DigitallySigned* mutable_tree_head_signature();
  inline ::ct::DigitallySigned* release_tree_head_signature();
  inline void set_allocated_tree_head_signature(::ct::DigitallySigned* tree_head_signature);

  // @@protoc_insertion_point(class_scope:ct.MerkleAuditProof)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_tree_size();
  inline void clear_has_tree_size();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_leaf_index();
  inline void clear_has_leaf_index();
  inline void set_has_tree_head_signature();
  inline void clear_has_tree_head_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ct::LogID* id_;
  ::google::protobuf::int64 tree_size_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::int64 leaf_index_;
  ::google::protobuf::RepeatedPtrField< ::std::string> path_node_;
  ::ct::DigitallySigned* tree_head_signature_;
  int version_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static MerkleAuditProof* default_instance_;
};
// -------------------------------------------------------------------

class ShortMerkleAuditProof : public ::google::protobuf::Message {
 public:
  ShortMerkleAuditProof();
  virtual ~ShortMerkleAuditProof();

  ShortMerkleAuditProof(const ShortMerkleAuditProof& from);

  inline ShortMerkleAuditProof& operator=(const ShortMerkleAuditProof& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShortMerkleAuditProof& default_instance();

  void Swap(ShortMerkleAuditProof* other);

  // implements Message ----------------------------------------------

  ShortMerkleAuditProof* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShortMerkleAuditProof& from);
  void MergeFrom(const ShortMerkleAuditProof& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 leaf_index = 1;
  inline bool has_leaf_index() const;
  inline void clear_leaf_index();
  static const int kLeafIndexFieldNumber = 1;
  inline ::google::protobuf::int64 leaf_index() const;
  inline void set_leaf_index(::google::protobuf::int64 value);

  // repeated bytes path_node = 2;
  inline int path_node_size() const;
  inline void clear_path_node();
  static const int kPathNodeFieldNumber = 2;
  inline const ::std::string& path_node(int index) const;
  inline ::std::string* mutable_path_node(int index);
  inline void set_path_node(int index, const ::std::string& value);
  inline void set_path_node(int index, const char* value);
  inline void set_path_node(int index, const void* value, size_t size);
  inline ::std::string* add_path_node();
  inline void add_path_node(const ::std::string& value);
  inline void add_path_node(const char* value);
  inline void add_path_node(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& path_node() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_path_node();

  // @@protoc_insertion_point(class_scope:ct.ShortMerkleAuditProof)
 private:
  inline void set_has_leaf_index();
  inline void clear_has_leaf_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 leaf_index_;
  ::google::protobuf::RepeatedPtrField< ::std::string> path_node_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static ShortMerkleAuditProof* default_instance_;
};
// -------------------------------------------------------------------

class LoggedEntryPB_Contents : public ::google::protobuf::Message {
 public:
  LoggedEntryPB_Contents();
  virtual ~LoggedEntryPB_Contents();

  LoggedEntryPB_Contents(const LoggedEntryPB_Contents& from);

  inline LoggedEntryPB_Contents& operator=(const LoggedEntryPB_Contents& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoggedEntryPB_Contents& default_instance();

  void Swap(LoggedEntryPB_Contents* other);

  // implements Message ----------------------------------------------

  LoggedEntryPB_Contents* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoggedEntryPB_Contents& from);
  void MergeFrom(const LoggedEntryPB_Contents& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ct.SignedCertificateTimestamp sct = 1;
  inline bool has_sct() const;
  inline void clear_sct();
  static const int kSctFieldNumber = 1;
  inline const ::ct::SignedCertificateTimestamp& sct() const;
  inline ::ct::SignedCertificateTimestamp* mutable_sct();
  inline ::ct::SignedCertificateTimestamp* release_sct();
  inline void set_allocated_sct(::ct::SignedCertificateTimestamp* sct);

  // optional .ct.LogEntry entry = 2;
  inline bool has_entry() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 2;
  inline const ::ct::LogEntry& entry() const;
  inline ::ct::LogEntry* mutable_entry();
  inline ::ct::LogEntry* release_entry();
  inline void set_allocated_entry(::ct::LogEntry* entry);

  // @@protoc_insertion_point(class_scope:ct.LoggedEntryPB.Contents)
 private:
  inline void set_has_sct();
  inline void clear_has_sct();
  inline void set_has_entry();
  inline void clear_has_entry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ct::SignedCertificateTimestamp* sct_;
  ::ct::LogEntry* entry_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static LoggedEntryPB_Contents* default_instance_;
};
// -------------------------------------------------------------------

class LoggedEntryPB : public ::google::protobuf::Message {
 public:
  LoggedEntryPB();
  virtual ~LoggedEntryPB();

  LoggedEntryPB(const LoggedEntryPB& from);

  inline LoggedEntryPB& operator=(const LoggedEntryPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoggedEntryPB& default_instance();

  void Swap(LoggedEntryPB* other);

  // implements Message ----------------------------------------------

  LoggedEntryPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoggedEntryPB& from);
  void MergeFrom(const LoggedEntryPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LoggedEntryPB_Contents Contents;

  // accessors -------------------------------------------------------

  // optional int64 sequence_number = 1;
  inline bool has_sequence_number() const;
  inline void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  inline ::google::protobuf::int64 sequence_number() const;
  inline void set_sequence_number(::google::protobuf::int64 value);

  // optional bytes merkle_leaf_hash = 2;
  inline bool has_merkle_leaf_hash() const;
  inline void clear_merkle_leaf_hash();
  static const int kMerkleLeafHashFieldNumber = 2;
  inline const ::std::string& merkle_leaf_hash() const;
  inline void set_merkle_leaf_hash(const ::std::string& value);
  inline void set_merkle_leaf_hash(const char* value);
  inline void set_merkle_leaf_hash(const void* value, size_t size);
  inline ::std::string* mutable_merkle_leaf_hash();
  inline ::std::string* release_merkle_leaf_hash();
  inline void set_allocated_merkle_leaf_hash(::std::string* merkle_leaf_hash);

  // required .ct.LoggedEntryPB.Contents contents = 3;
  inline bool has_contents() const;
  inline void clear_contents();
  static const int kContentsFieldNumber = 3;
  inline const ::ct::LoggedEntryPB_Contents& contents() const;
  inline ::ct::LoggedEntryPB_Contents* mutable_contents();
  inline ::ct::LoggedEntryPB_Contents* release_contents();
  inline void set_allocated_contents(::ct::LoggedEntryPB_Contents* contents);

  // @@protoc_insertion_point(class_scope:ct.LoggedEntryPB)
 private:
  inline void set_has_sequence_number();
  inline void clear_has_sequence_number();
  inline void set_has_merkle_leaf_hash();
  inline void clear_has_merkle_leaf_hash();
  inline void set_has_contents();
  inline void clear_has_contents();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 sequence_number_;
  ::std::string* merkle_leaf_hash_;
  ::ct::LoggedEntryPB_Contents* contents_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static LoggedEntryPB* default_instance_;
};
// -------------------------------------------------------------------

class SthExtension : public ::google::protobuf::Message {
 public:
  SthExtension();
  virtual ~SthExtension();

  SthExtension(const SthExtension& from);

  inline SthExtension& operator=(const SthExtension& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SthExtension& default_instance();

  void Swap(SthExtension* other);

  // implements Message ----------------------------------------------

  SthExtension* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SthExtension& from);
  void MergeFrom(const SthExtension& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sth_extension_type = 1;
  inline bool has_sth_extension_type() const;
  inline void clear_sth_extension_type();
  static const int kSthExtensionTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 sth_extension_type() const;
  inline void set_sth_extension_type(::google::protobuf::uint32 value);

  // optional bytes sth_extension_data = 2;
  inline bool has_sth_extension_data() const;
  inline void clear_sth_extension_data();
  static const int kSthExtensionDataFieldNumber = 2;
  inline const ::std::string& sth_extension_data() const;
  inline void set_sth_extension_data(const ::std::string& value);
  inline void set_sth_extension_data(const char* value);
  inline void set_sth_extension_data(const void* value, size_t size);
  inline ::std::string* mutable_sth_extension_data();
  inline ::std::string* release_sth_extension_data();
  inline void set_allocated_sth_extension_data(::std::string* sth_extension_data);

  // @@protoc_insertion_point(class_scope:ct.SthExtension)
 private:
  inline void set_has_sth_extension_type();
  inline void clear_has_sth_extension_type();
  inline void set_has_sth_extension_data();
  inline void clear_has_sth_extension_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sth_extension_data_;
  ::google::protobuf::uint32 sth_extension_type_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static SthExtension* default_instance_;
};
// -------------------------------------------------------------------

class SignedTreeHead : public ::google::protobuf::Message {
 public:
  SignedTreeHead();
  virtual ~SignedTreeHead();

  SignedTreeHead(const SignedTreeHead& from);

  inline SignedTreeHead& operator=(const SignedTreeHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedTreeHead& default_instance();

  void Swap(SignedTreeHead* other);

  // implements Message ----------------------------------------------

  SignedTreeHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedTreeHead& from);
  void MergeFrom(const SignedTreeHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::ct::Version version() const;
  inline void set_version(::ct::Version value);

  // optional .ct.LogID id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::ct::LogID& id() const;
  inline ::ct::LogID* mutable_id();
  inline ::ct::LogID* release_id();
  inline void set_allocated_id(::ct::LogID* id);

  // optional uint64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional int64 tree_size = 4;
  inline bool has_tree_size() const;
  inline void clear_tree_size();
  static const int kTreeSizeFieldNumber = 4;
  inline ::google::protobuf::int64 tree_size() const;
  inline void set_tree_size(::google::protobuf::int64 value);

  // optional bytes sha256_root_hash = 5;
  inline bool has_sha256_root_hash() const;
  inline void clear_sha256_root_hash();
  static const int kSha256RootHashFieldNumber = 5;
  inline const ::std::string& sha256_root_hash() const;
  inline void set_sha256_root_hash(const ::std::string& value);
  inline void set_sha256_root_hash(const char* value);
  inline void set_sha256_root_hash(const void* value, size_t size);
  inline ::std::string* mutable_sha256_root_hash();
  inline ::std::string* release_sha256_root_hash();
  inline void set_allocated_sha256_root_hash(::std::string* sha256_root_hash);

  // optional .ct.DigitallySigned signature = 6;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 6;
  inline const ::ct::DigitallySigned& signature() const;
  inline ::ct::DigitallySigned* mutable_signature();
  inline ::ct::DigitallySigned* release_signature();
  inline void set_allocated_signature(::ct::DigitallySigned* signature);

  // repeated .ct.SthExtension sth_extension = 7;
  inline int sth_extension_size() const;
  inline void clear_sth_extension();
  static const int kSthExtensionFieldNumber = 7;
  inline const ::ct::SthExtension& sth_extension(int index) const;
  inline ::ct::SthExtension* mutable_sth_extension(int index);
  inline ::ct::SthExtension* add_sth_extension();
  inline const ::google::protobuf::RepeatedPtrField< ::ct::SthExtension >&
      sth_extension() const;
  inline ::google::protobuf::RepeatedPtrField< ::ct::SthExtension >*
      mutable_sth_extension();

  // @@protoc_insertion_point(class_scope:ct.SignedTreeHead)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_tree_size();
  inline void clear_has_tree_size();
  inline void set_has_sha256_root_hash();
  inline void clear_has_sha256_root_hash();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ct::LogID* id_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::int64 tree_size_;
  ::std::string* sha256_root_hash_;
  ::ct::DigitallySigned* signature_;
  ::google::protobuf::RepeatedPtrField< ::ct::SthExtension > sth_extension_;
  int version_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static SignedTreeHead* default_instance_;
};
// -------------------------------------------------------------------

class SSLClientCTData_SCTInfo : public ::google::protobuf::Message {
 public:
  SSLClientCTData_SCTInfo();
  virtual ~SSLClientCTData_SCTInfo();

  SSLClientCTData_SCTInfo(const SSLClientCTData_SCTInfo& from);

  inline SSLClientCTData_SCTInfo& operator=(const SSLClientCTData_SCTInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSLClientCTData_SCTInfo& default_instance();

  void Swap(SSLClientCTData_SCTInfo* other);

  // implements Message ----------------------------------------------

  SSLClientCTData_SCTInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SSLClientCTData_SCTInfo& from);
  void MergeFrom(const SSLClientCTData_SCTInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ct.SignedCertificateTimestamp sct = 1;
  inline bool has_sct() const;
  inline void clear_sct();
  static const int kSctFieldNumber = 1;
  inline const ::ct::SignedCertificateTimestamp& sct() const;
  inline ::ct::SignedCertificateTimestamp* mutable_sct();
  inline ::ct::SignedCertificateTimestamp* release_sct();
  inline void set_allocated_sct(::ct::SignedCertificateTimestamp* sct);

  // optional bytes merkle_leaf_hash = 2;
  inline bool has_merkle_leaf_hash() const;
  inline void clear_merkle_leaf_hash();
  static const int kMerkleLeafHashFieldNumber = 2;
  inline const ::std::string& merkle_leaf_hash() const;
  inline void set_merkle_leaf_hash(const ::std::string& value);
  inline void set_merkle_leaf_hash(const char* value);
  inline void set_merkle_leaf_hash(const void* value, size_t size);
  inline ::std::string* mutable_merkle_leaf_hash();
  inline ::std::string* release_merkle_leaf_hash();
  inline void set_allocated_merkle_leaf_hash(::std::string* merkle_leaf_hash);

  // @@protoc_insertion_point(class_scope:ct.SSLClientCTData.SCTInfo)
 private:
  inline void set_has_sct();
  inline void clear_has_sct();
  inline void set_has_merkle_leaf_hash();
  inline void clear_has_merkle_leaf_hash();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ct::SignedCertificateTimestamp* sct_;
  ::std::string* merkle_leaf_hash_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static SSLClientCTData_SCTInfo* default_instance_;
};
// -------------------------------------------------------------------

class SSLClientCTData : public ::google::protobuf::Message {
 public:
  SSLClientCTData();
  virtual ~SSLClientCTData();

  SSLClientCTData(const SSLClientCTData& from);

  inline SSLClientCTData& operator=(const SSLClientCTData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSLClientCTData& default_instance();

  void Swap(SSLClientCTData* other);

  // implements Message ----------------------------------------------

  SSLClientCTData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SSLClientCTData& from);
  void MergeFrom(const SSLClientCTData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SSLClientCTData_SCTInfo SCTInfo;

  // accessors -------------------------------------------------------

  // optional .ct.LogEntry reconstructed_entry = 1;
  inline bool has_reconstructed_entry() const;
  inline void clear_reconstructed_entry();
  static const int kReconstructedEntryFieldNumber = 1;
  inline const ::ct::LogEntry& reconstructed_entry() const;
  inline ::ct::LogEntry* mutable_reconstructed_entry();
  inline ::ct::LogEntry* release_reconstructed_entry();
  inline void set_allocated_reconstructed_entry(::ct::LogEntry* reconstructed_entry);

  // optional bytes certificate_sha256_hash = 2;
  inline bool has_certificate_sha256_hash() const;
  inline void clear_certificate_sha256_hash();
  static const int kCertificateSha256HashFieldNumber = 2;
  inline const ::std::string& certificate_sha256_hash() const;
  inline void set_certificate_sha256_hash(const ::std::string& value);
  inline void set_certificate_sha256_hash(const char* value);
  inline void set_certificate_sha256_hash(const void* value, size_t size);
  inline ::std::string* mutable_certificate_sha256_hash();
  inline ::std::string* release_certificate_sha256_hash();
  inline void set_allocated_certificate_sha256_hash(::std::string* certificate_sha256_hash);

  // repeated .ct.SSLClientCTData.SCTInfo attached_sct_info = 3;
  inline int attached_sct_info_size() const;
  inline void clear_attached_sct_info();
  static const int kAttachedSctInfoFieldNumber = 3;
  inline const ::ct::SSLClientCTData_SCTInfo& attached_sct_info(int index) const;
  inline ::ct::SSLClientCTData_SCTInfo* mutable_attached_sct_info(int index);
  inline ::ct::SSLClientCTData_SCTInfo* add_attached_sct_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ct::SSLClientCTData_SCTInfo >&
      attached_sct_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ct::SSLClientCTData_SCTInfo >*
      mutable_attached_sct_info();

  // @@protoc_insertion_point(class_scope:ct.SSLClientCTData)
 private:
  inline void set_has_reconstructed_entry();
  inline void clear_has_reconstructed_entry();
  inline void set_has_certificate_sha256_hash();
  inline void clear_has_certificate_sha256_hash();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ct::LogEntry* reconstructed_entry_;
  ::std::string* certificate_sha256_hash_;
  ::google::protobuf::RepeatedPtrField< ::ct::SSLClientCTData_SCTInfo > attached_sct_info_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static SSLClientCTData* default_instance_;
};
// -------------------------------------------------------------------

class ClusterNodeState : public ::google::protobuf::Message {
 public:
  ClusterNodeState();
  virtual ~ClusterNodeState();

  ClusterNodeState(const ClusterNodeState& from);

  inline ClusterNodeState& operator=(const ClusterNodeState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterNodeState& default_instance();

  void Swap(ClusterNodeState* other);

  // implements Message ----------------------------------------------

  ClusterNodeState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClusterNodeState& from);
  void MergeFrom(const ClusterNodeState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // optional int64 contiguous_tree_size = 2 [deprecated = true];
  inline bool has_contiguous_tree_size() const PROTOBUF_DEPRECATED;
  inline void clear_contiguous_tree_size() PROTOBUF_DEPRECATED;
  static const int kContiguousTreeSizeFieldNumber = 2;
  inline ::google::protobuf::int64 contiguous_tree_size() const PROTOBUF_DEPRECATED;
  inline void set_contiguous_tree_size(::google::protobuf::int64 value) PROTOBUF_DEPRECATED;

  // optional .ct.SignedTreeHead newest_sth = 3;
  inline bool has_newest_sth() const;
  inline void clear_newest_sth();
  static const int kNewestSthFieldNumber = 3;
  inline const ::ct::SignedTreeHead& newest_sth() const;
  inline ::ct::SignedTreeHead* mutable_newest_sth();
  inline ::ct::SignedTreeHead* release_newest_sth();
  inline void set_allocated_newest_sth(::ct::SignedTreeHead* newest_sth);

  // optional .ct.SignedTreeHead current_serving_sth = 4;
  inline bool has_current_serving_sth() const;
  inline void clear_current_serving_sth();
  static const int kCurrentServingSthFieldNumber = 4;
  inline const ::ct::SignedTreeHead& current_serving_sth() const;
  inline ::ct::SignedTreeHead* mutable_current_serving_sth();
  inline ::ct::SignedTreeHead* release_current_serving_sth();
  inline void set_allocated_current_serving_sth(::ct::SignedTreeHead* current_serving_sth);

  // optional string hostname = 5;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 5;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional int32 log_port = 6;
  inline bool has_log_port() const;
  inline void clear_log_port();
  static const int kLogPortFieldNumber = 6;
  inline ::google::protobuf::int32 log_port() const;
  inline void set_log_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ct.ClusterNodeState)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_contiguous_tree_size();
  inline void clear_has_contiguous_tree_size();
  inline void set_has_newest_sth();
  inline void clear_has_newest_sth();
  inline void set_has_current_serving_sth();
  inline void clear_has_current_serving_sth();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_log_port();
  inline void clear_has_log_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_id_;
  ::google::protobuf::int64 contiguous_tree_size_;
  ::ct::SignedTreeHead* newest_sth_;
  ::ct::SignedTreeHead* current_serving_sth_;
  ::std::string* hostname_;
  ::google::protobuf::int32 log_port_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static ClusterNodeState* default_instance_;
};
// -------------------------------------------------------------------

class ClusterControl : public ::google::protobuf::Message {
 public:
  ClusterControl();
  virtual ~ClusterControl();

  ClusterControl(const ClusterControl& from);

  inline ClusterControl& operator=(const ClusterControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterControl& default_instance();

  void Swap(ClusterControl* other);

  // implements Message ----------------------------------------------

  ClusterControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClusterControl& from);
  void MergeFrom(const ClusterControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool accept_new_entries = 1 [default = true];
  inline bool has_accept_new_entries() const;
  inline void clear_accept_new_entries();
  static const int kAcceptNewEntriesFieldNumber = 1;
  inline bool accept_new_entries() const;
  inline void set_accept_new_entries(bool value);

  // @@protoc_insertion_point(class_scope:ct.ClusterControl)
 private:
  inline void set_has_accept_new_entries();
  inline void clear_has_accept_new_entries();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool accept_new_entries_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static ClusterControl* default_instance_;
};
// -------------------------------------------------------------------

class ClusterConfig : public ::google::protobuf::Message {
 public:
  ClusterConfig();
  virtual ~ClusterConfig();

  ClusterConfig(const ClusterConfig& from);

  inline ClusterConfig& operator=(const ClusterConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterConfig& default_instance();

  void Swap(ClusterConfig* other);

  // implements Message ----------------------------------------------

  ClusterConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClusterConfig& from);
  void MergeFrom(const ClusterConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 minimum_serving_nodes = 1;
  inline bool has_minimum_serving_nodes() const;
  inline void clear_minimum_serving_nodes();
  static const int kMinimumServingNodesFieldNumber = 1;
  inline ::google::protobuf::int32 minimum_serving_nodes() const;
  inline void set_minimum_serving_nodes(::google::protobuf::int32 value);

  // optional double minimum_serving_fraction = 2;
  inline bool has_minimum_serving_fraction() const;
  inline void clear_minimum_serving_fraction();
  static const int kMinimumServingFractionFieldNumber = 2;
  inline double minimum_serving_fraction() const;
  inline void set_minimum_serving_fraction(double value);

  // optional double etcd_reject_add_pending_threshold = 3 [default = 30000];
  inline bool has_etcd_reject_add_pending_threshold() const;
  inline void clear_etcd_reject_add_pending_threshold();
  static const int kEtcdRejectAddPendingThresholdFieldNumber = 3;
  inline double etcd_reject_add_pending_threshold() const;
  inline void set_etcd_reject_add_pending_threshold(double value);

  // @@protoc_insertion_point(class_scope:ct.ClusterConfig)
 private:
  inline void set_has_minimum_serving_nodes();
  inline void clear_has_minimum_serving_nodes();
  inline void set_has_minimum_serving_fraction();
  inline void clear_has_minimum_serving_fraction();
  inline void set_has_etcd_reject_add_pending_threshold();
  inline void clear_has_etcd_reject_add_pending_threshold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double minimum_serving_fraction_;
  double etcd_reject_add_pending_threshold_;
  ::google::protobuf::int32 minimum_serving_nodes_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static ClusterConfig* default_instance_;
};
// -------------------------------------------------------------------

class SequenceMapping_Mapping : public ::google::protobuf::Message {
 public:
  SequenceMapping_Mapping();
  virtual ~SequenceMapping_Mapping();

  SequenceMapping_Mapping(const SequenceMapping_Mapping& from);

  inline SequenceMapping_Mapping& operator=(const SequenceMapping_Mapping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceMapping_Mapping& default_instance();

  void Swap(SequenceMapping_Mapping* other);

  // implements Message ----------------------------------------------

  SequenceMapping_Mapping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SequenceMapping_Mapping& from);
  void MergeFrom(const SequenceMapping_Mapping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes entry_hash = 1;
  inline bool has_entry_hash() const;
  inline void clear_entry_hash();
  static const int kEntryHashFieldNumber = 1;
  inline const ::std::string& entry_hash() const;
  inline void set_entry_hash(const ::std::string& value);
  inline void set_entry_hash(const char* value);
  inline void set_entry_hash(const void* value, size_t size);
  inline ::std::string* mutable_entry_hash();
  inline ::std::string* release_entry_hash();
  inline void set_allocated_entry_hash(::std::string* entry_hash);

  // optional int64 sequence_number = 2;
  inline bool has_sequence_number() const;
  inline void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 2;
  inline ::google::protobuf::int64 sequence_number() const;
  inline void set_sequence_number(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ct.SequenceMapping.Mapping)
 private:
  inline void set_has_entry_hash();
  inline void clear_has_entry_hash();
  inline void set_has_sequence_number();
  inline void clear_has_sequence_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* entry_hash_;
  ::google::protobuf::int64 sequence_number_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static SequenceMapping_Mapping* default_instance_;
};
// -------------------------------------------------------------------

class SequenceMapping : public ::google::protobuf::Message {
 public:
  SequenceMapping();
  virtual ~SequenceMapping();

  SequenceMapping(const SequenceMapping& from);

  inline SequenceMapping& operator=(const SequenceMapping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceMapping& default_instance();

  void Swap(SequenceMapping* other);

  // implements Message ----------------------------------------------

  SequenceMapping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SequenceMapping& from);
  void MergeFrom(const SequenceMapping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SequenceMapping_Mapping Mapping;

  // accessors -------------------------------------------------------

  // repeated .ct.SequenceMapping.Mapping mapping = 1;
  inline int mapping_size() const;
  inline void clear_mapping();
  static const int kMappingFieldNumber = 1;
  inline const ::ct::SequenceMapping_Mapping& mapping(int index) const;
  inline ::ct::SequenceMapping_Mapping* mutable_mapping(int index);
  inline ::ct::SequenceMapping_Mapping* add_mapping();
  inline const ::google::protobuf::RepeatedPtrField< ::ct::SequenceMapping_Mapping >&
      mapping() const;
  inline ::google::protobuf::RepeatedPtrField< ::ct::SequenceMapping_Mapping >*
      mutable_mapping();

  // @@protoc_insertion_point(class_scope:ct.SequenceMapping)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ct::SequenceMapping_Mapping > mapping_;
  friend void  protobuf_AddDesc_proto_2fct_2eproto();
  friend void protobuf_AssignDesc_proto_2fct_2eproto();
  friend void protobuf_ShutdownFile_proto_2fct_2eproto();

  void InitAsDefaultInstance();
  static SequenceMapping* default_instance_;
};
// ===================================================================


// ===================================================================

// DigitallySigned

// optional .ct.DigitallySigned.HashAlgorithm hash_algorithm = 1 [default = NONE];
inline bool DigitallySigned::has_hash_algorithm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DigitallySigned::set_has_hash_algorithm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DigitallySigned::clear_has_hash_algorithm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DigitallySigned::clear_hash_algorithm() {
  hash_algorithm_ = 0;
  clear_has_hash_algorithm();
}
inline ::ct::DigitallySigned_HashAlgorithm DigitallySigned::hash_algorithm() const {
  // @@protoc_insertion_point(field_get:ct.DigitallySigned.hash_algorithm)
  return static_cast< ::ct::DigitallySigned_HashAlgorithm >(hash_algorithm_);
}
inline void DigitallySigned::set_hash_algorithm(::ct::DigitallySigned_HashAlgorithm value) {
  assert(::ct::DigitallySigned_HashAlgorithm_IsValid(value));
  set_has_hash_algorithm();
  hash_algorithm_ = value;
  // @@protoc_insertion_point(field_set:ct.DigitallySigned.hash_algorithm)
}

// optional .ct.DigitallySigned.SignatureAlgorithm sig_algorithm = 2 [default = ANONYMOUS];
inline bool DigitallySigned::has_sig_algorithm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DigitallySigned::set_has_sig_algorithm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DigitallySigned::clear_has_sig_algorithm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DigitallySigned::clear_sig_algorithm() {
  sig_algorithm_ = 0;
  clear_has_sig_algorithm();
}
inline ::ct::DigitallySigned_SignatureAlgorithm DigitallySigned::sig_algorithm() const {
  // @@protoc_insertion_point(field_get:ct.DigitallySigned.sig_algorithm)
  return static_cast< ::ct::DigitallySigned_SignatureAlgorithm >(sig_algorithm_);
}
inline void DigitallySigned::set_sig_algorithm(::ct::DigitallySigned_SignatureAlgorithm value) {
  assert(::ct::DigitallySigned_SignatureAlgorithm_IsValid(value));
  set_has_sig_algorithm();
  sig_algorithm_ = value;
  // @@protoc_insertion_point(field_set:ct.DigitallySigned.sig_algorithm)
}

// optional bytes signature = 3;
inline bool DigitallySigned::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DigitallySigned::set_has_signature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DigitallySigned::clear_has_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DigitallySigned::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& DigitallySigned::signature() const {
  // @@protoc_insertion_point(field_get:ct.DigitallySigned.signature)
  return *signature_;
}
inline void DigitallySigned::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:ct.DigitallySigned.signature)
}
inline void DigitallySigned::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.DigitallySigned.signature)
}
inline void DigitallySigned::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.DigitallySigned.signature)
}
inline ::std::string* DigitallySigned::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.DigitallySigned.signature)
  return signature_;
}
inline ::std::string* DigitallySigned::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DigitallySigned::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.DigitallySigned.signature)
}

// -------------------------------------------------------------------

// X509ChainEntry

// optional bytes leaf_certificate = 1;
inline bool X509ChainEntry::has_leaf_certificate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X509ChainEntry::set_has_leaf_certificate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X509ChainEntry::clear_has_leaf_certificate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X509ChainEntry::clear_leaf_certificate() {
  if (leaf_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    leaf_certificate_->clear();
  }
  clear_has_leaf_certificate();
}
inline const ::std::string& X509ChainEntry::leaf_certificate() const {
  // @@protoc_insertion_point(field_get:ct.X509ChainEntry.leaf_certificate)
  return *leaf_certificate_;
}
inline void X509ChainEntry::set_leaf_certificate(const ::std::string& value) {
  set_has_leaf_certificate();
  if (leaf_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    leaf_certificate_ = new ::std::string;
  }
  leaf_certificate_->assign(value);
  // @@protoc_insertion_point(field_set:ct.X509ChainEntry.leaf_certificate)
}
inline void X509ChainEntry::set_leaf_certificate(const char* value) {
  set_has_leaf_certificate();
  if (leaf_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    leaf_certificate_ = new ::std::string;
  }
  leaf_certificate_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.X509ChainEntry.leaf_certificate)
}
inline void X509ChainEntry::set_leaf_certificate(const void* value, size_t size) {
  set_has_leaf_certificate();
  if (leaf_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    leaf_certificate_ = new ::std::string;
  }
  leaf_certificate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.X509ChainEntry.leaf_certificate)
}
inline ::std::string* X509ChainEntry::mutable_leaf_certificate() {
  set_has_leaf_certificate();
  if (leaf_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    leaf_certificate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.X509ChainEntry.leaf_certificate)
  return leaf_certificate_;
}
inline ::std::string* X509ChainEntry::release_leaf_certificate() {
  clear_has_leaf_certificate();
  if (leaf_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = leaf_certificate_;
    leaf_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void X509ChainEntry::set_allocated_leaf_certificate(::std::string* leaf_certificate) {
  if (leaf_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete leaf_certificate_;
  }
  if (leaf_certificate) {
    set_has_leaf_certificate();
    leaf_certificate_ = leaf_certificate;
  } else {
    clear_has_leaf_certificate();
    leaf_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.X509ChainEntry.leaf_certificate)
}

// optional .ct.CertInfo cert_info = 3;
inline bool X509ChainEntry::has_cert_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X509ChainEntry::set_has_cert_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X509ChainEntry::clear_has_cert_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X509ChainEntry::clear_cert_info() {
  if (cert_info_ != NULL) cert_info_->::ct::CertInfo::Clear();
  clear_has_cert_info();
}
inline const ::ct::CertInfo& X509ChainEntry::cert_info() const {
  // @@protoc_insertion_point(field_get:ct.X509ChainEntry.cert_info)
  return cert_info_ != NULL ? *cert_info_ : *default_instance_->cert_info_;
}
inline ::ct::CertInfo* X509ChainEntry::mutable_cert_info() {
  set_has_cert_info();
  if (cert_info_ == NULL) cert_info_ = new ::ct::CertInfo;
  // @@protoc_insertion_point(field_mutable:ct.X509ChainEntry.cert_info)
  return cert_info_;
}
inline ::ct::CertInfo* X509ChainEntry::release_cert_info() {
  clear_has_cert_info();
  ::ct::CertInfo* temp = cert_info_;
  cert_info_ = NULL;
  return temp;
}
inline void X509ChainEntry::set_allocated_cert_info(::ct::CertInfo* cert_info) {
  delete cert_info_;
  cert_info_ = cert_info;
  if (cert_info) {
    set_has_cert_info();
  } else {
    clear_has_cert_info();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.X509ChainEntry.cert_info)
}

// repeated bytes certificate_chain = 2;
inline int X509ChainEntry::certificate_chain_size() const {
  return certificate_chain_.size();
}
inline void X509ChainEntry::clear_certificate_chain() {
  certificate_chain_.Clear();
}
inline const ::std::string& X509ChainEntry::certificate_chain(int index) const {
  // @@protoc_insertion_point(field_get:ct.X509ChainEntry.certificate_chain)
  return certificate_chain_.Get(index);
}
inline ::std::string* X509ChainEntry::mutable_certificate_chain(int index) {
  // @@protoc_insertion_point(field_mutable:ct.X509ChainEntry.certificate_chain)
  return certificate_chain_.Mutable(index);
}
inline void X509ChainEntry::set_certificate_chain(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ct.X509ChainEntry.certificate_chain)
  certificate_chain_.Mutable(index)->assign(value);
}
inline void X509ChainEntry::set_certificate_chain(int index, const char* value) {
  certificate_chain_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.X509ChainEntry.certificate_chain)
}
inline void X509ChainEntry::set_certificate_chain(int index, const void* value, size_t size) {
  certificate_chain_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.X509ChainEntry.certificate_chain)
}
inline ::std::string* X509ChainEntry::add_certificate_chain() {
  return certificate_chain_.Add();
}
inline void X509ChainEntry::add_certificate_chain(const ::std::string& value) {
  certificate_chain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ct.X509ChainEntry.certificate_chain)
}
inline void X509ChainEntry::add_certificate_chain(const char* value) {
  certificate_chain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ct.X509ChainEntry.certificate_chain)
}
inline void X509ChainEntry::add_certificate_chain(const void* value, size_t size) {
  certificate_chain_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ct.X509ChainEntry.certificate_chain)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
X509ChainEntry::certificate_chain() const {
  // @@protoc_insertion_point(field_list:ct.X509ChainEntry.certificate_chain)
  return certificate_chain_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
X509ChainEntry::mutable_certificate_chain() {
  // @@protoc_insertion_point(field_mutable_list:ct.X509ChainEntry.certificate_chain)
  return &certificate_chain_;
}

// -------------------------------------------------------------------

// PreCert

// optional bytes issuer_key_hash = 1;
inline bool PreCert::has_issuer_key_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreCert::set_has_issuer_key_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreCert::clear_has_issuer_key_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreCert::clear_issuer_key_hash() {
  if (issuer_key_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    issuer_key_hash_->clear();
  }
  clear_has_issuer_key_hash();
}
inline const ::std::string& PreCert::issuer_key_hash() const {
  // @@protoc_insertion_point(field_get:ct.PreCert.issuer_key_hash)
  return *issuer_key_hash_;
}
inline void PreCert::set_issuer_key_hash(const ::std::string& value) {
  set_has_issuer_key_hash();
  if (issuer_key_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    issuer_key_hash_ = new ::std::string;
  }
  issuer_key_hash_->assign(value);
  // @@protoc_insertion_point(field_set:ct.PreCert.issuer_key_hash)
}
inline void PreCert::set_issuer_key_hash(const char* value) {
  set_has_issuer_key_hash();
  if (issuer_key_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    issuer_key_hash_ = new ::std::string;
  }
  issuer_key_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.PreCert.issuer_key_hash)
}
inline void PreCert::set_issuer_key_hash(const void* value, size_t size) {
  set_has_issuer_key_hash();
  if (issuer_key_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    issuer_key_hash_ = new ::std::string;
  }
  issuer_key_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.PreCert.issuer_key_hash)
}
inline ::std::string* PreCert::mutable_issuer_key_hash() {
  set_has_issuer_key_hash();
  if (issuer_key_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    issuer_key_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.PreCert.issuer_key_hash)
  return issuer_key_hash_;
}
inline ::std::string* PreCert::release_issuer_key_hash() {
  clear_has_issuer_key_hash();
  if (issuer_key_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = issuer_key_hash_;
    issuer_key_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PreCert::set_allocated_issuer_key_hash(::std::string* issuer_key_hash) {
  if (issuer_key_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete issuer_key_hash_;
  }
  if (issuer_key_hash) {
    set_has_issuer_key_hash();
    issuer_key_hash_ = issuer_key_hash;
  } else {
    clear_has_issuer_key_hash();
    issuer_key_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.PreCert.issuer_key_hash)
}

// optional bytes tbs_certificate = 2;
inline bool PreCert::has_tbs_certificate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PreCert::set_has_tbs_certificate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PreCert::clear_has_tbs_certificate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PreCert::clear_tbs_certificate() {
  if (tbs_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tbs_certificate_->clear();
  }
  clear_has_tbs_certificate();
}
inline const ::std::string& PreCert::tbs_certificate() const {
  // @@protoc_insertion_point(field_get:ct.PreCert.tbs_certificate)
  return *tbs_certificate_;
}
inline void PreCert::set_tbs_certificate(const ::std::string& value) {
  set_has_tbs_certificate();
  if (tbs_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tbs_certificate_ = new ::std::string;
  }
  tbs_certificate_->assign(value);
  // @@protoc_insertion_point(field_set:ct.PreCert.tbs_certificate)
}
inline void PreCert::set_tbs_certificate(const char* value) {
  set_has_tbs_certificate();
  if (tbs_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tbs_certificate_ = new ::std::string;
  }
  tbs_certificate_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.PreCert.tbs_certificate)
}
inline void PreCert::set_tbs_certificate(const void* value, size_t size) {
  set_has_tbs_certificate();
  if (tbs_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tbs_certificate_ = new ::std::string;
  }
  tbs_certificate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.PreCert.tbs_certificate)
}
inline ::std::string* PreCert::mutable_tbs_certificate() {
  set_has_tbs_certificate();
  if (tbs_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tbs_certificate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.PreCert.tbs_certificate)
  return tbs_certificate_;
}
inline ::std::string* PreCert::release_tbs_certificate() {
  clear_has_tbs_certificate();
  if (tbs_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tbs_certificate_;
    tbs_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PreCert::set_allocated_tbs_certificate(::std::string* tbs_certificate) {
  if (tbs_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tbs_certificate_;
  }
  if (tbs_certificate) {
    set_has_tbs_certificate();
    tbs_certificate_ = tbs_certificate;
  } else {
    clear_has_tbs_certificate();
    tbs_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.PreCert.tbs_certificate)
}

// -------------------------------------------------------------------

// CertInfo

// optional bytes issuer_key_hash = 1;
inline bool CertInfo::has_issuer_key_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CertInfo::set_has_issuer_key_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CertInfo::clear_has_issuer_key_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CertInfo::clear_issuer_key_hash() {
  if (issuer_key_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    issuer_key_hash_->clear();
  }
  clear_has_issuer_key_hash();
}
inline const ::std::string& CertInfo::issuer_key_hash() const {
  // @@protoc_insertion_point(field_get:ct.CertInfo.issuer_key_hash)
  return *issuer_key_hash_;
}
inline void CertInfo::set_issuer_key_hash(const ::std::string& value) {
  set_has_issuer_key_hash();
  if (issuer_key_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    issuer_key_hash_ = new ::std::string;
  }
  issuer_key_hash_->assign(value);
  // @@protoc_insertion_point(field_set:ct.CertInfo.issuer_key_hash)
}
inline void CertInfo::set_issuer_key_hash(const char* value) {
  set_has_issuer_key_hash();
  if (issuer_key_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    issuer_key_hash_ = new ::std::string;
  }
  issuer_key_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.CertInfo.issuer_key_hash)
}
inline void CertInfo::set_issuer_key_hash(const void* value, size_t size) {
  set_has_issuer_key_hash();
  if (issuer_key_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    issuer_key_hash_ = new ::std::string;
  }
  issuer_key_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.CertInfo.issuer_key_hash)
}
inline ::std::string* CertInfo::mutable_issuer_key_hash() {
  set_has_issuer_key_hash();
  if (issuer_key_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    issuer_key_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.CertInfo.issuer_key_hash)
  return issuer_key_hash_;
}
inline ::std::string* CertInfo::release_issuer_key_hash() {
  clear_has_issuer_key_hash();
  if (issuer_key_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = issuer_key_hash_;
    issuer_key_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CertInfo::set_allocated_issuer_key_hash(::std::string* issuer_key_hash) {
  if (issuer_key_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete issuer_key_hash_;
  }
  if (issuer_key_hash) {
    set_has_issuer_key_hash();
    issuer_key_hash_ = issuer_key_hash;
  } else {
    clear_has_issuer_key_hash();
    issuer_key_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.CertInfo.issuer_key_hash)
}

// optional bytes tbs_certificate = 2;
inline bool CertInfo::has_tbs_certificate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CertInfo::set_has_tbs_certificate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CertInfo::clear_has_tbs_certificate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CertInfo::clear_tbs_certificate() {
  if (tbs_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tbs_certificate_->clear();
  }
  clear_has_tbs_certificate();
}
inline const ::std::string& CertInfo::tbs_certificate() const {
  // @@protoc_insertion_point(field_get:ct.CertInfo.tbs_certificate)
  return *tbs_certificate_;
}
inline void CertInfo::set_tbs_certificate(const ::std::string& value) {
  set_has_tbs_certificate();
  if (tbs_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tbs_certificate_ = new ::std::string;
  }
  tbs_certificate_->assign(value);
  // @@protoc_insertion_point(field_set:ct.CertInfo.tbs_certificate)
}
inline void CertInfo::set_tbs_certificate(const char* value) {
  set_has_tbs_certificate();
  if (tbs_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tbs_certificate_ = new ::std::string;
  }
  tbs_certificate_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.CertInfo.tbs_certificate)
}
inline void CertInfo::set_tbs_certificate(const void* value, size_t size) {
  set_has_tbs_certificate();
  if (tbs_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tbs_certificate_ = new ::std::string;
  }
  tbs_certificate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.CertInfo.tbs_certificate)
}
inline ::std::string* CertInfo::mutable_tbs_certificate() {
  set_has_tbs_certificate();
  if (tbs_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tbs_certificate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.CertInfo.tbs_certificate)
  return tbs_certificate_;
}
inline ::std::string* CertInfo::release_tbs_certificate() {
  clear_has_tbs_certificate();
  if (tbs_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tbs_certificate_;
    tbs_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CertInfo::set_allocated_tbs_certificate(::std::string* tbs_certificate) {
  if (tbs_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tbs_certificate_;
  }
  if (tbs_certificate) {
    set_has_tbs_certificate();
    tbs_certificate_ = tbs_certificate;
  } else {
    clear_has_tbs_certificate();
    tbs_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.CertInfo.tbs_certificate)
}

// -------------------------------------------------------------------

// PrecertChainEntry

// optional bytes pre_certificate = 1;
inline bool PrecertChainEntry::has_pre_certificate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrecertChainEntry::set_has_pre_certificate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrecertChainEntry::clear_has_pre_certificate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrecertChainEntry::clear_pre_certificate() {
  if (pre_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pre_certificate_->clear();
  }
  clear_has_pre_certificate();
}
inline const ::std::string& PrecertChainEntry::pre_certificate() const {
  // @@protoc_insertion_point(field_get:ct.PrecertChainEntry.pre_certificate)
  return *pre_certificate_;
}
inline void PrecertChainEntry::set_pre_certificate(const ::std::string& value) {
  set_has_pre_certificate();
  if (pre_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pre_certificate_ = new ::std::string;
  }
  pre_certificate_->assign(value);
  // @@protoc_insertion_point(field_set:ct.PrecertChainEntry.pre_certificate)
}
inline void PrecertChainEntry::set_pre_certificate(const char* value) {
  set_has_pre_certificate();
  if (pre_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pre_certificate_ = new ::std::string;
  }
  pre_certificate_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.PrecertChainEntry.pre_certificate)
}
inline void PrecertChainEntry::set_pre_certificate(const void* value, size_t size) {
  set_has_pre_certificate();
  if (pre_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pre_certificate_ = new ::std::string;
  }
  pre_certificate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.PrecertChainEntry.pre_certificate)
}
inline ::std::string* PrecertChainEntry::mutable_pre_certificate() {
  set_has_pre_certificate();
  if (pre_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pre_certificate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.PrecertChainEntry.pre_certificate)
  return pre_certificate_;
}
inline ::std::string* PrecertChainEntry::release_pre_certificate() {
  clear_has_pre_certificate();
  if (pre_certificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pre_certificate_;
    pre_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrecertChainEntry::set_allocated_pre_certificate(::std::string* pre_certificate) {
  if (pre_certificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pre_certificate_;
  }
  if (pre_certificate) {
    set_has_pre_certificate();
    pre_certificate_ = pre_certificate;
  } else {
    clear_has_pre_certificate();
    pre_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.PrecertChainEntry.pre_certificate)
}

// repeated bytes precertificate_chain = 2;
inline int PrecertChainEntry::precertificate_chain_size() const {
  return precertificate_chain_.size();
}
inline void PrecertChainEntry::clear_precertificate_chain() {
  precertificate_chain_.Clear();
}
inline const ::std::string& PrecertChainEntry::precertificate_chain(int index) const {
  // @@protoc_insertion_point(field_get:ct.PrecertChainEntry.precertificate_chain)
  return precertificate_chain_.Get(index);
}
inline ::std::string* PrecertChainEntry::mutable_precertificate_chain(int index) {
  // @@protoc_insertion_point(field_mutable:ct.PrecertChainEntry.precertificate_chain)
  return precertificate_chain_.Mutable(index);
}
inline void PrecertChainEntry::set_precertificate_chain(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ct.PrecertChainEntry.precertificate_chain)
  precertificate_chain_.Mutable(index)->assign(value);
}
inline void PrecertChainEntry::set_precertificate_chain(int index, const char* value) {
  precertificate_chain_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.PrecertChainEntry.precertificate_chain)
}
inline void PrecertChainEntry::set_precertificate_chain(int index, const void* value, size_t size) {
  precertificate_chain_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.PrecertChainEntry.precertificate_chain)
}
inline ::std::string* PrecertChainEntry::add_precertificate_chain() {
  return precertificate_chain_.Add();
}
inline void PrecertChainEntry::add_precertificate_chain(const ::std::string& value) {
  precertificate_chain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ct.PrecertChainEntry.precertificate_chain)
}
inline void PrecertChainEntry::add_precertificate_chain(const char* value) {
  precertificate_chain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ct.PrecertChainEntry.precertificate_chain)
}
inline void PrecertChainEntry::add_precertificate_chain(const void* value, size_t size) {
  precertificate_chain_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ct.PrecertChainEntry.precertificate_chain)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PrecertChainEntry::precertificate_chain() const {
  // @@protoc_insertion_point(field_list:ct.PrecertChainEntry.precertificate_chain)
  return precertificate_chain_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PrecertChainEntry::mutable_precertificate_chain() {
  // @@protoc_insertion_point(field_mutable_list:ct.PrecertChainEntry.precertificate_chain)
  return &precertificate_chain_;
}

// optional .ct.PreCert pre_cert = 3;
inline bool PrecertChainEntry::has_pre_cert() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrecertChainEntry::set_has_pre_cert() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrecertChainEntry::clear_has_pre_cert() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrecertChainEntry::clear_pre_cert() {
  if (pre_cert_ != NULL) pre_cert_->::ct::PreCert::Clear();
  clear_has_pre_cert();
}
inline const ::ct::PreCert& PrecertChainEntry::pre_cert() const {
  // @@protoc_insertion_point(field_get:ct.PrecertChainEntry.pre_cert)
  return pre_cert_ != NULL ? *pre_cert_ : *default_instance_->pre_cert_;
}
inline ::ct::PreCert* PrecertChainEntry::mutable_pre_cert() {
  set_has_pre_cert();
  if (pre_cert_ == NULL) pre_cert_ = new ::ct::PreCert;
  // @@protoc_insertion_point(field_mutable:ct.PrecertChainEntry.pre_cert)
  return pre_cert_;
}
inline ::ct::PreCert* PrecertChainEntry::release_pre_cert() {
  clear_has_pre_cert();
  ::ct::PreCert* temp = pre_cert_;
  pre_cert_ = NULL;
  return temp;
}
inline void PrecertChainEntry::set_allocated_pre_cert(::ct::PreCert* pre_cert) {
  delete pre_cert_;
  pre_cert_ = pre_cert;
  if (pre_cert) {
    set_has_pre_cert();
  } else {
    clear_has_pre_cert();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.PrecertChainEntry.pre_cert)
}

// optional .ct.CertInfo cert_info = 4;
inline bool PrecertChainEntry::has_cert_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrecertChainEntry::set_has_cert_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrecertChainEntry::clear_has_cert_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrecertChainEntry::clear_cert_info() {
  if (cert_info_ != NULL) cert_info_->::ct::CertInfo::Clear();
  clear_has_cert_info();
}
inline const ::ct::CertInfo& PrecertChainEntry::cert_info() const {
  // @@protoc_insertion_point(field_get:ct.PrecertChainEntry.cert_info)
  return cert_info_ != NULL ? *cert_info_ : *default_instance_->cert_info_;
}
inline ::ct::CertInfo* PrecertChainEntry::mutable_cert_info() {
  set_has_cert_info();
  if (cert_info_ == NULL) cert_info_ = new ::ct::CertInfo;
  // @@protoc_insertion_point(field_mutable:ct.PrecertChainEntry.cert_info)
  return cert_info_;
}
inline ::ct::CertInfo* PrecertChainEntry::release_cert_info() {
  clear_has_cert_info();
  ::ct::CertInfo* temp = cert_info_;
  cert_info_ = NULL;
  return temp;
}
inline void PrecertChainEntry::set_allocated_cert_info(::ct::CertInfo* cert_info) {
  delete cert_info_;
  cert_info_ = cert_info;
  if (cert_info) {
    set_has_cert_info();
  } else {
    clear_has_cert_info();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.PrecertChainEntry.cert_info)
}

// -------------------------------------------------------------------

// XJSONEntry

// optional string json = 1;
inline bool XJSONEntry::has_json() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XJSONEntry::set_has_json() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XJSONEntry::clear_has_json() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XJSONEntry::clear_json() {
  if (json_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    json_->clear();
  }
  clear_has_json();
}
inline const ::std::string& XJSONEntry::json() const {
  // @@protoc_insertion_point(field_get:ct.XJSONEntry.json)
  return *json_;
}
inline void XJSONEntry::set_json(const ::std::string& value) {
  set_has_json();
  if (json_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    json_ = new ::std::string;
  }
  json_->assign(value);
  // @@protoc_insertion_point(field_set:ct.XJSONEntry.json)
}
inline void XJSONEntry::set_json(const char* value) {
  set_has_json();
  if (json_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    json_ = new ::std::string;
  }
  json_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.XJSONEntry.json)
}
inline void XJSONEntry::set_json(const char* value, size_t size) {
  set_has_json();
  if (json_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    json_ = new ::std::string;
  }
  json_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.XJSONEntry.json)
}
inline ::std::string* XJSONEntry::mutable_json() {
  set_has_json();
  if (json_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    json_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.XJSONEntry.json)
  return json_;
}
inline ::std::string* XJSONEntry::release_json() {
  clear_has_json();
  if (json_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = json_;
    json_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void XJSONEntry::set_allocated_json(::std::string* json) {
  if (json_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete json_;
  }
  if (json) {
    set_has_json();
    json_ = json;
  } else {
    clear_has_json();
    json_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.XJSONEntry.json)
}

// -------------------------------------------------------------------

// LogEntry

// optional .ct.LogEntryType type = 1 [default = UNKNOWN_ENTRY_TYPE];
inline bool LogEntry::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogEntry::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogEntry::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogEntry::clear_type() {
  type_ = 65536;
  clear_has_type();
}
inline ::ct::LogEntryType LogEntry::type() const {
  // @@protoc_insertion_point(field_get:ct.LogEntry.type)
  return static_cast< ::ct::LogEntryType >(type_);
}
inline void LogEntry::set_type(::ct::LogEntryType value) {
  assert(::ct::LogEntryType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ct.LogEntry.type)
}

// optional .ct.X509ChainEntry x509_entry = 2;
inline bool LogEntry::has_x509_entry() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogEntry::set_has_x509_entry() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogEntry::clear_has_x509_entry() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogEntry::clear_x509_entry() {
  if (x509_entry_ != NULL) x509_entry_->::ct::X509ChainEntry::Clear();
  clear_has_x509_entry();
}
inline const ::ct::X509ChainEntry& LogEntry::x509_entry() const {
  // @@protoc_insertion_point(field_get:ct.LogEntry.x509_entry)
  return x509_entry_ != NULL ? *x509_entry_ : *default_instance_->x509_entry_;
}
inline ::ct::X509ChainEntry* LogEntry::mutable_x509_entry() {
  set_has_x509_entry();
  if (x509_entry_ == NULL) x509_entry_ = new ::ct::X509ChainEntry;
  // @@protoc_insertion_point(field_mutable:ct.LogEntry.x509_entry)
  return x509_entry_;
}
inline ::ct::X509ChainEntry* LogEntry::release_x509_entry() {
  clear_has_x509_entry();
  ::ct::X509ChainEntry* temp = x509_entry_;
  x509_entry_ = NULL;
  return temp;
}
inline void LogEntry::set_allocated_x509_entry(::ct::X509ChainEntry* x509_entry) {
  delete x509_entry_;
  x509_entry_ = x509_entry;
  if (x509_entry) {
    set_has_x509_entry();
  } else {
    clear_has_x509_entry();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.LogEntry.x509_entry)
}

// optional .ct.PrecertChainEntry precert_entry = 3;
inline bool LogEntry::has_precert_entry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogEntry::set_has_precert_entry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogEntry::clear_has_precert_entry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogEntry::clear_precert_entry() {
  if (precert_entry_ != NULL) precert_entry_->::ct::PrecertChainEntry::Clear();
  clear_has_precert_entry();
}
inline const ::ct::PrecertChainEntry& LogEntry::precert_entry() const {
  // @@protoc_insertion_point(field_get:ct.LogEntry.precert_entry)
  return precert_entry_ != NULL ? *precert_entry_ : *default_instance_->precert_entry_;
}
inline ::ct::PrecertChainEntry* LogEntry::mutable_precert_entry() {
  set_has_precert_entry();
  if (precert_entry_ == NULL) precert_entry_ = new ::ct::PrecertChainEntry;
  // @@protoc_insertion_point(field_mutable:ct.LogEntry.precert_entry)
  return precert_entry_;
}
inline ::ct::PrecertChainEntry* LogEntry::release_precert_entry() {
  clear_has_precert_entry();
  ::ct::PrecertChainEntry* temp = precert_entry_;
  precert_entry_ = NULL;
  return temp;
}
inline void LogEntry::set_allocated_precert_entry(::ct::PrecertChainEntry* precert_entry) {
  delete precert_entry_;
  precert_entry_ = precert_entry;
  if (precert_entry) {
    set_has_precert_entry();
  } else {
    clear_has_precert_entry();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.LogEntry.precert_entry)
}

// optional .ct.XJSONEntry x_json_entry = 4;
inline bool LogEntry::has_x_json_entry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogEntry::set_has_x_json_entry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogEntry::clear_has_x_json_entry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogEntry::clear_x_json_entry() {
  if (x_json_entry_ != NULL) x_json_entry_->::ct::XJSONEntry::Clear();
  clear_has_x_json_entry();
}
inline const ::ct::XJSONEntry& LogEntry::x_json_entry() const {
  // @@protoc_insertion_point(field_get:ct.LogEntry.x_json_entry)
  return x_json_entry_ != NULL ? *x_json_entry_ : *default_instance_->x_json_entry_;
}
inline ::ct::XJSONEntry* LogEntry::mutable_x_json_entry() {
  set_has_x_json_entry();
  if (x_json_entry_ == NULL) x_json_entry_ = new ::ct::XJSONEntry;
  // @@protoc_insertion_point(field_mutable:ct.LogEntry.x_json_entry)
  return x_json_entry_;
}
inline ::ct::XJSONEntry* LogEntry::release_x_json_entry() {
  clear_has_x_json_entry();
  ::ct::XJSONEntry* temp = x_json_entry_;
  x_json_entry_ = NULL;
  return temp;
}
inline void LogEntry::set_allocated_x_json_entry(::ct::XJSONEntry* x_json_entry) {
  delete x_json_entry_;
  x_json_entry_ = x_json_entry;
  if (x_json_entry) {
    set_has_x_json_entry();
  } else {
    clear_has_x_json_entry();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.LogEntry.x_json_entry)
}

// -------------------------------------------------------------------

// LogID

// optional bytes key_id = 1;
inline bool LogID::has_key_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogID::set_has_key_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogID::clear_has_key_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogID::clear_key_id() {
  if (key_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_id_->clear();
  }
  clear_has_key_id();
}
inline const ::std::string& LogID::key_id() const {
  // @@protoc_insertion_point(field_get:ct.LogID.key_id)
  return *key_id_;
}
inline void LogID::set_key_id(const ::std::string& value) {
  set_has_key_id();
  if (key_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_id_ = new ::std::string;
  }
  key_id_->assign(value);
  // @@protoc_insertion_point(field_set:ct.LogID.key_id)
}
inline void LogID::set_key_id(const char* value) {
  set_has_key_id();
  if (key_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_id_ = new ::std::string;
  }
  key_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.LogID.key_id)
}
inline void LogID::set_key_id(const void* value, size_t size) {
  set_has_key_id();
  if (key_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_id_ = new ::std::string;
  }
  key_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.LogID.key_id)
}
inline ::std::string* LogID::mutable_key_id() {
  set_has_key_id();
  if (key_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.LogID.key_id)
  return key_id_;
}
inline ::std::string* LogID::release_key_id() {
  clear_has_key_id();
  if (key_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_id_;
    key_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogID::set_allocated_key_id(::std::string* key_id) {
  if (key_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_id_;
  }
  if (key_id) {
    set_has_key_id();
    key_id_ = key_id;
  } else {
    clear_has_key_id();
    key_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.LogID.key_id)
}

// -------------------------------------------------------------------

// SctExtension

// optional uint32 sct_extension_type = 1;
inline bool SctExtension::has_sct_extension_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SctExtension::set_has_sct_extension_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SctExtension::clear_has_sct_extension_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SctExtension::clear_sct_extension_type() {
  sct_extension_type_ = 0u;
  clear_has_sct_extension_type();
}
inline ::google::protobuf::uint32 SctExtension::sct_extension_type() const {
  // @@protoc_insertion_point(field_get:ct.SctExtension.sct_extension_type)
  return sct_extension_type_;
}
inline void SctExtension::set_sct_extension_type(::google::protobuf::uint32 value) {
  set_has_sct_extension_type();
  sct_extension_type_ = value;
  // @@protoc_insertion_point(field_set:ct.SctExtension.sct_extension_type)
}

// optional bytes sct_extension_data = 2;
inline bool SctExtension::has_sct_extension_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SctExtension::set_has_sct_extension_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SctExtension::clear_has_sct_extension_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SctExtension::clear_sct_extension_data() {
  if (sct_extension_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sct_extension_data_->clear();
  }
  clear_has_sct_extension_data();
}
inline const ::std::string& SctExtension::sct_extension_data() const {
  // @@protoc_insertion_point(field_get:ct.SctExtension.sct_extension_data)
  return *sct_extension_data_;
}
inline void SctExtension::set_sct_extension_data(const ::std::string& value) {
  set_has_sct_extension_data();
  if (sct_extension_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sct_extension_data_ = new ::std::string;
  }
  sct_extension_data_->assign(value);
  // @@protoc_insertion_point(field_set:ct.SctExtension.sct_extension_data)
}
inline void SctExtension::set_sct_extension_data(const char* value) {
  set_has_sct_extension_data();
  if (sct_extension_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sct_extension_data_ = new ::std::string;
  }
  sct_extension_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.SctExtension.sct_extension_data)
}
inline void SctExtension::set_sct_extension_data(const void* value, size_t size) {
  set_has_sct_extension_data();
  if (sct_extension_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sct_extension_data_ = new ::std::string;
  }
  sct_extension_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.SctExtension.sct_extension_data)
}
inline ::std::string* SctExtension::mutable_sct_extension_data() {
  set_has_sct_extension_data();
  if (sct_extension_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sct_extension_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.SctExtension.sct_extension_data)
  return sct_extension_data_;
}
inline ::std::string* SctExtension::release_sct_extension_data() {
  clear_has_sct_extension_data();
  if (sct_extension_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sct_extension_data_;
    sct_extension_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SctExtension::set_allocated_sct_extension_data(::std::string* sct_extension_data) {
  if (sct_extension_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sct_extension_data_;
  }
  if (sct_extension_data) {
    set_has_sct_extension_data();
    sct_extension_data_ = sct_extension_data;
  } else {
    clear_has_sct_extension_data();
    sct_extension_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SctExtension.sct_extension_data)
}

// -------------------------------------------------------------------

// SignedCertificateTimestamp

// optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
inline bool SignedCertificateTimestamp::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedCertificateTimestamp::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedCertificateTimestamp::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedCertificateTimestamp::clear_version() {
  version_ = 256;
  clear_has_version();
}
inline ::ct::Version SignedCertificateTimestamp::version() const {
  // @@protoc_insertion_point(field_get:ct.SignedCertificateTimestamp.version)
  return static_cast< ::ct::Version >(version_);
}
inline void SignedCertificateTimestamp::set_version(::ct::Version value) {
  assert(::ct::Version_IsValid(value));
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:ct.SignedCertificateTimestamp.version)
}

// optional .ct.LogID id = 2;
inline bool SignedCertificateTimestamp::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedCertificateTimestamp::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedCertificateTimestamp::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedCertificateTimestamp::clear_id() {
  if (id_ != NULL) id_->::ct::LogID::Clear();
  clear_has_id();
}
inline const ::ct::LogID& SignedCertificateTimestamp::id() const {
  // @@protoc_insertion_point(field_get:ct.SignedCertificateTimestamp.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::ct::LogID* SignedCertificateTimestamp::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::ct::LogID;
  // @@protoc_insertion_point(field_mutable:ct.SignedCertificateTimestamp.id)
  return id_;
}
inline ::ct::LogID* SignedCertificateTimestamp::release_id() {
  clear_has_id();
  ::ct::LogID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void SignedCertificateTimestamp::set_allocated_id(::ct::LogID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SignedCertificateTimestamp.id)
}

// optional uint64 timestamp = 3;
inline bool SignedCertificateTimestamp::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedCertificateTimestamp::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignedCertificateTimestamp::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignedCertificateTimestamp::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 SignedCertificateTimestamp::timestamp() const {
  // @@protoc_insertion_point(field_get:ct.SignedCertificateTimestamp.timestamp)
  return timestamp_;
}
inline void SignedCertificateTimestamp::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ct.SignedCertificateTimestamp.timestamp)
}

// optional .ct.DigitallySigned signature = 4;
inline bool SignedCertificateTimestamp::has_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignedCertificateTimestamp::set_has_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignedCertificateTimestamp::clear_has_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignedCertificateTimestamp::clear_signature() {
  if (signature_ != NULL) signature_->::ct::DigitallySigned::Clear();
  clear_has_signature();
}
inline const ::ct::DigitallySigned& SignedCertificateTimestamp::signature() const {
  // @@protoc_insertion_point(field_get:ct.SignedCertificateTimestamp.signature)
  return signature_ != NULL ? *signature_ : *default_instance_->signature_;
}
inline ::ct::DigitallySigned* SignedCertificateTimestamp::mutable_signature() {
  set_has_signature();
  if (signature_ == NULL) signature_ = new ::ct::DigitallySigned;
  // @@protoc_insertion_point(field_mutable:ct.SignedCertificateTimestamp.signature)
  return signature_;
}
inline ::ct::DigitallySigned* SignedCertificateTimestamp::release_signature() {
  clear_has_signature();
  ::ct::DigitallySigned* temp = signature_;
  signature_ = NULL;
  return temp;
}
inline void SignedCertificateTimestamp::set_allocated_signature(::ct::DigitallySigned* signature) {
  delete signature_;
  signature_ = signature;
  if (signature) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SignedCertificateTimestamp.signature)
}

// optional bytes extensions = 5;
inline bool SignedCertificateTimestamp::has_extensions() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignedCertificateTimestamp::set_has_extensions() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignedCertificateTimestamp::clear_has_extensions() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignedCertificateTimestamp::clear_extensions() {
  if (extensions_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extensions_->clear();
  }
  clear_has_extensions();
}
inline const ::std::string& SignedCertificateTimestamp::extensions() const {
  // @@protoc_insertion_point(field_get:ct.SignedCertificateTimestamp.extensions)
  return *extensions_;
}
inline void SignedCertificateTimestamp::set_extensions(const ::std::string& value) {
  set_has_extensions();
  if (extensions_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extensions_ = new ::std::string;
  }
  extensions_->assign(value);
  // @@protoc_insertion_point(field_set:ct.SignedCertificateTimestamp.extensions)
}
inline void SignedCertificateTimestamp::set_extensions(const char* value) {
  set_has_extensions();
  if (extensions_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extensions_ = new ::std::string;
  }
  extensions_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.SignedCertificateTimestamp.extensions)
}
inline void SignedCertificateTimestamp::set_extensions(const void* value, size_t size) {
  set_has_extensions();
  if (extensions_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extensions_ = new ::std::string;
  }
  extensions_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.SignedCertificateTimestamp.extensions)
}
inline ::std::string* SignedCertificateTimestamp::mutable_extensions() {
  set_has_extensions();
  if (extensions_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extensions_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.SignedCertificateTimestamp.extensions)
  return extensions_;
}
inline ::std::string* SignedCertificateTimestamp::release_extensions() {
  clear_has_extensions();
  if (extensions_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = extensions_;
    extensions_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignedCertificateTimestamp::set_allocated_extensions(::std::string* extensions) {
  if (extensions_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extensions_;
  }
  if (extensions) {
    set_has_extensions();
    extensions_ = extensions;
  } else {
    clear_has_extensions();
    extensions_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SignedCertificateTimestamp.extensions)
}

// repeated .ct.SctExtension sct_extension = 6;
inline int SignedCertificateTimestamp::sct_extension_size() const {
  return sct_extension_.size();
}
inline void SignedCertificateTimestamp::clear_sct_extension() {
  sct_extension_.Clear();
}
inline const ::ct::SctExtension& SignedCertificateTimestamp::sct_extension(int index) const {
  // @@protoc_insertion_point(field_get:ct.SignedCertificateTimestamp.sct_extension)
  return sct_extension_.Get(index);
}
inline ::ct::SctExtension* SignedCertificateTimestamp::mutable_sct_extension(int index) {
  // @@protoc_insertion_point(field_mutable:ct.SignedCertificateTimestamp.sct_extension)
  return sct_extension_.Mutable(index);
}
inline ::ct::SctExtension* SignedCertificateTimestamp::add_sct_extension() {
  // @@protoc_insertion_point(field_add:ct.SignedCertificateTimestamp.sct_extension)
  return sct_extension_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ct::SctExtension >&
SignedCertificateTimestamp::sct_extension() const {
  // @@protoc_insertion_point(field_list:ct.SignedCertificateTimestamp.sct_extension)
  return sct_extension_;
}
inline ::google::protobuf::RepeatedPtrField< ::ct::SctExtension >*
SignedCertificateTimestamp::mutable_sct_extension() {
  // @@protoc_insertion_point(field_mutable_list:ct.SignedCertificateTimestamp.sct_extension)
  return &sct_extension_;
}

// -------------------------------------------------------------------

// SignedCertificateTimestampList

// repeated bytes sct_list = 1;
inline int SignedCertificateTimestampList::sct_list_size() const {
  return sct_list_.size();
}
inline void SignedCertificateTimestampList::clear_sct_list() {
  sct_list_.Clear();
}
inline const ::std::string& SignedCertificateTimestampList::sct_list(int index) const {
  // @@protoc_insertion_point(field_get:ct.SignedCertificateTimestampList.sct_list)
  return sct_list_.Get(index);
}
inline ::std::string* SignedCertificateTimestampList::mutable_sct_list(int index) {
  // @@protoc_insertion_point(field_mutable:ct.SignedCertificateTimestampList.sct_list)
  return sct_list_.Mutable(index);
}
inline void SignedCertificateTimestampList::set_sct_list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ct.SignedCertificateTimestampList.sct_list)
  sct_list_.Mutable(index)->assign(value);
}
inline void SignedCertificateTimestampList::set_sct_list(int index, const char* value) {
  sct_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.SignedCertificateTimestampList.sct_list)
}
inline void SignedCertificateTimestampList::set_sct_list(int index, const void* value, size_t size) {
  sct_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.SignedCertificateTimestampList.sct_list)
}
inline ::std::string* SignedCertificateTimestampList::add_sct_list() {
  return sct_list_.Add();
}
inline void SignedCertificateTimestampList::add_sct_list(const ::std::string& value) {
  sct_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ct.SignedCertificateTimestampList.sct_list)
}
inline void SignedCertificateTimestampList::add_sct_list(const char* value) {
  sct_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ct.SignedCertificateTimestampList.sct_list)
}
inline void SignedCertificateTimestampList::add_sct_list(const void* value, size_t size) {
  sct_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ct.SignedCertificateTimestampList.sct_list)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SignedCertificateTimestampList::sct_list() const {
  // @@protoc_insertion_point(field_list:ct.SignedCertificateTimestampList.sct_list)
  return sct_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SignedCertificateTimestampList::mutable_sct_list() {
  // @@protoc_insertion_point(field_mutable_list:ct.SignedCertificateTimestampList.sct_list)
  return &sct_list_;
}

// -------------------------------------------------------------------

// SignedEntry

// optional bytes x509 = 1;
inline bool SignedEntry::has_x509() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedEntry::set_has_x509() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedEntry::clear_has_x509() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedEntry::clear_x509() {
  if (x509_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    x509_->clear();
  }
  clear_has_x509();
}
inline const ::std::string& SignedEntry::x509() const {
  // @@protoc_insertion_point(field_get:ct.SignedEntry.x509)
  return *x509_;
}
inline void SignedEntry::set_x509(const ::std::string& value) {
  set_has_x509();
  if (x509_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    x509_ = new ::std::string;
  }
  x509_->assign(value);
  // @@protoc_insertion_point(field_set:ct.SignedEntry.x509)
}
inline void SignedEntry::set_x509(const char* value) {
  set_has_x509();
  if (x509_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    x509_ = new ::std::string;
  }
  x509_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.SignedEntry.x509)
}
inline void SignedEntry::set_x509(const void* value, size_t size) {
  set_has_x509();
  if (x509_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    x509_ = new ::std::string;
  }
  x509_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.SignedEntry.x509)
}
inline ::std::string* SignedEntry::mutable_x509() {
  set_has_x509();
  if (x509_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    x509_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.SignedEntry.x509)
  return x509_;
}
inline ::std::string* SignedEntry::release_x509() {
  clear_has_x509();
  if (x509_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = x509_;
    x509_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignedEntry::set_allocated_x509(::std::string* x509) {
  if (x509_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete x509_;
  }
  if (x509) {
    set_has_x509();
    x509_ = x509;
  } else {
    clear_has_x509();
    x509_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SignedEntry.x509)
}

// optional .ct.PreCert precert = 2;
inline bool SignedEntry::has_precert() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedEntry::set_has_precert() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedEntry::clear_has_precert() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedEntry::clear_precert() {
  if (precert_ != NULL) precert_->::ct::PreCert::Clear();
  clear_has_precert();
}
inline const ::ct::PreCert& SignedEntry::precert() const {
  // @@protoc_insertion_point(field_get:ct.SignedEntry.precert)
  return precert_ != NULL ? *precert_ : *default_instance_->precert_;
}
inline ::ct::PreCert* SignedEntry::mutable_precert() {
  set_has_precert();
  if (precert_ == NULL) precert_ = new ::ct::PreCert;
  // @@protoc_insertion_point(field_mutable:ct.SignedEntry.precert)
  return precert_;
}
inline ::ct::PreCert* SignedEntry::release_precert() {
  clear_has_precert();
  ::ct::PreCert* temp = precert_;
  precert_ = NULL;
  return temp;
}
inline void SignedEntry::set_allocated_precert(::ct::PreCert* precert) {
  delete precert_;
  precert_ = precert;
  if (precert) {
    set_has_precert();
  } else {
    clear_has_precert();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SignedEntry.precert)
}

// optional bytes json = 3;
inline bool SignedEntry::has_json() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedEntry::set_has_json() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignedEntry::clear_has_json() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignedEntry::clear_json() {
  if (json_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    json_->clear();
  }
  clear_has_json();
}
inline const ::std::string& SignedEntry::json() const {
  // @@protoc_insertion_point(field_get:ct.SignedEntry.json)
  return *json_;
}
inline void SignedEntry::set_json(const ::std::string& value) {
  set_has_json();
  if (json_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    json_ = new ::std::string;
  }
  json_->assign(value);
  // @@protoc_insertion_point(field_set:ct.SignedEntry.json)
}
inline void SignedEntry::set_json(const char* value) {
  set_has_json();
  if (json_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    json_ = new ::std::string;
  }
  json_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.SignedEntry.json)
}
inline void SignedEntry::set_json(const void* value, size_t size) {
  set_has_json();
  if (json_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    json_ = new ::std::string;
  }
  json_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.SignedEntry.json)
}
inline ::std::string* SignedEntry::mutable_json() {
  set_has_json();
  if (json_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    json_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.SignedEntry.json)
  return json_;
}
inline ::std::string* SignedEntry::release_json() {
  clear_has_json();
  if (json_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = json_;
    json_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignedEntry::set_allocated_json(::std::string* json) {
  if (json_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete json_;
  }
  if (json) {
    set_has_json();
    json_ = json;
  } else {
    clear_has_json();
    json_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SignedEntry.json)
}

// optional .ct.CertInfo cert_info = 4;
inline bool SignedEntry::has_cert_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignedEntry::set_has_cert_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignedEntry::clear_has_cert_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignedEntry::clear_cert_info() {
  if (cert_info_ != NULL) cert_info_->::ct::CertInfo::Clear();
  clear_has_cert_info();
}
inline const ::ct::CertInfo& SignedEntry::cert_info() const {
  // @@protoc_insertion_point(field_get:ct.SignedEntry.cert_info)
  return cert_info_ != NULL ? *cert_info_ : *default_instance_->cert_info_;
}
inline ::ct::CertInfo* SignedEntry::mutable_cert_info() {
  set_has_cert_info();
  if (cert_info_ == NULL) cert_info_ = new ::ct::CertInfo;
  // @@protoc_insertion_point(field_mutable:ct.SignedEntry.cert_info)
  return cert_info_;
}
inline ::ct::CertInfo* SignedEntry::release_cert_info() {
  clear_has_cert_info();
  ::ct::CertInfo* temp = cert_info_;
  cert_info_ = NULL;
  return temp;
}
inline void SignedEntry::set_allocated_cert_info(::ct::CertInfo* cert_info) {
  delete cert_info_;
  cert_info_ = cert_info;
  if (cert_info) {
    set_has_cert_info();
  } else {
    clear_has_cert_info();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SignedEntry.cert_info)
}

// -------------------------------------------------------------------

// TimestampedEntry

// optional uint64 timestamp = 1;
inline bool TimestampedEntry::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimestampedEntry::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimestampedEntry::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimestampedEntry::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 TimestampedEntry::timestamp() const {
  // @@protoc_insertion_point(field_get:ct.TimestampedEntry.timestamp)
  return timestamp_;
}
inline void TimestampedEntry::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ct.TimestampedEntry.timestamp)
}

// optional .ct.LogEntryType entry_type = 2;
inline bool TimestampedEntry::has_entry_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimestampedEntry::set_has_entry_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimestampedEntry::clear_has_entry_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimestampedEntry::clear_entry_type() {
  entry_type_ = 0;
  clear_has_entry_type();
}
inline ::ct::LogEntryType TimestampedEntry::entry_type() const {
  // @@protoc_insertion_point(field_get:ct.TimestampedEntry.entry_type)
  return static_cast< ::ct::LogEntryType >(entry_type_);
}
inline void TimestampedEntry::set_entry_type(::ct::LogEntryType value) {
  assert(::ct::LogEntryType_IsValid(value));
  set_has_entry_type();
  entry_type_ = value;
  // @@protoc_insertion_point(field_set:ct.TimestampedEntry.entry_type)
}

// optional .ct.SignedEntry signed_entry = 3;
inline bool TimestampedEntry::has_signed_entry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimestampedEntry::set_has_signed_entry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimestampedEntry::clear_has_signed_entry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimestampedEntry::clear_signed_entry() {
  if (signed_entry_ != NULL) signed_entry_->::ct::SignedEntry::Clear();
  clear_has_signed_entry();
}
inline const ::ct::SignedEntry& TimestampedEntry::signed_entry() const {
  // @@protoc_insertion_point(field_get:ct.TimestampedEntry.signed_entry)
  return signed_entry_ != NULL ? *signed_entry_ : *default_instance_->signed_entry_;
}
inline ::ct::SignedEntry* TimestampedEntry::mutable_signed_entry() {
  set_has_signed_entry();
  if (signed_entry_ == NULL) signed_entry_ = new ::ct::SignedEntry;
  // @@protoc_insertion_point(field_mutable:ct.TimestampedEntry.signed_entry)
  return signed_entry_;
}
inline ::ct::SignedEntry* TimestampedEntry::release_signed_entry() {
  clear_has_signed_entry();
  ::ct::SignedEntry* temp = signed_entry_;
  signed_entry_ = NULL;
  return temp;
}
inline void TimestampedEntry::set_allocated_signed_entry(::ct::SignedEntry* signed_entry) {
  delete signed_entry_;
  signed_entry_ = signed_entry;
  if (signed_entry) {
    set_has_signed_entry();
  } else {
    clear_has_signed_entry();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.TimestampedEntry.signed_entry)
}

// optional bytes extensions = 4;
inline bool TimestampedEntry::has_extensions() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimestampedEntry::set_has_extensions() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimestampedEntry::clear_has_extensions() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimestampedEntry::clear_extensions() {
  if (extensions_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extensions_->clear();
  }
  clear_has_extensions();
}
inline const ::std::string& TimestampedEntry::extensions() const {
  // @@protoc_insertion_point(field_get:ct.TimestampedEntry.extensions)
  return *extensions_;
}
inline void TimestampedEntry::set_extensions(const ::std::string& value) {
  set_has_extensions();
  if (extensions_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extensions_ = new ::std::string;
  }
  extensions_->assign(value);
  // @@protoc_insertion_point(field_set:ct.TimestampedEntry.extensions)
}
inline void TimestampedEntry::set_extensions(const char* value) {
  set_has_extensions();
  if (extensions_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extensions_ = new ::std::string;
  }
  extensions_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.TimestampedEntry.extensions)
}
inline void TimestampedEntry::set_extensions(const void* value, size_t size) {
  set_has_extensions();
  if (extensions_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extensions_ = new ::std::string;
  }
  extensions_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.TimestampedEntry.extensions)
}
inline ::std::string* TimestampedEntry::mutable_extensions() {
  set_has_extensions();
  if (extensions_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extensions_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.TimestampedEntry.extensions)
  return extensions_;
}
inline ::std::string* TimestampedEntry::release_extensions() {
  clear_has_extensions();
  if (extensions_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = extensions_;
    extensions_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TimestampedEntry::set_allocated_extensions(::std::string* extensions) {
  if (extensions_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extensions_;
  }
  if (extensions) {
    set_has_extensions();
    extensions_ = extensions;
  } else {
    clear_has_extensions();
    extensions_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.TimestampedEntry.extensions)
}

// repeated .ct.SctExtension sct_extension = 5;
inline int TimestampedEntry::sct_extension_size() const {
  return sct_extension_.size();
}
inline void TimestampedEntry::clear_sct_extension() {
  sct_extension_.Clear();
}
inline const ::ct::SctExtension& TimestampedEntry::sct_extension(int index) const {
  // @@protoc_insertion_point(field_get:ct.TimestampedEntry.sct_extension)
  return sct_extension_.Get(index);
}
inline ::ct::SctExtension* TimestampedEntry::mutable_sct_extension(int index) {
  // @@protoc_insertion_point(field_mutable:ct.TimestampedEntry.sct_extension)
  return sct_extension_.Mutable(index);
}
inline ::ct::SctExtension* TimestampedEntry::add_sct_extension() {
  // @@protoc_insertion_point(field_add:ct.TimestampedEntry.sct_extension)
  return sct_extension_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ct::SctExtension >&
TimestampedEntry::sct_extension() const {
  // @@protoc_insertion_point(field_list:ct.TimestampedEntry.sct_extension)
  return sct_extension_;
}
inline ::google::protobuf::RepeatedPtrField< ::ct::SctExtension >*
TimestampedEntry::mutable_sct_extension() {
  // @@protoc_insertion_point(field_mutable_list:ct.TimestampedEntry.sct_extension)
  return &sct_extension_;
}

// -------------------------------------------------------------------

// MerkleTreeLeaf

// optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
inline bool MerkleTreeLeaf::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MerkleTreeLeaf::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MerkleTreeLeaf::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MerkleTreeLeaf::clear_version() {
  version_ = 256;
  clear_has_version();
}
inline ::ct::Version MerkleTreeLeaf::version() const {
  // @@protoc_insertion_point(field_get:ct.MerkleTreeLeaf.version)
  return static_cast< ::ct::Version >(version_);
}
inline void MerkleTreeLeaf::set_version(::ct::Version value) {
  assert(::ct::Version_IsValid(value));
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:ct.MerkleTreeLeaf.version)
}

// optional .ct.MerkleLeafType type = 2 [default = UNKNOWN_LEAF_TYPE];
inline bool MerkleTreeLeaf::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MerkleTreeLeaf::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MerkleTreeLeaf::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MerkleTreeLeaf::clear_type() {
  type_ = 256;
  clear_has_type();
}
inline ::ct::MerkleLeafType MerkleTreeLeaf::type() const {
  // @@protoc_insertion_point(field_get:ct.MerkleTreeLeaf.type)
  return static_cast< ::ct::MerkleLeafType >(type_);
}
inline void MerkleTreeLeaf::set_type(::ct::MerkleLeafType value) {
  assert(::ct::MerkleLeafType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ct.MerkleTreeLeaf.type)
}

// optional .ct.TimestampedEntry timestamped_entry = 3;
inline bool MerkleTreeLeaf::has_timestamped_entry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MerkleTreeLeaf::set_has_timestamped_entry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MerkleTreeLeaf::clear_has_timestamped_entry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MerkleTreeLeaf::clear_timestamped_entry() {
  if (timestamped_entry_ != NULL) timestamped_entry_->::ct::TimestampedEntry::Clear();
  clear_has_timestamped_entry();
}
inline const ::ct::TimestampedEntry& MerkleTreeLeaf::timestamped_entry() const {
  // @@protoc_insertion_point(field_get:ct.MerkleTreeLeaf.timestamped_entry)
  return timestamped_entry_ != NULL ? *timestamped_entry_ : *default_instance_->timestamped_entry_;
}
inline ::ct::TimestampedEntry* MerkleTreeLeaf::mutable_timestamped_entry() {
  set_has_timestamped_entry();
  if (timestamped_entry_ == NULL) timestamped_entry_ = new ::ct::TimestampedEntry;
  // @@protoc_insertion_point(field_mutable:ct.MerkleTreeLeaf.timestamped_entry)
  return timestamped_entry_;
}
inline ::ct::TimestampedEntry* MerkleTreeLeaf::release_timestamped_entry() {
  clear_has_timestamped_entry();
  ::ct::TimestampedEntry* temp = timestamped_entry_;
  timestamped_entry_ = NULL;
  return temp;
}
inline void MerkleTreeLeaf::set_allocated_timestamped_entry(::ct::TimestampedEntry* timestamped_entry) {
  delete timestamped_entry_;
  timestamped_entry_ = timestamped_entry;
  if (timestamped_entry) {
    set_has_timestamped_entry();
  } else {
    clear_has_timestamped_entry();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.MerkleTreeLeaf.timestamped_entry)
}

// -------------------------------------------------------------------

// MerkleAuditProof

// optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
inline bool MerkleAuditProof::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MerkleAuditProof::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MerkleAuditProof::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MerkleAuditProof::clear_version() {
  version_ = 256;
  clear_has_version();
}
inline ::ct::Version MerkleAuditProof::version() const {
  // @@protoc_insertion_point(field_get:ct.MerkleAuditProof.version)
  return static_cast< ::ct::Version >(version_);
}
inline void MerkleAuditProof::set_version(::ct::Version value) {
  assert(::ct::Version_IsValid(value));
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:ct.MerkleAuditProof.version)
}

// optional .ct.LogID id = 2;
inline bool MerkleAuditProof::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MerkleAuditProof::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MerkleAuditProof::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MerkleAuditProof::clear_id() {
  if (id_ != NULL) id_->::ct::LogID::Clear();
  clear_has_id();
}
inline const ::ct::LogID& MerkleAuditProof::id() const {
  // @@protoc_insertion_point(field_get:ct.MerkleAuditProof.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::ct::LogID* MerkleAuditProof::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::ct::LogID;
  // @@protoc_insertion_point(field_mutable:ct.MerkleAuditProof.id)
  return id_;
}
inline ::ct::LogID* MerkleAuditProof::release_id() {
  clear_has_id();
  ::ct::LogID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void MerkleAuditProof::set_allocated_id(::ct::LogID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.MerkleAuditProof.id)
}

// optional int64 tree_size = 3;
inline bool MerkleAuditProof::has_tree_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MerkleAuditProof::set_has_tree_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MerkleAuditProof::clear_has_tree_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MerkleAuditProof::clear_tree_size() {
  tree_size_ = GOOGLE_LONGLONG(0);
  clear_has_tree_size();
}
inline ::google::protobuf::int64 MerkleAuditProof::tree_size() const {
  // @@protoc_insertion_point(field_get:ct.MerkleAuditProof.tree_size)
  return tree_size_;
}
inline void MerkleAuditProof::set_tree_size(::google::protobuf::int64 value) {
  set_has_tree_size();
  tree_size_ = value;
  // @@protoc_insertion_point(field_set:ct.MerkleAuditProof.tree_size)
}

// optional uint64 timestamp = 4;
inline bool MerkleAuditProof::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MerkleAuditProof::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MerkleAuditProof::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MerkleAuditProof::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 MerkleAuditProof::timestamp() const {
  // @@protoc_insertion_point(field_get:ct.MerkleAuditProof.timestamp)
  return timestamp_;
}
inline void MerkleAuditProof::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ct.MerkleAuditProof.timestamp)
}

// optional int64 leaf_index = 5;
inline bool MerkleAuditProof::has_leaf_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MerkleAuditProof::set_has_leaf_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MerkleAuditProof::clear_has_leaf_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MerkleAuditProof::clear_leaf_index() {
  leaf_index_ = GOOGLE_LONGLONG(0);
  clear_has_leaf_index();
}
inline ::google::protobuf::int64 MerkleAuditProof::leaf_index() const {
  // @@protoc_insertion_point(field_get:ct.MerkleAuditProof.leaf_index)
  return leaf_index_;
}
inline void MerkleAuditProof::set_leaf_index(::google::protobuf::int64 value) {
  set_has_leaf_index();
  leaf_index_ = value;
  // @@protoc_insertion_point(field_set:ct.MerkleAuditProof.leaf_index)
}

// repeated bytes path_node = 6;
inline int MerkleAuditProof::path_node_size() const {
  return path_node_.size();
}
inline void MerkleAuditProof::clear_path_node() {
  path_node_.Clear();
}
inline const ::std::string& MerkleAuditProof::path_node(int index) const {
  // @@protoc_insertion_point(field_get:ct.MerkleAuditProof.path_node)
  return path_node_.Get(index);
}
inline ::std::string* MerkleAuditProof::mutable_path_node(int index) {
  // @@protoc_insertion_point(field_mutable:ct.MerkleAuditProof.path_node)
  return path_node_.Mutable(index);
}
inline void MerkleAuditProof::set_path_node(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ct.MerkleAuditProof.path_node)
  path_node_.Mutable(index)->assign(value);
}
inline void MerkleAuditProof::set_path_node(int index, const char* value) {
  path_node_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.MerkleAuditProof.path_node)
}
inline void MerkleAuditProof::set_path_node(int index, const void* value, size_t size) {
  path_node_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.MerkleAuditProof.path_node)
}
inline ::std::string* MerkleAuditProof::add_path_node() {
  return path_node_.Add();
}
inline void MerkleAuditProof::add_path_node(const ::std::string& value) {
  path_node_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ct.MerkleAuditProof.path_node)
}
inline void MerkleAuditProof::add_path_node(const char* value) {
  path_node_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ct.MerkleAuditProof.path_node)
}
inline void MerkleAuditProof::add_path_node(const void* value, size_t size) {
  path_node_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ct.MerkleAuditProof.path_node)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MerkleAuditProof::path_node() const {
  // @@protoc_insertion_point(field_list:ct.MerkleAuditProof.path_node)
  return path_node_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MerkleAuditProof::mutable_path_node() {
  // @@protoc_insertion_point(field_mutable_list:ct.MerkleAuditProof.path_node)
  return &path_node_;
}

// optional .ct.DigitallySigned tree_head_signature = 7;
inline bool MerkleAuditProof::has_tree_head_signature() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MerkleAuditProof::set_has_tree_head_signature() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MerkleAuditProof::clear_has_tree_head_signature() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MerkleAuditProof::clear_tree_head_signature() {
  if (tree_head_signature_ != NULL) tree_head_signature_->::ct::DigitallySigned::Clear();
  clear_has_tree_head_signature();
}
inline const ::ct::DigitallySigned& MerkleAuditProof::tree_head_signature() const {
  // @@protoc_insertion_point(field_get:ct.MerkleAuditProof.tree_head_signature)
  return tree_head_signature_ != NULL ? *tree_head_signature_ : *default_instance_->tree_head_signature_;
}
inline ::ct::DigitallySigned* MerkleAuditProof::mutable_tree_head_signature() {
  set_has_tree_head_signature();
  if (tree_head_signature_ == NULL) tree_head_signature_ = new ::ct::DigitallySigned;
  // @@protoc_insertion_point(field_mutable:ct.MerkleAuditProof.tree_head_signature)
  return tree_head_signature_;
}
inline ::ct::DigitallySigned* MerkleAuditProof::release_tree_head_signature() {
  clear_has_tree_head_signature();
  ::ct::DigitallySigned* temp = tree_head_signature_;
  tree_head_signature_ = NULL;
  return temp;
}
inline void MerkleAuditProof::set_allocated_tree_head_signature(::ct::DigitallySigned* tree_head_signature) {
  delete tree_head_signature_;
  tree_head_signature_ = tree_head_signature;
  if (tree_head_signature) {
    set_has_tree_head_signature();
  } else {
    clear_has_tree_head_signature();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.MerkleAuditProof.tree_head_signature)
}

// -------------------------------------------------------------------

// ShortMerkleAuditProof

// required int64 leaf_index = 1;
inline bool ShortMerkleAuditProof::has_leaf_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShortMerkleAuditProof::set_has_leaf_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShortMerkleAuditProof::clear_has_leaf_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShortMerkleAuditProof::clear_leaf_index() {
  leaf_index_ = GOOGLE_LONGLONG(0);
  clear_has_leaf_index();
}
inline ::google::protobuf::int64 ShortMerkleAuditProof::leaf_index() const {
  // @@protoc_insertion_point(field_get:ct.ShortMerkleAuditProof.leaf_index)
  return leaf_index_;
}
inline void ShortMerkleAuditProof::set_leaf_index(::google::protobuf::int64 value) {
  set_has_leaf_index();
  leaf_index_ = value;
  // @@protoc_insertion_point(field_set:ct.ShortMerkleAuditProof.leaf_index)
}

// repeated bytes path_node = 2;
inline int ShortMerkleAuditProof::path_node_size() const {
  return path_node_.size();
}
inline void ShortMerkleAuditProof::clear_path_node() {
  path_node_.Clear();
}
inline const ::std::string& ShortMerkleAuditProof::path_node(int index) const {
  // @@protoc_insertion_point(field_get:ct.ShortMerkleAuditProof.path_node)
  return path_node_.Get(index);
}
inline ::std::string* ShortMerkleAuditProof::mutable_path_node(int index) {
  // @@protoc_insertion_point(field_mutable:ct.ShortMerkleAuditProof.path_node)
  return path_node_.Mutable(index);
}
inline void ShortMerkleAuditProof::set_path_node(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ct.ShortMerkleAuditProof.path_node)
  path_node_.Mutable(index)->assign(value);
}
inline void ShortMerkleAuditProof::set_path_node(int index, const char* value) {
  path_node_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.ShortMerkleAuditProof.path_node)
}
inline void ShortMerkleAuditProof::set_path_node(int index, const void* value, size_t size) {
  path_node_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.ShortMerkleAuditProof.path_node)
}
inline ::std::string* ShortMerkleAuditProof::add_path_node() {
  return path_node_.Add();
}
inline void ShortMerkleAuditProof::add_path_node(const ::std::string& value) {
  path_node_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ct.ShortMerkleAuditProof.path_node)
}
inline void ShortMerkleAuditProof::add_path_node(const char* value) {
  path_node_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ct.ShortMerkleAuditProof.path_node)
}
inline void ShortMerkleAuditProof::add_path_node(const void* value, size_t size) {
  path_node_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ct.ShortMerkleAuditProof.path_node)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ShortMerkleAuditProof::path_node() const {
  // @@protoc_insertion_point(field_list:ct.ShortMerkleAuditProof.path_node)
  return path_node_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ShortMerkleAuditProof::mutable_path_node() {
  // @@protoc_insertion_point(field_mutable_list:ct.ShortMerkleAuditProof.path_node)
  return &path_node_;
}

// -------------------------------------------------------------------

// LoggedEntryPB_Contents

// optional .ct.SignedCertificateTimestamp sct = 1;
inline bool LoggedEntryPB_Contents::has_sct() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoggedEntryPB_Contents::set_has_sct() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoggedEntryPB_Contents::clear_has_sct() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoggedEntryPB_Contents::clear_sct() {
  if (sct_ != NULL) sct_->::ct::SignedCertificateTimestamp::Clear();
  clear_has_sct();
}
inline const ::ct::SignedCertificateTimestamp& LoggedEntryPB_Contents::sct() const {
  // @@protoc_insertion_point(field_get:ct.LoggedEntryPB.Contents.sct)
  return sct_ != NULL ? *sct_ : *default_instance_->sct_;
}
inline ::ct::SignedCertificateTimestamp* LoggedEntryPB_Contents::mutable_sct() {
  set_has_sct();
  if (sct_ == NULL) sct_ = new ::ct::SignedCertificateTimestamp;
  // @@protoc_insertion_point(field_mutable:ct.LoggedEntryPB.Contents.sct)
  return sct_;
}
inline ::ct::SignedCertificateTimestamp* LoggedEntryPB_Contents::release_sct() {
  clear_has_sct();
  ::ct::SignedCertificateTimestamp* temp = sct_;
  sct_ = NULL;
  return temp;
}
inline void LoggedEntryPB_Contents::set_allocated_sct(::ct::SignedCertificateTimestamp* sct) {
  delete sct_;
  sct_ = sct;
  if (sct) {
    set_has_sct();
  } else {
    clear_has_sct();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.LoggedEntryPB.Contents.sct)
}

// optional .ct.LogEntry entry = 2;
inline bool LoggedEntryPB_Contents::has_entry() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoggedEntryPB_Contents::set_has_entry() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoggedEntryPB_Contents::clear_has_entry() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoggedEntryPB_Contents::clear_entry() {
  if (entry_ != NULL) entry_->::ct::LogEntry::Clear();
  clear_has_entry();
}
inline const ::ct::LogEntry& LoggedEntryPB_Contents::entry() const {
  // @@protoc_insertion_point(field_get:ct.LoggedEntryPB.Contents.entry)
  return entry_ != NULL ? *entry_ : *default_instance_->entry_;
}
inline ::ct::LogEntry* LoggedEntryPB_Contents::mutable_entry() {
  set_has_entry();
  if (entry_ == NULL) entry_ = new ::ct::LogEntry;
  // @@protoc_insertion_point(field_mutable:ct.LoggedEntryPB.Contents.entry)
  return entry_;
}
inline ::ct::LogEntry* LoggedEntryPB_Contents::release_entry() {
  clear_has_entry();
  ::ct::LogEntry* temp = entry_;
  entry_ = NULL;
  return temp;
}
inline void LoggedEntryPB_Contents::set_allocated_entry(::ct::LogEntry* entry) {
  delete entry_;
  entry_ = entry;
  if (entry) {
    set_has_entry();
  } else {
    clear_has_entry();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.LoggedEntryPB.Contents.entry)
}

// -------------------------------------------------------------------

// LoggedEntryPB

// optional int64 sequence_number = 1;
inline bool LoggedEntryPB::has_sequence_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoggedEntryPB::set_has_sequence_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoggedEntryPB::clear_has_sequence_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoggedEntryPB::clear_sequence_number() {
  sequence_number_ = GOOGLE_LONGLONG(0);
  clear_has_sequence_number();
}
inline ::google::protobuf::int64 LoggedEntryPB::sequence_number() const {
  // @@protoc_insertion_point(field_get:ct.LoggedEntryPB.sequence_number)
  return sequence_number_;
}
inline void LoggedEntryPB::set_sequence_number(::google::protobuf::int64 value) {
  set_has_sequence_number();
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:ct.LoggedEntryPB.sequence_number)
}

// optional bytes merkle_leaf_hash = 2;
inline bool LoggedEntryPB::has_merkle_leaf_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoggedEntryPB::set_has_merkle_leaf_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoggedEntryPB::clear_has_merkle_leaf_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoggedEntryPB::clear_merkle_leaf_hash() {
  if (merkle_leaf_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merkle_leaf_hash_->clear();
  }
  clear_has_merkle_leaf_hash();
}
inline const ::std::string& LoggedEntryPB::merkle_leaf_hash() const {
  // @@protoc_insertion_point(field_get:ct.LoggedEntryPB.merkle_leaf_hash)
  return *merkle_leaf_hash_;
}
inline void LoggedEntryPB::set_merkle_leaf_hash(const ::std::string& value) {
  set_has_merkle_leaf_hash();
  if (merkle_leaf_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merkle_leaf_hash_ = new ::std::string;
  }
  merkle_leaf_hash_->assign(value);
  // @@protoc_insertion_point(field_set:ct.LoggedEntryPB.merkle_leaf_hash)
}
inline void LoggedEntryPB::set_merkle_leaf_hash(const char* value) {
  set_has_merkle_leaf_hash();
  if (merkle_leaf_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merkle_leaf_hash_ = new ::std::string;
  }
  merkle_leaf_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.LoggedEntryPB.merkle_leaf_hash)
}
inline void LoggedEntryPB::set_merkle_leaf_hash(const void* value, size_t size) {
  set_has_merkle_leaf_hash();
  if (merkle_leaf_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merkle_leaf_hash_ = new ::std::string;
  }
  merkle_leaf_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.LoggedEntryPB.merkle_leaf_hash)
}
inline ::std::string* LoggedEntryPB::mutable_merkle_leaf_hash() {
  set_has_merkle_leaf_hash();
  if (merkle_leaf_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merkle_leaf_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.LoggedEntryPB.merkle_leaf_hash)
  return merkle_leaf_hash_;
}
inline ::std::string* LoggedEntryPB::release_merkle_leaf_hash() {
  clear_has_merkle_leaf_hash();
  if (merkle_leaf_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = merkle_leaf_hash_;
    merkle_leaf_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoggedEntryPB::set_allocated_merkle_leaf_hash(::std::string* merkle_leaf_hash) {
  if (merkle_leaf_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete merkle_leaf_hash_;
  }
  if (merkle_leaf_hash) {
    set_has_merkle_leaf_hash();
    merkle_leaf_hash_ = merkle_leaf_hash;
  } else {
    clear_has_merkle_leaf_hash();
    merkle_leaf_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.LoggedEntryPB.merkle_leaf_hash)
}

// required .ct.LoggedEntryPB.Contents contents = 3;
inline bool LoggedEntryPB::has_contents() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoggedEntryPB::set_has_contents() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoggedEntryPB::clear_has_contents() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoggedEntryPB::clear_contents() {
  if (contents_ != NULL) contents_->::ct::LoggedEntryPB_Contents::Clear();
  clear_has_contents();
}
inline const ::ct::LoggedEntryPB_Contents& LoggedEntryPB::contents() const {
  // @@protoc_insertion_point(field_get:ct.LoggedEntryPB.contents)
  return contents_ != NULL ? *contents_ : *default_instance_->contents_;
}
inline ::ct::LoggedEntryPB_Contents* LoggedEntryPB::mutable_contents() {
  set_has_contents();
  if (contents_ == NULL) contents_ = new ::ct::LoggedEntryPB_Contents;
  // @@protoc_insertion_point(field_mutable:ct.LoggedEntryPB.contents)
  return contents_;
}
inline ::ct::LoggedEntryPB_Contents* LoggedEntryPB::release_contents() {
  clear_has_contents();
  ::ct::LoggedEntryPB_Contents* temp = contents_;
  contents_ = NULL;
  return temp;
}
inline void LoggedEntryPB::set_allocated_contents(::ct::LoggedEntryPB_Contents* contents) {
  delete contents_;
  contents_ = contents;
  if (contents) {
    set_has_contents();
  } else {
    clear_has_contents();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.LoggedEntryPB.contents)
}

// -------------------------------------------------------------------

// SthExtension

// optional uint32 sth_extension_type = 1;
inline bool SthExtension::has_sth_extension_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SthExtension::set_has_sth_extension_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SthExtension::clear_has_sth_extension_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SthExtension::clear_sth_extension_type() {
  sth_extension_type_ = 0u;
  clear_has_sth_extension_type();
}
inline ::google::protobuf::uint32 SthExtension::sth_extension_type() const {
  // @@protoc_insertion_point(field_get:ct.SthExtension.sth_extension_type)
  return sth_extension_type_;
}
inline void SthExtension::set_sth_extension_type(::google::protobuf::uint32 value) {
  set_has_sth_extension_type();
  sth_extension_type_ = value;
  // @@protoc_insertion_point(field_set:ct.SthExtension.sth_extension_type)
}

// optional bytes sth_extension_data = 2;
inline bool SthExtension::has_sth_extension_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SthExtension::set_has_sth_extension_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SthExtension::clear_has_sth_extension_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SthExtension::clear_sth_extension_data() {
  if (sth_extension_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sth_extension_data_->clear();
  }
  clear_has_sth_extension_data();
}
inline const ::std::string& SthExtension::sth_extension_data() const {
  // @@protoc_insertion_point(field_get:ct.SthExtension.sth_extension_data)
  return *sth_extension_data_;
}
inline void SthExtension::set_sth_extension_data(const ::std::string& value) {
  set_has_sth_extension_data();
  if (sth_extension_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sth_extension_data_ = new ::std::string;
  }
  sth_extension_data_->assign(value);
  // @@protoc_insertion_point(field_set:ct.SthExtension.sth_extension_data)
}
inline void SthExtension::set_sth_extension_data(const char* value) {
  set_has_sth_extension_data();
  if (sth_extension_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sth_extension_data_ = new ::std::string;
  }
  sth_extension_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.SthExtension.sth_extension_data)
}
inline void SthExtension::set_sth_extension_data(const void* value, size_t size) {
  set_has_sth_extension_data();
  if (sth_extension_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sth_extension_data_ = new ::std::string;
  }
  sth_extension_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.SthExtension.sth_extension_data)
}
inline ::std::string* SthExtension::mutable_sth_extension_data() {
  set_has_sth_extension_data();
  if (sth_extension_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sth_extension_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.SthExtension.sth_extension_data)
  return sth_extension_data_;
}
inline ::std::string* SthExtension::release_sth_extension_data() {
  clear_has_sth_extension_data();
  if (sth_extension_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sth_extension_data_;
    sth_extension_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SthExtension::set_allocated_sth_extension_data(::std::string* sth_extension_data) {
  if (sth_extension_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sth_extension_data_;
  }
  if (sth_extension_data) {
    set_has_sth_extension_data();
    sth_extension_data_ = sth_extension_data;
  } else {
    clear_has_sth_extension_data();
    sth_extension_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SthExtension.sth_extension_data)
}

// -------------------------------------------------------------------

// SignedTreeHead

// optional .ct.Version version = 1 [default = UNKNOWN_VERSION];
inline bool SignedTreeHead::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedTreeHead::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedTreeHead::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedTreeHead::clear_version() {
  version_ = 256;
  clear_has_version();
}
inline ::ct::Version SignedTreeHead::version() const {
  // @@protoc_insertion_point(field_get:ct.SignedTreeHead.version)
  return static_cast< ::ct::Version >(version_);
}
inline void SignedTreeHead::set_version(::ct::Version value) {
  assert(::ct::Version_IsValid(value));
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:ct.SignedTreeHead.version)
}

// optional .ct.LogID id = 2;
inline bool SignedTreeHead::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedTreeHead::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedTreeHead::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedTreeHead::clear_id() {
  if (id_ != NULL) id_->::ct::LogID::Clear();
  clear_has_id();
}
inline const ::ct::LogID& SignedTreeHead::id() const {
  // @@protoc_insertion_point(field_get:ct.SignedTreeHead.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::ct::LogID* SignedTreeHead::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::ct::LogID;
  // @@protoc_insertion_point(field_mutable:ct.SignedTreeHead.id)
  return id_;
}
inline ::ct::LogID* SignedTreeHead::release_id() {
  clear_has_id();
  ::ct::LogID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void SignedTreeHead::set_allocated_id(::ct::LogID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SignedTreeHead.id)
}

// optional uint64 timestamp = 3;
inline bool SignedTreeHead::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedTreeHead::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignedTreeHead::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignedTreeHead::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 SignedTreeHead::timestamp() const {
  // @@protoc_insertion_point(field_get:ct.SignedTreeHead.timestamp)
  return timestamp_;
}
inline void SignedTreeHead::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ct.SignedTreeHead.timestamp)
}

// optional int64 tree_size = 4;
inline bool SignedTreeHead::has_tree_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignedTreeHead::set_has_tree_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignedTreeHead::clear_has_tree_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignedTreeHead::clear_tree_size() {
  tree_size_ = GOOGLE_LONGLONG(0);
  clear_has_tree_size();
}
inline ::google::protobuf::int64 SignedTreeHead::tree_size() const {
  // @@protoc_insertion_point(field_get:ct.SignedTreeHead.tree_size)
  return tree_size_;
}
inline void SignedTreeHead::set_tree_size(::google::protobuf::int64 value) {
  set_has_tree_size();
  tree_size_ = value;
  // @@protoc_insertion_point(field_set:ct.SignedTreeHead.tree_size)
}

// optional bytes sha256_root_hash = 5;
inline bool SignedTreeHead::has_sha256_root_hash() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignedTreeHead::set_has_sha256_root_hash() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignedTreeHead::clear_has_sha256_root_hash() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignedTreeHead::clear_sha256_root_hash() {
  if (sha256_root_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sha256_root_hash_->clear();
  }
  clear_has_sha256_root_hash();
}
inline const ::std::string& SignedTreeHead::sha256_root_hash() const {
  // @@protoc_insertion_point(field_get:ct.SignedTreeHead.sha256_root_hash)
  return *sha256_root_hash_;
}
inline void SignedTreeHead::set_sha256_root_hash(const ::std::string& value) {
  set_has_sha256_root_hash();
  if (sha256_root_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sha256_root_hash_ = new ::std::string;
  }
  sha256_root_hash_->assign(value);
  // @@protoc_insertion_point(field_set:ct.SignedTreeHead.sha256_root_hash)
}
inline void SignedTreeHead::set_sha256_root_hash(const char* value) {
  set_has_sha256_root_hash();
  if (sha256_root_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sha256_root_hash_ = new ::std::string;
  }
  sha256_root_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.SignedTreeHead.sha256_root_hash)
}
inline void SignedTreeHead::set_sha256_root_hash(const void* value, size_t size) {
  set_has_sha256_root_hash();
  if (sha256_root_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sha256_root_hash_ = new ::std::string;
  }
  sha256_root_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.SignedTreeHead.sha256_root_hash)
}
inline ::std::string* SignedTreeHead::mutable_sha256_root_hash() {
  set_has_sha256_root_hash();
  if (sha256_root_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sha256_root_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.SignedTreeHead.sha256_root_hash)
  return sha256_root_hash_;
}
inline ::std::string* SignedTreeHead::release_sha256_root_hash() {
  clear_has_sha256_root_hash();
  if (sha256_root_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sha256_root_hash_;
    sha256_root_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignedTreeHead::set_allocated_sha256_root_hash(::std::string* sha256_root_hash) {
  if (sha256_root_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sha256_root_hash_;
  }
  if (sha256_root_hash) {
    set_has_sha256_root_hash();
    sha256_root_hash_ = sha256_root_hash;
  } else {
    clear_has_sha256_root_hash();
    sha256_root_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SignedTreeHead.sha256_root_hash)
}

// optional .ct.DigitallySigned signature = 6;
inline bool SignedTreeHead::has_signature() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignedTreeHead::set_has_signature() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignedTreeHead::clear_has_signature() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignedTreeHead::clear_signature() {
  if (signature_ != NULL) signature_->::ct::DigitallySigned::Clear();
  clear_has_signature();
}
inline const ::ct::DigitallySigned& SignedTreeHead::signature() const {
  // @@protoc_insertion_point(field_get:ct.SignedTreeHead.signature)
  return signature_ != NULL ? *signature_ : *default_instance_->signature_;
}
inline ::ct::DigitallySigned* SignedTreeHead::mutable_signature() {
  set_has_signature();
  if (signature_ == NULL) signature_ = new ::ct::DigitallySigned;
  // @@protoc_insertion_point(field_mutable:ct.SignedTreeHead.signature)
  return signature_;
}
inline ::ct::DigitallySigned* SignedTreeHead::release_signature() {
  clear_has_signature();
  ::ct::DigitallySigned* temp = signature_;
  signature_ = NULL;
  return temp;
}
inline void SignedTreeHead::set_allocated_signature(::ct::DigitallySigned* signature) {
  delete signature_;
  signature_ = signature;
  if (signature) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SignedTreeHead.signature)
}

// repeated .ct.SthExtension sth_extension = 7;
inline int SignedTreeHead::sth_extension_size() const {
  return sth_extension_.size();
}
inline void SignedTreeHead::clear_sth_extension() {
  sth_extension_.Clear();
}
inline const ::ct::SthExtension& SignedTreeHead::sth_extension(int index) const {
  // @@protoc_insertion_point(field_get:ct.SignedTreeHead.sth_extension)
  return sth_extension_.Get(index);
}
inline ::ct::SthExtension* SignedTreeHead::mutable_sth_extension(int index) {
  // @@protoc_insertion_point(field_mutable:ct.SignedTreeHead.sth_extension)
  return sth_extension_.Mutable(index);
}
inline ::ct::SthExtension* SignedTreeHead::add_sth_extension() {
  // @@protoc_insertion_point(field_add:ct.SignedTreeHead.sth_extension)
  return sth_extension_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ct::SthExtension >&
SignedTreeHead::sth_extension() const {
  // @@protoc_insertion_point(field_list:ct.SignedTreeHead.sth_extension)
  return sth_extension_;
}
inline ::google::protobuf::RepeatedPtrField< ::ct::SthExtension >*
SignedTreeHead::mutable_sth_extension() {
  // @@protoc_insertion_point(field_mutable_list:ct.SignedTreeHead.sth_extension)
  return &sth_extension_;
}

// -------------------------------------------------------------------

// SSLClientCTData_SCTInfo

// optional .ct.SignedCertificateTimestamp sct = 1;
inline bool SSLClientCTData_SCTInfo::has_sct() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSLClientCTData_SCTInfo::set_has_sct() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSLClientCTData_SCTInfo::clear_has_sct() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSLClientCTData_SCTInfo::clear_sct() {
  if (sct_ != NULL) sct_->::ct::SignedCertificateTimestamp::Clear();
  clear_has_sct();
}
inline const ::ct::SignedCertificateTimestamp& SSLClientCTData_SCTInfo::sct() const {
  // @@protoc_insertion_point(field_get:ct.SSLClientCTData.SCTInfo.sct)
  return sct_ != NULL ? *sct_ : *default_instance_->sct_;
}
inline ::ct::SignedCertificateTimestamp* SSLClientCTData_SCTInfo::mutable_sct() {
  set_has_sct();
  if (sct_ == NULL) sct_ = new ::ct::SignedCertificateTimestamp;
  // @@protoc_insertion_point(field_mutable:ct.SSLClientCTData.SCTInfo.sct)
  return sct_;
}
inline ::ct::SignedCertificateTimestamp* SSLClientCTData_SCTInfo::release_sct() {
  clear_has_sct();
  ::ct::SignedCertificateTimestamp* temp = sct_;
  sct_ = NULL;
  return temp;
}
inline void SSLClientCTData_SCTInfo::set_allocated_sct(::ct::SignedCertificateTimestamp* sct) {
  delete sct_;
  sct_ = sct;
  if (sct) {
    set_has_sct();
  } else {
    clear_has_sct();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SSLClientCTData.SCTInfo.sct)
}

// optional bytes merkle_leaf_hash = 2;
inline bool SSLClientCTData_SCTInfo::has_merkle_leaf_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SSLClientCTData_SCTInfo::set_has_merkle_leaf_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SSLClientCTData_SCTInfo::clear_has_merkle_leaf_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SSLClientCTData_SCTInfo::clear_merkle_leaf_hash() {
  if (merkle_leaf_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merkle_leaf_hash_->clear();
  }
  clear_has_merkle_leaf_hash();
}
inline const ::std::string& SSLClientCTData_SCTInfo::merkle_leaf_hash() const {
  // @@protoc_insertion_point(field_get:ct.SSLClientCTData.SCTInfo.merkle_leaf_hash)
  return *merkle_leaf_hash_;
}
inline void SSLClientCTData_SCTInfo::set_merkle_leaf_hash(const ::std::string& value) {
  set_has_merkle_leaf_hash();
  if (merkle_leaf_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merkle_leaf_hash_ = new ::std::string;
  }
  merkle_leaf_hash_->assign(value);
  // @@protoc_insertion_point(field_set:ct.SSLClientCTData.SCTInfo.merkle_leaf_hash)
}
inline void SSLClientCTData_SCTInfo::set_merkle_leaf_hash(const char* value) {
  set_has_merkle_leaf_hash();
  if (merkle_leaf_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merkle_leaf_hash_ = new ::std::string;
  }
  merkle_leaf_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.SSLClientCTData.SCTInfo.merkle_leaf_hash)
}
inline void SSLClientCTData_SCTInfo::set_merkle_leaf_hash(const void* value, size_t size) {
  set_has_merkle_leaf_hash();
  if (merkle_leaf_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merkle_leaf_hash_ = new ::std::string;
  }
  merkle_leaf_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.SSLClientCTData.SCTInfo.merkle_leaf_hash)
}
inline ::std::string* SSLClientCTData_SCTInfo::mutable_merkle_leaf_hash() {
  set_has_merkle_leaf_hash();
  if (merkle_leaf_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merkle_leaf_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.SSLClientCTData.SCTInfo.merkle_leaf_hash)
  return merkle_leaf_hash_;
}
inline ::std::string* SSLClientCTData_SCTInfo::release_merkle_leaf_hash() {
  clear_has_merkle_leaf_hash();
  if (merkle_leaf_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = merkle_leaf_hash_;
    merkle_leaf_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SSLClientCTData_SCTInfo::set_allocated_merkle_leaf_hash(::std::string* merkle_leaf_hash) {
  if (merkle_leaf_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete merkle_leaf_hash_;
  }
  if (merkle_leaf_hash) {
    set_has_merkle_leaf_hash();
    merkle_leaf_hash_ = merkle_leaf_hash;
  } else {
    clear_has_merkle_leaf_hash();
    merkle_leaf_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SSLClientCTData.SCTInfo.merkle_leaf_hash)
}

// -------------------------------------------------------------------

// SSLClientCTData

// optional .ct.LogEntry reconstructed_entry = 1;
inline bool SSLClientCTData::has_reconstructed_entry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSLClientCTData::set_has_reconstructed_entry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSLClientCTData::clear_has_reconstructed_entry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSLClientCTData::clear_reconstructed_entry() {
  if (reconstructed_entry_ != NULL) reconstructed_entry_->::ct::LogEntry::Clear();
  clear_has_reconstructed_entry();
}
inline const ::ct::LogEntry& SSLClientCTData::reconstructed_entry() const {
  // @@protoc_insertion_point(field_get:ct.SSLClientCTData.reconstructed_entry)
  return reconstructed_entry_ != NULL ? *reconstructed_entry_ : *default_instance_->reconstructed_entry_;
}
inline ::ct::LogEntry* SSLClientCTData::mutable_reconstructed_entry() {
  set_has_reconstructed_entry();
  if (reconstructed_entry_ == NULL) reconstructed_entry_ = new ::ct::LogEntry;
  // @@protoc_insertion_point(field_mutable:ct.SSLClientCTData.reconstructed_entry)
  return reconstructed_entry_;
}
inline ::ct::LogEntry* SSLClientCTData::release_reconstructed_entry() {
  clear_has_reconstructed_entry();
  ::ct::LogEntry* temp = reconstructed_entry_;
  reconstructed_entry_ = NULL;
  return temp;
}
inline void SSLClientCTData::set_allocated_reconstructed_entry(::ct::LogEntry* reconstructed_entry) {
  delete reconstructed_entry_;
  reconstructed_entry_ = reconstructed_entry;
  if (reconstructed_entry) {
    set_has_reconstructed_entry();
  } else {
    clear_has_reconstructed_entry();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SSLClientCTData.reconstructed_entry)
}

// optional bytes certificate_sha256_hash = 2;
inline bool SSLClientCTData::has_certificate_sha256_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SSLClientCTData::set_has_certificate_sha256_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SSLClientCTData::clear_has_certificate_sha256_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SSLClientCTData::clear_certificate_sha256_hash() {
  if (certificate_sha256_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    certificate_sha256_hash_->clear();
  }
  clear_has_certificate_sha256_hash();
}
inline const ::std::string& SSLClientCTData::certificate_sha256_hash() const {
  // @@protoc_insertion_point(field_get:ct.SSLClientCTData.certificate_sha256_hash)
  return *certificate_sha256_hash_;
}
inline void SSLClientCTData::set_certificate_sha256_hash(const ::std::string& value) {
  set_has_certificate_sha256_hash();
  if (certificate_sha256_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    certificate_sha256_hash_ = new ::std::string;
  }
  certificate_sha256_hash_->assign(value);
  // @@protoc_insertion_point(field_set:ct.SSLClientCTData.certificate_sha256_hash)
}
inline void SSLClientCTData::set_certificate_sha256_hash(const char* value) {
  set_has_certificate_sha256_hash();
  if (certificate_sha256_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    certificate_sha256_hash_ = new ::std::string;
  }
  certificate_sha256_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.SSLClientCTData.certificate_sha256_hash)
}
inline void SSLClientCTData::set_certificate_sha256_hash(const void* value, size_t size) {
  set_has_certificate_sha256_hash();
  if (certificate_sha256_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    certificate_sha256_hash_ = new ::std::string;
  }
  certificate_sha256_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.SSLClientCTData.certificate_sha256_hash)
}
inline ::std::string* SSLClientCTData::mutable_certificate_sha256_hash() {
  set_has_certificate_sha256_hash();
  if (certificate_sha256_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    certificate_sha256_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.SSLClientCTData.certificate_sha256_hash)
  return certificate_sha256_hash_;
}
inline ::std::string* SSLClientCTData::release_certificate_sha256_hash() {
  clear_has_certificate_sha256_hash();
  if (certificate_sha256_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = certificate_sha256_hash_;
    certificate_sha256_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SSLClientCTData::set_allocated_certificate_sha256_hash(::std::string* certificate_sha256_hash) {
  if (certificate_sha256_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete certificate_sha256_hash_;
  }
  if (certificate_sha256_hash) {
    set_has_certificate_sha256_hash();
    certificate_sha256_hash_ = certificate_sha256_hash;
  } else {
    clear_has_certificate_sha256_hash();
    certificate_sha256_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SSLClientCTData.certificate_sha256_hash)
}

// repeated .ct.SSLClientCTData.SCTInfo attached_sct_info = 3;
inline int SSLClientCTData::attached_sct_info_size() const {
  return attached_sct_info_.size();
}
inline void SSLClientCTData::clear_attached_sct_info() {
  attached_sct_info_.Clear();
}
inline const ::ct::SSLClientCTData_SCTInfo& SSLClientCTData::attached_sct_info(int index) const {
  // @@protoc_insertion_point(field_get:ct.SSLClientCTData.attached_sct_info)
  return attached_sct_info_.Get(index);
}
inline ::ct::SSLClientCTData_SCTInfo* SSLClientCTData::mutable_attached_sct_info(int index) {
  // @@protoc_insertion_point(field_mutable:ct.SSLClientCTData.attached_sct_info)
  return attached_sct_info_.Mutable(index);
}
inline ::ct::SSLClientCTData_SCTInfo* SSLClientCTData::add_attached_sct_info() {
  // @@protoc_insertion_point(field_add:ct.SSLClientCTData.attached_sct_info)
  return attached_sct_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ct::SSLClientCTData_SCTInfo >&
SSLClientCTData::attached_sct_info() const {
  // @@protoc_insertion_point(field_list:ct.SSLClientCTData.attached_sct_info)
  return attached_sct_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ct::SSLClientCTData_SCTInfo >*
SSLClientCTData::mutable_attached_sct_info() {
  // @@protoc_insertion_point(field_mutable_list:ct.SSLClientCTData.attached_sct_info)
  return &attached_sct_info_;
}

// -------------------------------------------------------------------

// ClusterNodeState

// optional string node_id = 1;
inline bool ClusterNodeState::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClusterNodeState::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClusterNodeState::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClusterNodeState::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& ClusterNodeState::node_id() const {
  // @@protoc_insertion_point(field_get:ct.ClusterNodeState.node_id)
  return *node_id_;
}
inline void ClusterNodeState::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set:ct.ClusterNodeState.node_id)
}
inline void ClusterNodeState::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.ClusterNodeState.node_id)
}
inline void ClusterNodeState::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.ClusterNodeState.node_id)
}
inline ::std::string* ClusterNodeState::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.ClusterNodeState.node_id)
  return node_id_;
}
inline ::std::string* ClusterNodeState::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClusterNodeState::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.ClusterNodeState.node_id)
}

// optional int64 contiguous_tree_size = 2 [deprecated = true];
inline bool ClusterNodeState::has_contiguous_tree_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClusterNodeState::set_has_contiguous_tree_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClusterNodeState::clear_has_contiguous_tree_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClusterNodeState::clear_contiguous_tree_size() {
  contiguous_tree_size_ = GOOGLE_LONGLONG(0);
  clear_has_contiguous_tree_size();
}
inline ::google::protobuf::int64 ClusterNodeState::contiguous_tree_size() const {
  // @@protoc_insertion_point(field_get:ct.ClusterNodeState.contiguous_tree_size)
  return contiguous_tree_size_;
}
inline void ClusterNodeState::set_contiguous_tree_size(::google::protobuf::int64 value) {
  set_has_contiguous_tree_size();
  contiguous_tree_size_ = value;
  // @@protoc_insertion_point(field_set:ct.ClusterNodeState.contiguous_tree_size)
}

// optional .ct.SignedTreeHead newest_sth = 3;
inline bool ClusterNodeState::has_newest_sth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClusterNodeState::set_has_newest_sth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClusterNodeState::clear_has_newest_sth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClusterNodeState::clear_newest_sth() {
  if (newest_sth_ != NULL) newest_sth_->::ct::SignedTreeHead::Clear();
  clear_has_newest_sth();
}
inline const ::ct::SignedTreeHead& ClusterNodeState::newest_sth() const {
  // @@protoc_insertion_point(field_get:ct.ClusterNodeState.newest_sth)
  return newest_sth_ != NULL ? *newest_sth_ : *default_instance_->newest_sth_;
}
inline ::ct::SignedTreeHead* ClusterNodeState::mutable_newest_sth() {
  set_has_newest_sth();
  if (newest_sth_ == NULL) newest_sth_ = new ::ct::SignedTreeHead;
  // @@protoc_insertion_point(field_mutable:ct.ClusterNodeState.newest_sth)
  return newest_sth_;
}
inline ::ct::SignedTreeHead* ClusterNodeState::release_newest_sth() {
  clear_has_newest_sth();
  ::ct::SignedTreeHead* temp = newest_sth_;
  newest_sth_ = NULL;
  return temp;
}
inline void ClusterNodeState::set_allocated_newest_sth(::ct::SignedTreeHead* newest_sth) {
  delete newest_sth_;
  newest_sth_ = newest_sth;
  if (newest_sth) {
    set_has_newest_sth();
  } else {
    clear_has_newest_sth();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.ClusterNodeState.newest_sth)
}

// optional .ct.SignedTreeHead current_serving_sth = 4;
inline bool ClusterNodeState::has_current_serving_sth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClusterNodeState::set_has_current_serving_sth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClusterNodeState::clear_has_current_serving_sth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClusterNodeState::clear_current_serving_sth() {
  if (current_serving_sth_ != NULL) current_serving_sth_->::ct::SignedTreeHead::Clear();
  clear_has_current_serving_sth();
}
inline const ::ct::SignedTreeHead& ClusterNodeState::current_serving_sth() const {
  // @@protoc_insertion_point(field_get:ct.ClusterNodeState.current_serving_sth)
  return current_serving_sth_ != NULL ? *current_serving_sth_ : *default_instance_->current_serving_sth_;
}
inline ::ct::SignedTreeHead* ClusterNodeState::mutable_current_serving_sth() {
  set_has_current_serving_sth();
  if (current_serving_sth_ == NULL) current_serving_sth_ = new ::ct::SignedTreeHead;
  // @@protoc_insertion_point(field_mutable:ct.ClusterNodeState.current_serving_sth)
  return current_serving_sth_;
}
inline ::ct::SignedTreeHead* ClusterNodeState::release_current_serving_sth() {
  clear_has_current_serving_sth();
  ::ct::SignedTreeHead* temp = current_serving_sth_;
  current_serving_sth_ = NULL;
  return temp;
}
inline void ClusterNodeState::set_allocated_current_serving_sth(::ct::SignedTreeHead* current_serving_sth) {
  delete current_serving_sth_;
  current_serving_sth_ = current_serving_sth;
  if (current_serving_sth) {
    set_has_current_serving_sth();
  } else {
    clear_has_current_serving_sth();
  }
  // @@protoc_insertion_point(field_set_allocated:ct.ClusterNodeState.current_serving_sth)
}

// optional string hostname = 5;
inline bool ClusterNodeState::has_hostname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClusterNodeState::set_has_hostname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClusterNodeState::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClusterNodeState::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& ClusterNodeState::hostname() const {
  // @@protoc_insertion_point(field_get:ct.ClusterNodeState.hostname)
  return *hostname_;
}
inline void ClusterNodeState::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set:ct.ClusterNodeState.hostname)
}
inline void ClusterNodeState::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.ClusterNodeState.hostname)
}
inline void ClusterNodeState::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.ClusterNodeState.hostname)
}
inline ::std::string* ClusterNodeState::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.ClusterNodeState.hostname)
  return hostname_;
}
inline ::std::string* ClusterNodeState::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClusterNodeState::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.ClusterNodeState.hostname)
}

// optional int32 log_port = 6;
inline bool ClusterNodeState::has_log_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClusterNodeState::set_has_log_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClusterNodeState::clear_has_log_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClusterNodeState::clear_log_port() {
  log_port_ = 0;
  clear_has_log_port();
}
inline ::google::protobuf::int32 ClusterNodeState::log_port() const {
  // @@protoc_insertion_point(field_get:ct.ClusterNodeState.log_port)
  return log_port_;
}
inline void ClusterNodeState::set_log_port(::google::protobuf::int32 value) {
  set_has_log_port();
  log_port_ = value;
  // @@protoc_insertion_point(field_set:ct.ClusterNodeState.log_port)
}

// -------------------------------------------------------------------

// ClusterControl

// optional bool accept_new_entries = 1 [default = true];
inline bool ClusterControl::has_accept_new_entries() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClusterControl::set_has_accept_new_entries() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClusterControl::clear_has_accept_new_entries() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClusterControl::clear_accept_new_entries() {
  accept_new_entries_ = true;
  clear_has_accept_new_entries();
}
inline bool ClusterControl::accept_new_entries() const {
  // @@protoc_insertion_point(field_get:ct.ClusterControl.accept_new_entries)
  return accept_new_entries_;
}
inline void ClusterControl::set_accept_new_entries(bool value) {
  set_has_accept_new_entries();
  accept_new_entries_ = value;
  // @@protoc_insertion_point(field_set:ct.ClusterControl.accept_new_entries)
}

// -------------------------------------------------------------------

// ClusterConfig

// optional int32 minimum_serving_nodes = 1;
inline bool ClusterConfig::has_minimum_serving_nodes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClusterConfig::set_has_minimum_serving_nodes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClusterConfig::clear_has_minimum_serving_nodes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClusterConfig::clear_minimum_serving_nodes() {
  minimum_serving_nodes_ = 0;
  clear_has_minimum_serving_nodes();
}
inline ::google::protobuf::int32 ClusterConfig::minimum_serving_nodes() const {
  // @@protoc_insertion_point(field_get:ct.ClusterConfig.minimum_serving_nodes)
  return minimum_serving_nodes_;
}
inline void ClusterConfig::set_minimum_serving_nodes(::google::protobuf::int32 value) {
  set_has_minimum_serving_nodes();
  minimum_serving_nodes_ = value;
  // @@protoc_insertion_point(field_set:ct.ClusterConfig.minimum_serving_nodes)
}

// optional double minimum_serving_fraction = 2;
inline bool ClusterConfig::has_minimum_serving_fraction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClusterConfig::set_has_minimum_serving_fraction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClusterConfig::clear_has_minimum_serving_fraction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClusterConfig::clear_minimum_serving_fraction() {
  minimum_serving_fraction_ = 0;
  clear_has_minimum_serving_fraction();
}
inline double ClusterConfig::minimum_serving_fraction() const {
  // @@protoc_insertion_point(field_get:ct.ClusterConfig.minimum_serving_fraction)
  return minimum_serving_fraction_;
}
inline void ClusterConfig::set_minimum_serving_fraction(double value) {
  set_has_minimum_serving_fraction();
  minimum_serving_fraction_ = value;
  // @@protoc_insertion_point(field_set:ct.ClusterConfig.minimum_serving_fraction)
}

// optional double etcd_reject_add_pending_threshold = 3 [default = 30000];
inline bool ClusterConfig::has_etcd_reject_add_pending_threshold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClusterConfig::set_has_etcd_reject_add_pending_threshold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClusterConfig::clear_has_etcd_reject_add_pending_threshold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClusterConfig::clear_etcd_reject_add_pending_threshold() {
  etcd_reject_add_pending_threshold_ = 30000;
  clear_has_etcd_reject_add_pending_threshold();
}
inline double ClusterConfig::etcd_reject_add_pending_threshold() const {
  // @@protoc_insertion_point(field_get:ct.ClusterConfig.etcd_reject_add_pending_threshold)
  return etcd_reject_add_pending_threshold_;
}
inline void ClusterConfig::set_etcd_reject_add_pending_threshold(double value) {
  set_has_etcd_reject_add_pending_threshold();
  etcd_reject_add_pending_threshold_ = value;
  // @@protoc_insertion_point(field_set:ct.ClusterConfig.etcd_reject_add_pending_threshold)
}

// -------------------------------------------------------------------

// SequenceMapping_Mapping

// optional bytes entry_hash = 1;
inline bool SequenceMapping_Mapping::has_entry_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SequenceMapping_Mapping::set_has_entry_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SequenceMapping_Mapping::clear_has_entry_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SequenceMapping_Mapping::clear_entry_hash() {
  if (entry_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entry_hash_->clear();
  }
  clear_has_entry_hash();
}
inline const ::std::string& SequenceMapping_Mapping::entry_hash() const {
  // @@protoc_insertion_point(field_get:ct.SequenceMapping.Mapping.entry_hash)
  return *entry_hash_;
}
inline void SequenceMapping_Mapping::set_entry_hash(const ::std::string& value) {
  set_has_entry_hash();
  if (entry_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entry_hash_ = new ::std::string;
  }
  entry_hash_->assign(value);
  // @@protoc_insertion_point(field_set:ct.SequenceMapping.Mapping.entry_hash)
}
inline void SequenceMapping_Mapping::set_entry_hash(const char* value) {
  set_has_entry_hash();
  if (entry_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entry_hash_ = new ::std::string;
  }
  entry_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:ct.SequenceMapping.Mapping.entry_hash)
}
inline void SequenceMapping_Mapping::set_entry_hash(const void* value, size_t size) {
  set_has_entry_hash();
  if (entry_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entry_hash_ = new ::std::string;
  }
  entry_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ct.SequenceMapping.Mapping.entry_hash)
}
inline ::std::string* SequenceMapping_Mapping::mutable_entry_hash() {
  set_has_entry_hash();
  if (entry_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entry_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ct.SequenceMapping.Mapping.entry_hash)
  return entry_hash_;
}
inline ::std::string* SequenceMapping_Mapping::release_entry_hash() {
  clear_has_entry_hash();
  if (entry_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = entry_hash_;
    entry_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SequenceMapping_Mapping::set_allocated_entry_hash(::std::string* entry_hash) {
  if (entry_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete entry_hash_;
  }
  if (entry_hash) {
    set_has_entry_hash();
    entry_hash_ = entry_hash;
  } else {
    clear_has_entry_hash();
    entry_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ct.SequenceMapping.Mapping.entry_hash)
}

// optional int64 sequence_number = 2;
inline bool SequenceMapping_Mapping::has_sequence_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SequenceMapping_Mapping::set_has_sequence_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SequenceMapping_Mapping::clear_has_sequence_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SequenceMapping_Mapping::clear_sequence_number() {
  sequence_number_ = GOOGLE_LONGLONG(0);
  clear_has_sequence_number();
}
inline ::google::protobuf::int64 SequenceMapping_Mapping::sequence_number() const {
  // @@protoc_insertion_point(field_get:ct.SequenceMapping.Mapping.sequence_number)
  return sequence_number_;
}
inline void SequenceMapping_Mapping::set_sequence_number(::google::protobuf::int64 value) {
  set_has_sequence_number();
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:ct.SequenceMapping.Mapping.sequence_number)
}

// -------------------------------------------------------------------

// SequenceMapping

// repeated .ct.SequenceMapping.Mapping mapping = 1;
inline int SequenceMapping::mapping_size() const {
  return mapping_.size();
}
inline void SequenceMapping::clear_mapping() {
  mapping_.Clear();
}
inline const ::ct::SequenceMapping_Mapping& SequenceMapping::mapping(int index) const {
  // @@protoc_insertion_point(field_get:ct.SequenceMapping.mapping)
  return mapping_.Get(index);
}
inline ::ct::SequenceMapping_Mapping* SequenceMapping::mutable_mapping(int index) {
  // @@protoc_insertion_point(field_mutable:ct.SequenceMapping.mapping)
  return mapping_.Mutable(index);
}
inline ::ct::SequenceMapping_Mapping* SequenceMapping::add_mapping() {
  // @@protoc_insertion_point(field_add:ct.SequenceMapping.mapping)
  return mapping_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ct::SequenceMapping_Mapping >&
SequenceMapping::mapping() const {
  // @@protoc_insertion_point(field_list:ct.SequenceMapping.mapping)
  return mapping_;
}
inline ::google::protobuf::RepeatedPtrField< ::ct::SequenceMapping_Mapping >*
SequenceMapping::mutable_mapping() {
  // @@protoc_insertion_point(field_mutable_list:ct.SequenceMapping.mapping)
  return &mapping_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ct

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ct::DigitallySigned_HashAlgorithm> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ct::DigitallySigned_HashAlgorithm>() {
  return ::ct::DigitallySigned_HashAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::ct::DigitallySigned_SignatureAlgorithm> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ct::DigitallySigned_SignatureAlgorithm>() {
  return ::ct::DigitallySigned_SignatureAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::ct::LogEntryType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ct::LogEntryType>() {
  return ::ct::LogEntryType_descriptor();
}
template <> struct is_proto_enum< ::ct::SignatureType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ct::SignatureType>() {
  return ::ct::SignatureType_descriptor();
}
template <> struct is_proto_enum< ::ct::Version> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ct::Version>() {
  return ::ct::Version_descriptor();
}
template <> struct is_proto_enum< ::ct::MerkleLeafType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ct::MerkleLeafType>() {
  return ::ct::MerkleLeafType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fct_2eproto__INCLUDED
